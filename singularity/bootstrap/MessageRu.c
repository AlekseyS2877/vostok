/* Generated by Vostok - Oberon-07 translator */

#include <stdbool.h>

#define O7_BOOL_UNDEFINED
#include <o7.h>

#include "MessageRu.h"

static void C(int s_len0, o7_char s[/*len0*/]) {
	Out_String(s_len0, s);
}

static void S(int s_len0, o7_char s[/*len0*/]) {
	Out_String(s_len0, s);
	Out_Ln();
}

extern void MessageRu_AstError(int code) {
	switch (code) {
	case -1:
		C(80, (o7_char *)"Имя модуля уже встречается в списке импорта");
		break;
	case -2:
		C(44, (o7_char *)"Модуль импортирует себя");
		break;
	case -3:
		C(91, (o7_char *)"Прямой или косвенный циклический импорт запрещён");
		break;
	case -4:
		C(99, (o7_char *)"Повторное объявление имени в той же области видимости");
		break;
	case -5:
		C(83, (o7_char *)"Имя объявления затеняет объявление из модуля");
		break;
	case -6:
		C(84, (o7_char *)"Имя объявления затеняет предопределённое имя");
		break;
	case -7:
		C(80, (o7_char *)"Типы подвыражений в умножении несовместимы");
		break;
	case -8:
		C(76, (o7_char *)"Типы подвыражений в делении несовместимы");
		break;
	case -9:
		C(146, (o7_char *)"В логическом выражении должны использоваться подвыражения логического же типа");
		break;
	case -10:
		C(128, (o7_char *)"В целочисленном делении допустимы только целочисленные подвыражения");
		break;
	case -11:
		C(115, (o7_char *)"В дробном делении допустимы только подвыражения дробного типа");
		break;
	case -12:
		C(111, (o7_char *)"В качестве элементов множества допустимы только целые числа");
		break;
	case -13:
		C(114, (o7_char *)"Элемент множества выходит за границы возможных значений - 0 .. 31");
		break;
	case -14:
		C(72, (o7_char *)"Левый элемент диапазона больше правого");
		break;
	case -15:
		C(109, (o7_char *)"Множество, содержащее 31 не может быть преобразовано в целое");
		break;
	case -16:
		C(78, (o7_char *)"Типы подвыражений в сложении несовместимы");
		break;
	case -17:
		C(103, (o7_char *)"В выражениях *, /, DIV, MOD допустимы только числа и множества");
		break;
	case -18:
		C(93, (o7_char *)"В выражениях +, - допустимы только числа и множества");
		break;
	case -19:
		C(90, (o7_char *)"Унарный знак не применим к логическому выражению");
		break;
	case -20:
		C(79, (o7_char *)"Типы подвыражений в сравнении не совпадают");
		break;
	case -21:
		C(124, (o7_char *)"Левый член выражения должен быть целочисленным, правый - множеством");
		break;
	case -22:
		C(86, (o7_char *)"Правый член выражения IN должен быть множеством");
		break;
	case -23:
		C(90, (o7_char *)"Левый член выражения IN должен быть целочисленным");
		break;
	case -24:
		C(78, (o7_char *)"В сравнении выражения несовместимых типов");
		break;
	case -25:
		C(69, (o7_char *)"Проверка IS применима только к записям");
		break;
	case -26:
		C(121, (o7_char *)"Левый член проверки IS должен иметь тип записи или указателя на неё");
		break;
	case -27:
		C(124, (o7_char *)"Тип переменной слева от IS должен быть того же сорта, что и тип справа");
		break;
	case -28:
		C(129, (o7_char *)"Справа от IS нужен расширенный тип по отношению к типу переменной слева");
		break;
	case -29:
		C(127, (o7_char *)"Постоянная сопоставляется выражению, невычислимым на этапе перевода");
		break;
	case -30:
		C(63, (o7_char *)"Несовместимые типы в присваивании");
		break;
	case -31:
		C(86, (o7_char *)"Ожидалось изменяемое выражение в присваивании");
		break;
	case -32:
		C(122, (o7_char *)"Вызов допустим только для процедур и переменных процедурного типа");
		break;
	case -34:
		C(95, (o7_char *)"Возвращаемое значение не задействовано в выражении");
		break;
	case -33:
		C(88, (o7_char *)"Вызываемая подпрограмма не возвращает значения");
		break;
	case -35:
		C(70, (o7_char *)"Лишние параметры при вызове процедуры");
		break;
	case -36:
		C(52, (o7_char *)"Несовместимый тип параметра");
		break;
	case -37:
		C(78, (o7_char *)"Параметр должен быть изменяемым значением");
		break;
	case -39:
		C(151, (o7_char *)"Для переменного параметра - указателя должен использоваться аргумент того же типа");
		break;
	case -38:
		C(98, (o7_char *)"Не хватает фактических параметров в вызове процедуры");
		break;
	case -40:
		C(97, (o7_char *)"Выражение в CASE должно быть целочисленным или литерой");
		break;
	case -41:
		C(86, (o7_char *)"Метка CASE должна быть целочисленной или литерой");
		break;
	case -42:
		C(90, (o7_char *)"Метки CASE должно быть целочисленными или литерами");
		break;
	case -43:
		C(60, (o7_char *)"Дублирование значения меток в CASE");
		break;
	case -44:
		C(46, (o7_char *)"Не совпадает тип меток CASE");
		break;
	case -45:
		C(124, (o7_char *)"Левая часть диапазона значений в метке CASE должна быть меньше правой");
		break;
	case -46:
		C(60, (o7_char *)"Метки CASE должны быть константами");
		break;
	case -47:
		C(39, (o7_char *)"ELSE ветка в CASE уже есть");
		break;
	case -48:
		C(84, (o7_char *)"Подпрограмма не имеет возвращаемого значения");
		break;
	case -49:
		C(146, (o7_char *)"Тип возвращаемого значения не совместим типом, указанном в заголовке процедуры");
		break;
	case -50:
		C(149, (o7_char *)"Ожидался возврат значения, так как в заголовке процедуры указан возвращаемый тип");
		break;
	case -51:
		C(91, (o7_char *)"Предварительное объявление имени не было найдено");
		break;
	case -53:
		C(134, (o7_char *)"Недопустимое использование константы для задания собственного значения");
		break;
	case -54:
		C(68, (o7_char *)"Импортированный модуль не был найден");
		break;
	case -55:
		C(73, (o7_char *)"Импортированный модуль содержит ошибки");
		break;
	case -56:
		C(76, (o7_char *)"Разыменовывание применено не к указателю");
		break;
	case -57:
		C(51, (o7_char *)"Длина массива должна быть > 0");
		break;
	case -58:
		C(66, (o7_char *)"Общая длина массива слишком большая");
		break;
	case -59:
		C(55, (o7_char *)"Получение элемента не массива");
		break;
	case -60:
		C(59, (o7_char *)"Индекс массива не целочисленный");
		break;
	case -61:
		C(54, (o7_char *)"Отрицательный индекс массива");
		break;
	case -62:
		C(69, (o7_char *)"Индекс массива выходит за его границы");
		break;
	case -63:
		C(79, (o7_char *)"В защите типа ожидается расширенная запись");
		break;
	case -64:
		C(103, (o7_char *)"В защите типа ожидается указатель на расширенную запись");
		break;
	case -65:
		C(140, (o7_char *)"В защите типа переменная должна быть либо записью, либо указателем на запись");
		break;
	case -66:
		C(84, (o7_char *)"Селектор элемента записи применён не к записи");
		break;
	case -67:
		C(39, (o7_char *)"Ожидалась переменная");
		break;
	case -68:
		C(63, (o7_char *)"Итератор FOR не целочисленного типа");
		break;
	case -69:
		C(115, (o7_char *)"Выражение в охране условного оператора должно быть логическим");
		break;
	case -70:
		C(94, (o7_char *)"Выражение в охране цикла WHILE должно быть логическим");
		break;
	case -71:
		C(53, (o7_char *)"Охрана цикла WHILE всегда ложна");
		break;
	case -72:
		C(91, (o7_char *)"Цикл бесконечен, так как охрана WHILE всегда истинна");
		break;
	case -73:
		C(118, (o7_char *)"Выражение в условии завершения цикла REPEAT должно быть логическим");
		break;
	case -74:
		C(104, (o7_char *)"Цикл бесконечен, так как условие завершения всегда ложно");
		break;
	case -75:
		C(63, (o7_char *)"Условие завершения всегда истинно");
		break;
	case -52:
		C(54, (o7_char *)"Объявление не экспортировано");
		break;
	case -76:
		C(98, (o7_char *)"Логическое отрицание применено не к логическому типу");
		break;
	case -77:
		C(69, (o7_char *)"Переполнение при сложении постоянных");
		break;
	case -78:
		C(71, (o7_char *)"Переполнение при вычитании постоянных");
		break;
	case -79:
		C(71, (o7_char *)"Переполнение при умножении постоянных");
		break;
	case -80:
		C(21, (o7_char *)"Деление на 0");
		break;
	case -81:
		C(56, (o7_char *)"Значение выходит за границы BYTE");
		break;
	case -82:
		C(56, (o7_char *)"Значение выходит за границы CHAR");
		break;
	case -83:
		C(64, (o7_char *)"Ожидается целочисленное выражение");
		break;
	case -84:
		C(87, (o7_char *)"Ожидается константное целочисленное выражение");
		break;
	case -85:
		C(63, (o7_char *)"Шаг итератора не может быть равен 0");
		break;
	case -86:
		C(115, (o7_char *)"Для прохода от меньшего к большему шаг итератора должен быть > 0");
		break;
	case -87:
		C(115, (o7_char *)"Для прохода от большего к меньшему шаг итератора должен быть < 0");
		break;
	case -88:
		C(81, (o7_char *)"Во время итерации в FOR возможно переполнение");
		break;
	case -89:
		C(88, (o7_char *)"Использование неинициализированной переменной");
		break;
	case -90:
		C(121, (o7_char *)"Использование переменной, которая может быть не инициализирована");
		break;
	case -91:
		C(62, (o7_char *)"Имя должно указывать на процедуру");
		break;
	case -92:
		C(145, (o7_char *)"В качестве команды может выступать только процедура без возращаемого значения");
		break;
	case -93:
		C(124, (o7_char *)"В качестве команды может выступать только процедура без параметров");
		break;
	case -94:
		C(133, (o7_char *)"Тип возвращаемого значения процедуры не может быть массивом или записью");
		break;
	case -95:
		C(136, (o7_char *)"Есть необъявленная запись, на которую предварительно ссылается указатель");
		break;
	case -96:
		C(79, (o7_char *)"Указатель может ссылаться только на запись");
		break;
	case -99:
		C(52, (o7_char *)"Выражение в Assert всегда ложно");
		break;
	case -97:
		C(107, (o7_char *)"Объявлена переменная, чей тип - это недообъявленная запись");
		break;
	case -98:
		C(93, (o7_char *)"Недообъявленная запись в качестве подтипа массива");
		break;
	case -100:
		C(122, (o7_char *)"Существует незадействованное объявление в этой области видимости");
		break;
	case -101:
		C(77, (o7_char *)"Слишком глубокая вложенность подпрограмм");
		break;
	default:
		o7_case_fail(code);
		break;
	}
}

extern void MessageRu_ParseError(int code) {
	switch (code) {
	case -1:
		C(51, (o7_char *)"Неожиданный символ в тексте");
		break;
	case -2:
		C(63, (o7_char *)"Значение константы слишком велико");
		break;
	case -3:
		C(18, (o7_char *)"ErrRealScaleTooBig");
		break;
	case -4:
		C(16, (o7_char *)"ErrWordLenTooBig");
		break;
	case -5:
		C(76, (o7_char *)"В конце 16-ричного числа ожидается 'H' или 'X'");
		break;
	case -6:
		C(19, (o7_char *)"Ожидалась ");
		C(1, (o7_char *)"\x22");
		break;
	case -7:
		C(21, (o7_char *)"ErrExpectDigitInScale");
		break;
	case -8:
		C(43, (o7_char *)"Незакрытый комментарий");
		break;
	case -101:
		C(27, (o7_char *)"Ожидается 'MODULE'");
		break;
	case -102:
		C(25, (o7_char *)"Ожидается имя");
		break;
	case -103:
		C(22, (o7_char *)"Ожидается ':'");
		break;
	case -104:
		C(22, (o7_char *)"Ожидается ';'");
		break;
	case -105:
		C(24, (o7_char *)"Ожидается 'END'");
		break;
	case -106:
		C(22, (o7_char *)"Ожидается '.'");
		break;
	case -107:
		C(38, (o7_char *)"Ожидается имя модуля");
		break;
	case -108:
		C(22, (o7_char *)"Ожидается '='");
		break;
	case -109:
		C(22, (o7_char *)"Ожидается ')'");
		break;
	case -110:
		C(22, (o7_char *)"Ожидается ']'");
		break;
	case -111:
		C(22, (o7_char *)"Ожидается '}'");
		break;
	case -112:
		C(21, (o7_char *)"Ожидается OF");
		break;
	case -115:
		C(21, (o7_char *)"Ожидается TO");
		break;
	case -116:
		C(120, (o7_char *)"Ожидается структурный тип: массив, запись, указатель, процедурный");
		break;
	case -117:
		C(31, (o7_char *)"Ожидается запись");
		break;
	case -118:
		C(35, (o7_char *)"Ожидается оператор");
		break;
	case -119:
		C(23, (o7_char *)"Ожидается THEN");
		break;
	case -120:
		C(21, (o7_char *)"Ожидается :=");
		break;
	case -122:
		C(101, (o7_char *)"Ожидается переменная типа запись либо указателя на неё");
		break;
	case -124:
		C(25, (o7_char *)"Ожидается тип");
		break;
	case -125:
		C(24, (o7_char *)"Ожидается UNTIL");
		break;
	case -126:
		C(21, (o7_char *)"Ожидается DO");
		break;
	case -128:
		C(41, (o7_char *)"Ожидается обозначение");
		break;
	case -130:
		C(37, (o7_char *)"Ожидается процедура");
		break;
	case -131:
		C(44, (o7_char *)"Ожидается имя константы");
		break;
	case -132:
		C(67, (o7_char *)"Ожидается завершающее имя процедуры");
		break;
	case -133:
		C(37, (o7_char *)"Ожидается выражение");
		break;
	case -135:
		C(16, (o7_char *)"Лишняя ';'");
		break;
	case -150:
		C(103, (o7_char *)"Завершающее имя в конце модуля не совпадает с его именем");
		break;
	case -152:
		C(63, (o7_char *)"Слишком большая n-мерность массива");
		break;
	case -153:
		C(105, (o7_char *)"Завершающее имя в теле процедуры не совпадает с её именем");
		break;
	case -154:
		C(121, (o7_char *)"Объявление процедуры с возвращаемым значением не содержит скобки");
		break;
	case -134:
		C(49, (o7_char *)"Ожидалось число или строка");
		break;
	case -136:
		C(103, (o7_char *)"Неуместный '='. Возможно, имелcя ввиду ':=' для присваивания");
		break;
	case -137:
		C(105, (o7_char *)"В качестве метки CASE недопустимы не односимвольные строки");
		break;
	case -151:
		C(58, (o7_char *)"Ожидался модуль с другим именем");
		break;
	default:
		o7_case_fail(code);
		break;
	}
}

extern void MessageRu_Usage(void) {
	S(28, (o7_char *)"Использование: ");
	S(13, (o7_char *)"  1) o7c help");
	S(76, (o7_char *)"  2) o7c to-c   Код ВыхКат {-m ПкМ | -i ПкИ | -infr Инфр}");
	S(105, (o7_char *)"  3) o7c to-bin Код Исполн {-m ПМ|-i ПИ|-infr И|-c ПHC|-cc Компил|-t ВремКат}");
	S(87, (o7_char *)"  4) o7c run    Код {-m ПкМ|-i ПкИ|-c ПHC|-t ВремКат} [-- Пар-ры]");
	S(89, (o7_char *)"2) to-c   преобразовывает модули в набор .h и .c файлов");
	S(116, (o7_char *)"3) to-bin превращает модули в исполнимый файл через неявные .c файлы");
	S(107, (o7_char *)"4) run    выполняет неявный исполнимый файл, созданный по Коду");
	S(137, (o7_char *)"Код - это упрощенный текст на Обероне, выражаемый через разновидность РБНФ:");
	S(109, (o7_char *)"  Код = Вызов { ; Вызов } . Вызов = Модуль.Процедура [ '('Пар-ры')' ] .");
	S(99, (o7_char *)"ВыхКат - Выходной Каталог для создаваемых .h и .c файлов.");
	S(81, (o7_char *)"Исполн - имя создаваемого исполнимого файла.");
	S(97, (o7_char *)"-m ПкМ - Путь к каталогу с Модулями, нужного для поиска.");
	S(51, (o7_char *)"  Пример: -m library -m source -m test/source");
	S(136, (o7_char *)"-i ПкИ - Путь к каталогу с Интерфейсными модулями без настоящего воплощения");
	S(41, (o7_char *)"  Пример: -i singularity/definition");
	S(130, (o7_char *)"-c ПHC - Путь к каталогу с .h и .c файлами-воплощениями интерфейсных модулей");
	S(45, (o7_char *)"  Пример: -c singularity/implementation");
	S(107, (o7_char *)"-infr Инфр - путь к Инфр_аструктуре. '-infr p' - это сокращение для:");
	S(74, (o7_char *)"  -i p/singularity/definition -c p/singularity/implementation -m p/library");
	S(135, (o7_char *)"-t ВремКат - новый Временный Каталог для хранения промежуточного .h и .c кода");
	S(42, (o7_char *)"  Пример: -t result/test/ReadDir.src");
	S(108, (o7_char *)"-cc Компил - Компилятро C для сбора .c-кода, по умолчанию 'cc -g -O1'");
	S(40, (o7_char *)"  Пример: -cc 'clang -O3 -flto -s'");
	S(133, (o7_char *)"-- Пар-ры - Параметры командной строки для запускаемого исполнимого файла");
}

extern void MessageRu_CliError(int err, int cmd_len0, o7_char cmd[/*len0*/]) {
	switch (err) {
	case -10:
		MessageRu_Usage();
		break;
	case -11:
		S(66, (o7_char *)"Слишком длинное имя исходного файла");
		Out_Ln();
		break;
	case -12:
		S(53, (o7_char *)"Слишком длинное выходное имя");
		Out_Ln();
		break;
	case -13:
		S(66, (o7_char *)"Не получается открыть исходный файл");
		break;
	case -14:
		S(69, (o7_char *)"Не получается открыть выходной .h файл");
		break;
	case -15:
		S(69, (o7_char *)"Не получается открыть выходной .c файл");
		break;
	case -16:
		C(39, (o7_char *)"Неизвестная команда: ");
		S(cmd_len0, cmd);
		MessageRu_Usage();
		break;
	case -17:
		C(69, (o7_char *)"Недостаточно аргументов для команды: ");
		S(cmd_len0, cmd);
		break;
	case -18:
		S(88, (o7_char *)"Суммарная длина путей с модулями слишком велика");
		break;
	case -19:
		S(55, (o7_char *)"Cлишком много путей с модулями");
		break;
	case -20:
		S(89, (o7_char *)"Суммарная длина путей с .c-файлами слишком велика");
		break;
	case -21:
		S(74, (o7_char *)"Длина опций компилятора C слишком велика");
		break;
	case -22:
		S(72, (o7_char *)"Имя временного каталога слишком велико");
		break;
	case -23:
		S(57, (o7_char *)"Ошибка при вызове компилятора C");
		break;
	case -24:
		S(80, (o7_char *)"Слишком длинные параметры командной строки");
		break;
	case -25:
		S(39, (o7_char *)"Неожиданный аргумент");
		break;
	case -26:
		S(111, (o7_char *)"Указанный способ инициализации переменных науке неизвестен");
		break;
	case -27:
		S(72, (o7_char *)"Не получается создать выходной каталог");
		break;
	case -28:
		S(72, (o7_char *)"Не получается удалить выходной каталог");
		break;
	case -29:
		S(40, (o7_char *)"Не найден компилятор C");
		break;
	default:
		o7_case_fail(err);
		break;
	}
}

extern void MessageRu_Text(int str_len0, o7_char str[/*len0*/]) {
	if (o7_strcmp(str_len0, str, 27, (o7_char *)"Found errors in the module ") == 0) {
		C(44, (o7_char *)"Найдены ошибки в модуле ");
	} else if (o7_strcmp(str_len0, str, 37, (o7_char *)"Can not found or open file of module ") == 0) {
		C(81, (o7_char *)"Не получается найти или открыть файл модуля ");
	} else {
		C(str_len0, str);
	}
}

extern void MessageRu_init(void) {
	static int initialized = 0;
	if (0 == initialized) {
		Ast_init();
		Parser_init();
		CliParser_init();
		Scanner_init();
		Out_init();
		Utf8_init();

	}
	++initialized;
}

