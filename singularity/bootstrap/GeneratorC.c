/* Generated by Vostok - Oberon-07 translator */

#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <assert.h>
#include <math.h>
#include <stdbool.h>

#define O7C_BOOL_UNDEFINED
#include <o7c.h>

#include "GeneratorC.h"

#define Interface_cnst 1
#define Implementation_cnst 0

o7c_tag_t GeneratorC_MemoryOut_tag;
extern void GeneratorC_MemoryOut_undef(struct GeneratorC_MemoryOut *r) {
	VDataStream_Out_undef(&r->_);
	memset(&r->mem, 0, sizeof(r->mem));
	r->invert = O7C_BOOL_UNDEF;
	r->next = NULL;
}
o7c_tag_t GeneratorC_Options_s_tag;
extern void GeneratorC_Options_s_undef(struct GeneratorC_Options_s *r) {
	V_Base_undef(&r->_);
	r->std = O7C_INT_UNDEF;
	r->gnu = O7C_BOOL_UNDEF;
	r->plan9 = O7C_BOOL_UNDEF;
	r->procLocal = O7C_BOOL_UNDEF;
	r->checkIndex = O7C_BOOL_UNDEF;
	r->vla = O7C_BOOL_UNDEF;
	r->checkArith = O7C_BOOL_UNDEF;
	r->caseAbort = O7C_BOOL_UNDEF;
	r->comment = O7C_BOOL_UNDEF;
	r->generatorNote = O7C_BOOL_UNDEF;
	r->varInit = O7C_INT_UNDEF;
	r->memManager = O7C_INT_UNDEF;
	r->main_ = O7C_BOOL_UNDEF;
	r->index = O7C_INT_UNDEF;
	r->records = NULL;
	r->recordLast = NULL;
	r->lastSelectorDereference = O7C_BOOL_UNDEF;
	r->memOuts = NULL;
}
o7c_tag_t GeneratorC_Generator_tag;
extern void GeneratorC_Generator_undef(struct GeneratorC_Generator *r) {
	TextGenerator_Out_undef(&r->_);
	r->module = NULL;
	r->localDeep = O7C_INT_UNDEF;
	r->fixedLen = O7C_INT_UNDEF;
	r->interface_ = O7C_BOOL_UNDEF;
	r->opt = NULL;
	r->expressionSemicolon = O7C_BOOL_UNDEF;
	r->insideSizeOf = O7C_BOOL_UNDEF;
}
typedef struct MOut {
	struct GeneratorC_Generator g[2];
	struct GeneratorC_Options_s *opt;
} MOut;
static o7c_tag_t MOut_tag;

static void MOut_undef(struct MOut *r) {
	o7c_int_t i;
	for (i = 0; i < O7C_LEN(r->g); i += 1) {
		GeneratorC_Generator_undef(r->g + i);
	}
	r->opt = NULL;
}
typedef struct Selectors {
	struct Ast_Designator_s *des;
	struct Ast_RDeclaration *decl;
	struct Ast_RSelector *list[TranslatorLimits_MaxSelectors_cnst];
	int i;
} Selectors;
static o7c_tag_t Selectors_tag;

static void Selectors_undef(struct Selectors *r) {
	r->des = NULL;
	r->decl = NULL;
	memset(&r->list, 0, sizeof(r->list));
	r->i = O7C_INT_UNDEF;
}
typedef struct RecExt_s {
	V_Base _;
	struct StringStore_String anonName;
	o7c_bool undef;
	struct Ast_Record_s *next;
} *RecExt;
static o7c_tag_t RecExt_s_tag;

static void RecExt_s_undef(struct RecExt_s *r) {
	V_Base_undef(&r->_);
	StringStore_String_undef(&r->anonName);
	r->undef = O7C_BOOL_UNDEF;
	r->next = NULL;
}

static void (*type)(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *decl, struct Ast_RType *type, o7c_bool typeDecl, o7c_bool sameType) = NULL;
static void (*declarator)(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *decl, o7c_bool typeDecl, o7c_bool sameType, o7c_bool global) = NULL;
static void (*declarations)(struct MOut *out, o7c_tag_t out_tag, struct Ast_RDeclarations *ds) = NULL;
static void (*statements)(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RStatement *stats) = NULL;
static void (*expression)(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *expr) = NULL;

static void MemoryWrite(struct GeneratorC_MemoryOut *out, o7c_tag_t out_tag, int buf_len0, o7c_char buf[/*len0*/], int ofs, int count) {
	o7c_bool ret = O7C_BOOL_UNDEF;

	ret = StringStore_CopyChars(4096, (*out).mem[o7c_ind(2, (int)(*out).invert)].buf, &(*out).mem[o7c_ind(2, (int)(*out).invert)].len, buf_len0, buf, ofs, o7c_add(ofs, count));
	assert(o7c_bl(ret));
}

static int MemWrite(struct VDataStream_Out *out, o7c_tag_t out_tag, int buf_len0, o7c_char buf[/*len0*/], int ofs, int count) {
	MemoryWrite(&O7C_GUARD_R(GeneratorC_MemoryOut, &(*out), out_tag), GeneratorC_MemoryOut_tag, buf_len0, buf, ofs, count);
	return count;
}

/* TODO заменить на NIL после иправления проверки совместимости ProcType и NIL*/
static int MemWriteBytes(struct VDataStream_Out *out, o7c_tag_t out_tag, int buf_len0, char unsigned buf[/*len0*/], int ofs, int count) {
	assert(false);
	return  - 1;
}

static struct GeneratorC_MemoryOut *PMemoryOutGet(struct GeneratorC_Options_s *opt) {
	struct GeneratorC_MemoryOut *m = NULL;

	if (opt->memOuts == NULL) {
		O7C_NEW(&m, GeneratorC_MemoryOut);
		VDataStream_InitOut(&(*m)._, GeneratorC_MemoryOut_tag, MemWriteBytes, MemWrite);
	} else {
		m = opt->memOuts;
		opt->memOuts = m->next;
	}
	m->mem[0].len = 0;
	m->mem[1].len = 0;
	m->invert = false;
	m->next = NULL;
	return m;
}

static void PMemoryOutBack(struct GeneratorC_Options_s *opt, struct GeneratorC_MemoryOut *m) {
	m->next = opt->memOuts;
	opt->memOuts = m;
}

static void MemWriteInvert(struct GeneratorC_MemoryOut *mo, o7c_tag_t mo_tag) {
	int inv = O7C_INT_UNDEF;
	o7c_bool ret = O7C_BOOL_UNDEF;

	inv = (int)(*mo).invert;
	if (o7c_cmp((*mo).mem[o7c_ind(2, inv)].len, 0) ==  0) {
		(*mo).invert = !(*mo).invert;
	} else {
		ret = StringStore_CopyChars(4096, (*mo).mem[o7c_ind(2, inv)].buf, &(*mo).mem[o7c_ind(2, inv)].len, 4096, (*mo).mem[o7c_ind(2, o7c_sub(1, inv))].buf, 0, (*mo).mem[o7c_ind(2, o7c_sub(1, inv))].len);
		assert(o7c_bl(ret));
		(*mo).mem[o7c_ind(2, o7c_sub(1, inv))].len = 0;
	}
}

static void MemWriteDirect(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct GeneratorC_MemoryOut *mo, o7c_tag_t mo_tag) {
	int inv = O7C_INT_UNDEF;

	inv = (int)(*mo).invert;
	assert(o7c_cmp((*mo).mem[o7c_ind(2, o7c_sub(1, inv))].len, 0) ==  0);
	TextGenerator_Data(&(*gen)._, gen_tag, 4096, (*mo).mem[o7c_ind(2, inv)].buf, 0, (*mo).mem[o7c_ind(2, inv)].len);
	(*mo).mem[o7c_ind(2, inv)].len = 0;
}

static o7c_bool Eq(struct StringStore_String *name, o7c_tag_t name_tag, int str_len0, o7c_char str[/*len0*/]) {
	return StringStore_IsEqualToString(&(*name), name_tag, str_len0, str);
}

static o7c_bool IsNameOccupied(struct StringStore_String *n, o7c_tag_t n_tag);
static o7c_bool IsNameOccupied_CKeyWord(struct StringStore_String *n, o7c_tag_t n_tag) {
	o7c_bool o = O7C_BOOL_UNDEF;

	switch ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)]) {
	case 97:
		o = Eq(&(*n), n_tag, 5, (o7c_char *)"auto") || Eq(&(*n), n_tag, 4, (o7c_char *)"asm");
		break;
	case 98:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"break");
		break;
	case 99:
		o = Eq(&(*n), n_tag, 5, (o7c_char *)"case") || Eq(&(*n), n_tag, 5, (o7c_char *)"char") || Eq(&(*n), n_tag, 6, (o7c_char *)"const") || Eq(&(*n), n_tag, 9, (o7c_char *)"continue");
		break;
	case 100:
		o = Eq(&(*n), n_tag, 8, (o7c_char *)"default") || Eq(&(*n), n_tag, 3, (o7c_char *)"do") || Eq(&(*n), n_tag, 7, (o7c_char *)"double");
		break;
	case 101:
		o = Eq(&(*n), n_tag, 5, (o7c_char *)"else") || Eq(&(*n), n_tag, 5, (o7c_char *)"enum") || Eq(&(*n), n_tag, 7, (o7c_char *)"extern");
		break;
	case 102:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"float") || Eq(&(*n), n_tag, 4, (o7c_char *)"for");
		break;
	case 103:
		o = Eq(&(*n), n_tag, 5, (o7c_char *)"goto");
		break;
	case 105:
		o = Eq(&(*n), n_tag, 3, (o7c_char *)"if") || Eq(&(*n), n_tag, 7, (o7c_char *)"inline") || Eq(&(*n), n_tag, 4, (o7c_char *)"int");
		break;
	case 108:
		o = Eq(&(*n), n_tag, 5, (o7c_char *)"long");
		break;
	case 114:
		o = Eq(&(*n), n_tag, 9, (o7c_char *)"register") || Eq(&(*n), n_tag, 9, (o7c_char *)"restrict") || Eq(&(*n), n_tag, 7, (o7c_char *)"return");
		break;
	case 115:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"short") || Eq(&(*n), n_tag, 7, (o7c_char *)"signed") || Eq(&(*n), n_tag, 7, (o7c_char *)"sizeof") || Eq(&(*n), n_tag, 7, (o7c_char *)"static") || Eq(&(*n), n_tag, 7, (o7c_char *)"struct") || Eq(&(*n), n_tag, 7, (o7c_char *)"switch");
		break;
	case 116:
		o = Eq(&(*n), n_tag, 8, (o7c_char *)"typedef") || Eq(&(*n), n_tag, 7, (o7c_char *)"typeof");
		break;
	case 117:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"union") || Eq(&(*n), n_tag, 9, (o7c_char *)"unsigned");
		break;
	case 118:
		o = Eq(&(*n), n_tag, 5, (o7c_char *)"void") || Eq(&(*n), n_tag, 9, (o7c_char *)"volatile");
		break;
	case 119:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"while");
		break;
	default:
		if (((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 104) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 106) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 107) || (109 <= (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] && (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] <= 113) || (120 <= (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] && (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] <= 122)) {
			o = false;
		} else abort();
		break;
	}
	return o;
}

static o7c_bool IsNameOccupied_CLib(struct StringStore_String *n, o7c_tag_t n_tag) {
	o7c_bool o = O7C_BOOL_UNDEF;

	switch ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)]) {
	case 97:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"abort") || Eq(&(*n), n_tag, 7, (o7c_char *)"assert") || Eq(&(*n), n_tag, 5, (o7c_char *)"atof") || Eq(&(*n), n_tag, 5, (o7c_char *)"atoi") || Eq(&(*n), n_tag, 5, (o7c_char *)"atol") || Eq(&(*n), n_tag, 6, (o7c_char *)"atoll") || Eq(&(*n), n_tag, 4, (o7c_char *)"abs") || Eq(&(*n), n_tag, 7, (o7c_char *)"atexit");
		break;
	case 98:
		o = Eq(&(*n), n_tag, 5, (o7c_char *)"bool") || Eq(&(*n), n_tag, 8, (o7c_char *)"bsearch");
		break;
	case 99:
		o = Eq(&(*n), n_tag, 7, (o7c_char *)"calloc");
		break;
	case 100:
		o = Eq(&(*n), n_tag, 4, (o7c_char *)"div");
		break;
	case 101:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"errno") || Eq(&(*n), n_tag, 5, (o7c_char *)"exit");
		break;
	case 102:
		o = Eq(&(*n), n_tag, 5, (o7c_char *)"free");
		break;
	case 103:
		o = Eq(&(*n), n_tag, 7, (o7c_char *)"getenv");
		break;
	case 108:
		o = Eq(&(*n), n_tag, 5, (o7c_char *)"labs") || Eq(&(*n), n_tag, 5, (o7c_char *)"ldiv") || Eq(&(*n), n_tag, 6, (o7c_char *)"llabs") || Eq(&(*n), n_tag, 6, (o7c_char *)"lldiv");
		break;
	case 109:
		o = Eq(&(*n), n_tag, 5, (o7c_char *)"main") || Eq(&(*n), n_tag, 7, (o7c_char *)"malloc") || Eq(&(*n), n_tag, 7, (o7c_char *)"memchr") || Eq(&(*n), n_tag, 7, (o7c_char *)"memcmp") || Eq(&(*n), n_tag, 7, (o7c_char *)"memcpy") || Eq(&(*n), n_tag, 7, (o7c_char *)"memset") || Eq(&(*n), n_tag, 6, (o7c_char *)"mblen") || Eq(&(*n), n_tag, 7, (o7c_char *)"mbtowc") || Eq(&(*n), n_tag, 9, (o7c_char *)"mbstowcs");
		break;
	case 113:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"qsort");
		break;
	case 114:
		o = Eq(&(*n), n_tag, 5, (o7c_char *)"rand") || Eq(&(*n), n_tag, 8, (o7c_char *)"realloc");
		break;
	case 115:
		o = Eq(&(*n), n_tag, 8, (o7c_char *)"strcspn") || Eq(&(*n), n_tag, 9, (o7c_char *)"strerror") || Eq(&(*n), n_tag, 7, (o7c_char *)"strspn") || Eq(&(*n), n_tag, 8, (o7c_char *)"strrchr") || Eq(&(*n), n_tag, 8, (o7c_char *)"strpbrk") || Eq(&(*n), n_tag, 7, (o7c_char *)"strchr") || Eq(&(*n), n_tag, 7, (o7c_char *)"strcat") || Eq(&(*n), n_tag, 7, (o7c_char *)"strstr") || Eq(&(*n), n_tag, 8, (o7c_char *)"strncat") || Eq(&(*n), n_tag, 7, (o7c_char *)"strcmp") || Eq(&(*n), n_tag, 8, (o7c_char *)"strcoll") || Eq(&(*n), n_tag, 7, (o7c_char *)"strcpy") || Eq(&(*n), n_tag, 8, (o7c_char *)"strncpy") || Eq(&(*n), n_tag, 7, (o7c_char *)"strlen") || Eq(&(*n), n_tag, 7, (o7c_char *)"strtok") || Eq(&(*n), n_tag, 7, (o7c_char *)"strtol") || Eq(&(*n), n_tag, 8, (o7c_char *)"strtoll") || Eq(&(*n), n_tag, 8, (o7c_char *)"strtoul") || Eq(&(*n), n_tag, 9, (o7c_char *)"strtoull") || Eq(&(*n), n_tag, 7, (o7c_char *)"strtod") || Eq(&(*n), n_tag, 7, (o7c_char *)"strtof") || Eq(&(*n), n_tag, 8, (o7c_char *)"strtold") || Eq(&(*n), n_tag, 8, (o7c_char *)"strxfrm") || Eq(&(*n), n_tag, 6, (o7c_char *)"srand") || Eq(&(*n), n_tag, 7, (o7c_char *)"system");
		break;
	case 119:
		o = Eq(&(*n), n_tag, 7, (o7c_char *)"wctomb") || Eq(&(*n), n_tag, 9, (o7c_char *)"wcstombs");
		break;
	default:
		if (((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 104) || (105 <= (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] && (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] <= 107) || (110 <= (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] && (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] <= 112) || (116 <= (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] && (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] <= 118) || (120 <= (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] && (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] <= 122)) {
			o = false;
		} else abort();
		break;
	}
	return o;
}

static o7c_bool IsNameOccupied_CppKeyWord(struct StringStore_String *n, o7c_tag_t n_tag) {
	o7c_bool o = O7C_BOOL_UNDEF;

	switch ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)]) {
	case 97:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"array");
		break;
	case 99:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"catch") || Eq(&(*n), n_tag, 6, (o7c_char *)"class");
		break;
	case 100:
		o = Eq(&(*n), n_tag, 9, (o7c_char *)"decltype") || Eq(&(*n), n_tag, 9, (o7c_char *)"delegate") || Eq(&(*n), n_tag, 7, (o7c_char *)"delete") || Eq(&(*n), n_tag, 11, (o7c_char *)"deprecated") || Eq(&(*n), n_tag, 10, (o7c_char *)"dllexport") || Eq(&(*n), n_tag, 10, (o7c_char *)"dllimport") || Eq(&(*n), n_tag, 10, (o7c_char *)"dllexport");
		break;
	case 101:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"event") || Eq(&(*n), n_tag, 9, (o7c_char *)"explicit") || Eq(&(*n), n_tag, 5, (o7c_char *)"each");
		break;
	case 102:
		o = Eq(&(*n), n_tag, 8, (o7c_char *)"finally") || Eq(&(*n), n_tag, 7, (o7c_char *)"friend");
		break;
	case 103:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"gcnew") || Eq(&(*n), n_tag, 8, (o7c_char *)"generic");
		break;
	case 105:
		o = Eq(&(*n), n_tag, 3, (o7c_char *)"in") || Eq(&(*n), n_tag, 9, (o7c_char *)"initonly") || Eq(&(*n), n_tag, 10, (o7c_char *)"interface");
		break;
	case 108:
		o = Eq(&(*n), n_tag, 8, (o7c_char *)"literal");
		break;
	case 109:
		o = Eq(&(*n), n_tag, 8, (o7c_char *)"mutable");
		break;
	case 110:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"naked") || Eq(&(*n), n_tag, 10, (o7c_char *)"namespace") || Eq(&(*n), n_tag, 4, (o7c_char *)"new") || Eq(&(*n), n_tag, 9, (o7c_char *)"noinline") || Eq(&(*n), n_tag, 9, (o7c_char *)"noreturn") || Eq(&(*n), n_tag, 8, (o7c_char *)"nothrow") || Eq(&(*n), n_tag, 9, (o7c_char *)"novtable") || Eq(&(*n), n_tag, 8, (o7c_char *)"nullptr");
		break;
	case 111:
		o = Eq(&(*n), n_tag, 9, (o7c_char *)"operator");
		break;
	case 112:
		o = Eq(&(*n), n_tag, 8, (o7c_char *)"private") || Eq(&(*n), n_tag, 9, (o7c_char *)"property") || Eq(&(*n), n_tag, 10, (o7c_char *)"protected") || Eq(&(*n), n_tag, 7, (o7c_char *)"public");
		break;
	case 114:
		o = Eq(&(*n), n_tag, 4, (o7c_char *)"ref");
		break;
	case 115:
		o = Eq(&(*n), n_tag, 9, (o7c_char *)"safecast") || Eq(&(*n), n_tag, 7, (o7c_char *)"sealed") || Eq(&(*n), n_tag, 10, (o7c_char *)"selectany") || Eq(&(*n), n_tag, 6, (o7c_char *)"super");
		break;
	case 116:
		o = Eq(&(*n), n_tag, 9, (o7c_char *)"template") || Eq(&(*n), n_tag, 5, (o7c_char *)"this") || Eq(&(*n), n_tag, 7, (o7c_char *)"thread") || Eq(&(*n), n_tag, 6, (o7c_char *)"throw") || Eq(&(*n), n_tag, 4, (o7c_char *)"try") || Eq(&(*n), n_tag, 7, (o7c_char *)"typeid") || Eq(&(*n), n_tag, 9, (o7c_char *)"typename");
		break;
	case 117:
		o = Eq(&(*n), n_tag, 5, (o7c_char *)"uuid");
		break;
	case 118:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"value") || Eq(&(*n), n_tag, 8, (o7c_char *)"virtual");
		break;
	default:
		if (((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 98) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 104) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 106) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 107) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 113) || (119 <= (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] && (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] <= 122)) {
			o = false;
		} else abort();
		break;
	}
	return o;
}

static o7c_bool IsNameOccupied_JsKeyWord(struct StringStore_String *n, o7c_tag_t n_tag) {
	o7c_bool o = O7C_BOOL_UNDEF;

	switch ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)]) {
	case 97:
		o = Eq(&(*n), n_tag, 9, (o7c_char *)"abstract") || Eq(&(*n), n_tag, 10, (o7c_char *)"arguments");
		break;
	case 98:
		o = Eq(&(*n), n_tag, 8, (o7c_char *)"boolean") || Eq(&(*n), n_tag, 5, (o7c_char *)"byte");
		break;
	case 100:
		o = Eq(&(*n), n_tag, 9, (o7c_char *)"debugger");
		break;
	case 101:
		o = Eq(&(*n), n_tag, 5, (o7c_char *)"eval") || Eq(&(*n), n_tag, 7, (o7c_char *)"export") || Eq(&(*n), n_tag, 8, (o7c_char *)"extends");
		break;
	case 102:
		o = Eq(&(*n), n_tag, 6, (o7c_char *)"final") || Eq(&(*n), n_tag, 9, (o7c_char *)"function");
		break;
	case 105:
		o = Eq(&(*n), n_tag, 11, (o7c_char *)"implements") || Eq(&(*n), n_tag, 7, (o7c_char *)"import") || Eq(&(*n), n_tag, 11, (o7c_char *)"instanceof") || Eq(&(*n), n_tag, 10, (o7c_char *)"interface");
		break;
	case 108:
		o = Eq(&(*n), n_tag, 4, (o7c_char *)"let");
		break;
	case 110:
		o = Eq(&(*n), n_tag, 7, (o7c_char *)"native") || Eq(&(*n), n_tag, 5, (o7c_char *)"null");
		break;
	case 112:
		o = Eq(&(*n), n_tag, 8, (o7c_char *)"package") || Eq(&(*n), n_tag, 8, (o7c_char *)"private") || Eq(&(*n), n_tag, 10, (o7c_char *)"protected");
		break;
	case 115:
		o = Eq(&(*n), n_tag, 13, (o7c_char *)"synchronized");
		break;
	case 116:
		o = Eq(&(*n), n_tag, 7, (o7c_char *)"throws") || Eq(&(*n), n_tag, 10, (o7c_char *)"transient");
		break;
	case 118:
		o = Eq(&(*n), n_tag, 4, (o7c_char *)"var");
		break;
	default:
		if (((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 99) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 103) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 104) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 106) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 107) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 109) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 111) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 113) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 114) || ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] == 117) || (119 <= (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] && (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] <= 122)) {
			o = false;
		} else abort();
		break;
	}
	return o;
}

static o7c_bool IsNameOccupied_O7(struct StringStore_String *n, o7c_tag_t n_tag) {
	return Eq(&(*n), n_tag, 4, (o7c_char *)"o7c") || Eq(&(*n), n_tag, 4, (o7c_char *)"O7C") || Eq(&(*n), n_tag, 12, (o7c_char *)"initialized") || Eq(&(*n), n_tag, 5, (o7c_char *)"init") || Eq(&(*n), n_tag, 5, (o7c_char *)"NULL");
}

static o7c_bool IsNameOccupied(struct StringStore_String *n, o7c_tag_t n_tag) {
	return IsNameOccupied_O7(&(*n), n_tag) || ((char unsigned)'a' <= (*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)]) && ((*n).block->s[o7c_ind(StringStore_BlockSize_cnst + 1, (*n).ofs)] <= (char unsigned)'z') && (IsNameOccupied_CKeyWord(&(*n), n_tag) || IsNameOccupied_CLib(&(*n), n_tag) || IsNameOccupied_CppKeyWord(&(*n), n_tag) || IsNameOccupied_JsKeyWord(&(*n), n_tag));
}

static void Name(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *decl) {
	struct Ast_RDeclarations *up = NULL;

	if ((o7c_is(decl, Ast_RType_tag)) && (decl->up != &decl->module->_) && (decl->up != NULL) || !(*gen).opt->procLocal && (o7c_is(decl, Ast_RProcedure_tag))) {
		up = decl->up;
		while (!(o7c_is(up, Ast_RModule_tag))) {
			TextGenerator_String(&(*gen)._, gen_tag, &up->_.name, StringStore_String_tag);
			TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"_");
			up = up->_.up;
		}
	}
	TextGenerator_String(&(*gen)._, gen_tag, &decl->name, StringStore_String_tag);
	if (o7c_is(decl, Ast_Const_s_tag)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 6, (o7c_char *)"_cnst");
	} else if (IsNameOccupied(&decl->name, StringStore_String_tag)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"_");
	}
}

static void GlobalName(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *decl) {
	if (o7c_bl(decl->mark) || (decl->module != NULL) && ((*gen).module != decl->module)) {
		assert(decl->module != NULL);
		TextGenerator_String(&(*gen)._, gen_tag, &decl->module->_._.name, StringStore_String_tag);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"_");
		TextGenerator_String(&(*gen)._, gen_tag, &decl->name, StringStore_String_tag);
		if (o7c_is(decl, Ast_Const_s_tag)) {
			TextGenerator_Str(&(*gen)._, gen_tag, 6, (o7c_char *)"_cnst");
		}
	} else {
		Name(&(*gen), gen_tag, decl);
	}
}

static void Import(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *decl) {
	TextGenerator_Str(&(*gen)._, gen_tag, 10, (o7c_char *)"#include ");
	TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"\x22");
	if (o7c_is(decl, Ast_RModule_tag)) {
		TextGenerator_String(&(*gen)._, gen_tag, &decl->name, StringStore_String_tag);
	} else {
		assert(o7c_is(decl, Ast_Import_s_tag));
		TextGenerator_String(&(*gen)._, gen_tag, &decl->module->_._.name, StringStore_String_tag);
	}
	TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)".h");
	TextGenerator_StrLn(&(*gen)._, gen_tag, 2, (o7c_char *)"\x22");
}

static void Factor(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *expr) {
	if (o7c_is(expr, Ast_RFactor_tag)) {
		expression(&(*gen), gen_tag, expr);
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"(");
		expression(&(*gen), gen_tag, expr);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	}
}

static o7c_bool IsAnonStruct(struct Ast_Record_s *rec) {
	return !StringStore_IsDefined(&rec->_._._.name, StringStore_String_tag) || StringStore_SearchSubString(&rec->_._._.name, StringStore_String_tag, 7, (o7c_char *)"_anon_");
}

static struct Ast_RType *TypeForTag(struct Ast_Record_s *rec) {
	if (IsAnonStruct(rec)) {
		rec = rec->base;
	}
	return (&(rec)->_._);
}

static o7c_bool CheckStructName(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Record_s *rec) {
	o7c_char anon[TranslatorLimits_MaxLenName_cnst * 2 + 3];
	int i = O7C_INT_UNDEF, j = O7C_INT_UNDEF, l = O7C_INT_UNDEF;
	o7c_bool ret = O7C_BOOL_UNDEF, corr = O7C_BOOL_UNDEF;
	memset(&anon, 0, sizeof(anon));

	if (StringStore_IsDefined(&rec->_._._.name, StringStore_String_tag)) {
	} else if ((rec->pointer != NULL) && StringStore_IsDefined(&rec->pointer->_._._.name, StringStore_String_tag)) {
		l = 0;
		assert(rec->_._._.module != NULL);
		/*rec.mark := TRUE; TODO удалить? */
		corr = StringStore_CopyToChars(TranslatorLimits_MaxLenName_cnst * 2 + 3, anon, &l, &rec->pointer->_._._.name, StringStore_String_tag);
		assert(o7c_bl(corr));
		anon[o7c_ind(TranslatorLimits_MaxLenName_cnst * 2 + 3, l)] = (char unsigned)'_';
		anon[o7c_ind(TranslatorLimits_MaxLenName_cnst * 2 + 3, o7c_add(l, 1))] = (char unsigned)'s';
		anon[o7c_ind(TranslatorLimits_MaxLenName_cnst * 2 + 3, o7c_add(l, 2))] = 0x00u;
		Ast_PutChars(rec->pointer->_._._.module, &rec->_._._.name, StringStore_String_tag, TranslatorLimits_MaxLenName_cnst * 2 + 3, anon, 0, o7c_add(l, 2));
	} else {
		l = 0;
		corr = StringStore_CopyToChars(TranslatorLimits_MaxLenName_cnst * 2 + 3, anon, &l, &rec->_._._.module->_._.name, StringStore_String_tag);
		assert(o7c_bl(corr));
		Log_StrLn(7, (o7c_char *)"Record");
		ret = StringStore_CopyChars(TranslatorLimits_MaxLenName_cnst * 2 + 3, anon, &l, 11, (o7c_char *)"_anon_0000", 0, 10);
		assert(o7c_bl(ret));
		assert((o7c_cmp((*gen).opt->index, 0) >=  0) && (o7c_cmp((*gen).opt->index, 10000) <  0));
		i = (*gen).opt->index;
		/*Log.Int(i); Log.Ln;*/
		j = o7c_sub(l, 1);
		while (o7c_cmp(i, 0) >  0) {
			anon[o7c_ind(TranslatorLimits_MaxLenName_cnst * 2 + 3, j)] = o7c_chr(o7c_add((int)(char unsigned)'0', o7c_mod(i, 10)));
			i = o7c_div(i, 10);
			j = o7c_sub(j, 1);
		}
		(*gen).opt->index = o7c_add((*gen).opt->index, 1);
		Ast_PutChars(rec->_._._.module, &rec->_._._.name, StringStore_String_tag, TranslatorLimits_MaxLenName_cnst * 2 + 3, anon, 0, l);
	}
	return StringStore_IsDefined(&rec->_._._.name, StringStore_String_tag);
}

static void ArrayDeclLen(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RType *arr, struct Ast_RDeclaration *decl, struct Ast_RSelector *sel, int i) {
	if (O7C_GUARD(Ast_RArray, &arr)->count != NULL) {
		expression(&(*gen), gen_tag, O7C_GUARD(Ast_RArray, &arr)->count);
	} else {
		GlobalName(&(*gen), gen_tag, decl);
		/*TODO*/
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"_len");
		if (o7c_cmp(i, 0) <  0) {
			i = 0;
			while (sel != NULL) {
				i = o7c_add(i, 1);
				sel = sel->next;
			}
		}
		TextGenerator_Int(&(*gen)._, gen_tag, i);
	}
}

static void ArrayLen(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *e) {
	int i = O7C_INT_UNDEF;
	struct Ast_Designator_s *des = NULL;
	struct Ast_RType *t = NULL;

	if (O7C_GUARD(Ast_RArray, &e->type)->count != NULL) {
		expression(&(*gen), gen_tag, O7C_GUARD(Ast_RArray, &e->type)->count);
	} else {
		des = O7C_GUARD(Ast_Designator_s, &e);
		GlobalName(&(*gen), gen_tag, des->decl);
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"_len");
		i = 0;
		t = des->_._.type;
		while (t != e->type) {
			i = o7c_add(i, 1);
			t = t->_.type;
		}
		TextGenerator_Int(&(*gen)._, gen_tag, i);
	}
}

static void Selector(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Selectors *sels, o7c_tag_t sels_tag, int i, struct Ast_RType **typ, struct Ast_RType *desType);
static void Selector_Record(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RType **typ, struct Ast_RSelector **sel);
static o7c_bool Record_Selector_Search(struct Ast_Record_s *ds, struct Ast_RDeclaration *d) {
	struct Ast_RDeclaration *c = NULL;

	c = (&(ds->vars)->_);
	while ((c != NULL) && (c != d)) {
		c = c->next;
	}
	return c != NULL;
}

static void Selector_Record(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RType **typ, struct Ast_RSelector **sel) {
	struct Ast_RDeclaration *var_ = NULL;
	struct Ast_Record_s *up = NULL;

	var_ = (&(O7C_GUARD(Ast_SelRecord_s, &(*sel))->var_)->_);
	if (o7c_is((*typ), Ast_RPointer_tag)) {
		up = O7C_GUARD(Ast_Record_s, &O7C_GUARD(Ast_RPointer, &(*typ))->_._._.type);
	} else {
		up = O7C_GUARD(Ast_Record_s, &(*typ));
	}
	if (o7c_cmp((*typ)->_._.id, Ast_IdPointer_cnst) ==  0) {
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"->");
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)".");
	}
	if (!(*gen).opt->plan9) {
		while ((up != NULL) && !Record_Selector_Search(up, var_)) {
			up = up->base;
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"_.");
		}
	}
	Name(&(*gen), gen_tag, var_);
	(*typ) = var_->type;
}

static void Selector_Declarator(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *decl) {
	if ((o7c_is(decl, Ast_FormalParam_s_tag)) && (o7c_bl(O7C_GUARD(Ast_FormalParam_s, &decl)->isVar) && (o7c_cmp(decl->type->_._.id, Ast_IdArray_cnst) !=  0) || (o7c_cmp(decl->type->_._.id, Ast_IdRecord_cnst) ==  0))) {
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"(*");
		GlobalName(&(*gen), gen_tag, decl);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	} else {
		GlobalName(&(*gen), gen_tag, decl);
	}
}

static void Selector_Array(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RType **typ, struct Ast_RSelector **sel, struct Ast_RDeclaration *decl, o7c_bool isDesignatorArray);
static void Array_Selector_Mult(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *decl, int j, struct Ast_RType *t) {
	while ((t != NULL) && (o7c_is(t, Ast_RArray_tag))) {
		TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" * ");
		Name(&(*gen), gen_tag, decl);
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"_len");
		TextGenerator_Int(&(*gen)._, gen_tag, j);
		j = o7c_add(j, 1);
		t = t->_.type;
	}
}

static void Selector_Array(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RType **typ, struct Ast_RSelector **sel, struct Ast_RDeclaration *decl, o7c_bool isDesignatorArray) {
	int i = O7C_INT_UNDEF;

	if (o7c_bl(isDesignatorArray) && !(*gen).opt->vla) {
		TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" + ");
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"[");
	}
	if ((o7c_cmp((*typ)->_.type->_._.id, Ast_IdArray_cnst) !=  0) || (O7C_GUARD(Ast_RArray, &(*typ))->count != NULL) || o7c_bl((*gen).opt->vla)) {
		if (o7c_bl((*gen).opt->checkIndex) && ((O7C_GUARD(Ast_SelArray_s, &(*sel))->index->value_ == NULL) || (O7C_GUARD(Ast_RArray, &(*typ))->count == NULL) && (o7c_cmp(O7C_GUARD(Ast_RExprInteger, &O7C_GUARD(Ast_SelArray_s, &(*sel))->index->value_)->int_, 0) !=  0))) {
			TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"o7c_ind(");
			ArrayDeclLen(&(*gen), gen_tag, (*typ), decl, (*sel), 0);
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
			expression(&(*gen), gen_tag, O7C_GUARD(Ast_SelArray_s, &(*sel))->index);
			TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
		} else {
			expression(&(*gen), gen_tag, O7C_GUARD(Ast_SelArray_s, &(*sel))->index);
		}
		(*typ) = (*typ)->_.type;
		(*sel) = (*sel)->next;
		i = 1;
		while (((*sel) != NULL) && (o7c_is((*sel), Ast_SelArray_s_tag))) {
			if (o7c_bl((*gen).opt->checkIndex) && ((O7C_GUARD(Ast_SelArray_s, &(*sel))->index->value_ == NULL) || (O7C_GUARD(Ast_RArray, &(*typ))->count == NULL) && (o7c_cmp(O7C_GUARD(Ast_RExprInteger, &O7C_GUARD(Ast_SelArray_s, &(*sel))->index->value_)->int_, 0) !=  0))) {
				TextGenerator_Str(&(*gen)._, gen_tag, 11, (o7c_char *)"][o7c_ind(");
				ArrayDeclLen(&(*gen), gen_tag, (*typ), decl, (*sel), i);
				TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
				expression(&(*gen), gen_tag, O7C_GUARD(Ast_SelArray_s, &(*sel))->index);
				TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
			} else {
				TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"][");
				expression(&(*gen), gen_tag, O7C_GUARD(Ast_SelArray_s, &(*sel))->index);
			}
			i = o7c_add(i, 1);
			(*sel) = (*sel)->next;
			(*typ) = (*typ)->_.type;
		}
	} else {
		i = 0;
		while (((*sel)->next != NULL) && (o7c_is((*sel)->next, Ast_SelArray_s_tag))) {
			TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"o7c_ind(");
			ArrayDeclLen(&(*gen), gen_tag, (*typ), decl, NULL, i);
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
			expression(&(*gen), gen_tag, O7C_GUARD(Ast_SelArray_s, &(*sel))->index);
			TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
			(*typ) = (*typ)->_.type;
			Array_Selector_Mult(&(*gen), gen_tag, decl, o7c_add(i, 1), (*typ));
			(*sel) = (*sel)->next;
			i = o7c_add(i, 1);
			TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" + ");
		}
		TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"o7c_ind(");
		ArrayDeclLen(&(*gen), gen_tag, (*typ), decl, NULL, i);
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
		expression(&(*gen), gen_tag, O7C_GUARD(Ast_SelArray_s, &(*sel))->index);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
		Array_Selector_Mult(&(*gen), gen_tag, decl, o7c_add(i, 1), (*typ)->_.type);
	}
	if (!isDesignatorArray || o7c_bl((*gen).opt->vla)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"]");
	}
}

static void Selector(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Selectors *sels, o7c_tag_t sels_tag, int i, struct Ast_RType **typ, struct Ast_RType *desType) {
	struct Ast_RSelector *sel = NULL;
	o7c_bool ret = O7C_BOOL_UNDEF;

	if (o7c_cmp(i, 0) <  0) {
		Selector_Declarator(&(*gen), gen_tag, (*sels).decl);
	} else {
		sel = (*sels).list[o7c_ind(TranslatorLimits_MaxSelectors_cnst, i)];
		i = o7c_sub(i, 1);
		if (o7c_is(sel, Ast_SelRecord_s_tag)) {
			Selector(&(*gen), gen_tag, &(*sels), sels_tag, i, &(*typ), desType);
			Selector_Record(&(*gen), gen_tag, &(*typ), &sel);
		} else if (o7c_is(sel, Ast_SelArray_s_tag)) {
			Selector(&(*gen), gen_tag, &(*sels), sels_tag, i, &(*typ), desType);
			Selector_Array(&(*gen), gen_tag, &(*typ), &sel, (*sels).decl, (o7c_cmp(desType->_._.id, Ast_IdArray_cnst) ==  0) && (O7C_GUARD(Ast_RArray, &desType)->count == NULL));
		} else if (o7c_is(sel, Ast_SelPointer_s_tag)) {
			if ((sel->next == NULL) || !(o7c_is(sel->next, Ast_SelRecord_s_tag))) {
				TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"(*");
				Selector(&(*gen), gen_tag, &(*sels), sels_tag, i, &(*typ), desType);
				TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
			} else {
				Selector(&(*gen), gen_tag, &(*sels), sels_tag, i, &(*typ), desType);
			}
		} else if (o7c_is(sel, Ast_SelGuard_s_tag)) {
			if (o7c_cmp(O7C_GUARD(Ast_SelGuard_s, &sel)->type->_._.id, Ast_IdPointer_cnst) ==  0) {
				TextGenerator_Str(&(*gen)._, gen_tag, 11, (o7c_char *)"O7C_GUARD(");
				ret = CheckStructName(&(*gen), gen_tag, O7C_GUARD(Ast_Record_s, &O7C_GUARD(Ast_SelGuard_s, &sel)->type->_.type));
				assert(o7c_bl(ret));
				GlobalName(&(*gen), gen_tag, &O7C_GUARD(Ast_SelGuard_s, &sel)->type->_.type->_);
			} else {
				TextGenerator_Str(&(*gen)._, gen_tag, 13, (o7c_char *)"O7C_GUARD_R(");
				GlobalName(&(*gen), gen_tag, &O7C_GUARD(Ast_SelGuard_s, &sel)->type->_);
			}
			TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)", &");
			Selector(&(*gen), gen_tag, &(*sels), sels_tag, i, &(*typ), desType);
			if (o7c_cmp(O7C_GUARD(Ast_SelGuard_s, &sel)->type->_._.id, Ast_IdPointer_cnst) ==  0) {
				TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
			} else {
				TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
				GlobalName(&(*gen), gen_tag, (*sels).decl);
				TextGenerator_Str(&(*gen)._, gen_tag, 6, (o7c_char *)"_tag)");
			}
			(*typ) = O7C_GUARD(Ast_SelGuard_s, &sel)->type;
		} else {
			assert(false);
		}
	}
}

static void Designator(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Designator_s *des);
static void Designator_Put(struct Selectors *sels, o7c_tag_t sels_tag, struct Ast_RSelector *sel) {
	(*sels).i =  - 1;
	while (sel != NULL) {
		(*sels).i = o7c_add((*sels).i, 1);
		(*sels).list[o7c_ind(TranslatorLimits_MaxSelectors_cnst, (*sels).i)] = sel;
		if (o7c_is(sel, Ast_SelArray_s_tag)) {
			while ((sel != NULL) && (o7c_is(sel, Ast_SelArray_s_tag))) {
				sel = sel->next;
			}
		} else {
			sel = sel->next;
		}
	}
}

static void Designator(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Designator_s *des) {
	struct Selectors sels;
	struct Ast_RType *typ = NULL;
	Selectors_undef(&sels);

	Designator_Put(&sels, Selectors_tag, des->sel);
	typ = des->decl->type;
	sels.des = des;
	sels.decl = des->decl;
	/* TODO */
	(*gen).opt->lastSelectorDereference = (o7c_cmp(sels.i, 0) >  0) && (o7c_is(sels.list[o7c_ind(TranslatorLimits_MaxSelectors_cnst, sels.i)], Ast_SelPointer_s_tag));
	Selector(&(*gen), gen_tag, &sels, Selectors_tag, sels.i, &typ, des->_._.type);
}

static void CheckExpr(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *e) {
	if ((o7c_cmp((*gen).opt->varInit, GeneratorC_VarInitUndefined_cnst) ==  0) && (o7c_is(e, Ast_Designator_s_tag)) && (o7c_cmp(e->type->_._.id, Ast_IdBoolean_cnst) ==  0) && (e->value_ == NULL)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"o7c_bl(");
		expression(&(*gen), gen_tag, e);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	} else {
		expression(&(*gen), gen_tag, e);
	}
}

static void Expression(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *expr);
static void Expression_Call(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprCall_s *call);
static void Call_Expression_Predefined(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprCall_s *call);
static void Predefined_Call_Expression_Shift(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, int shift_len0, o7c_char shift[/*len0*/], struct Ast_Parameter_s *ps) {
	TextGenerator_Str(&(*gen)._, gen_tag, 17, (o7c_char *)"(int)((unsigned)");
	Factor(&(*gen), gen_tag, ps->expr);
	TextGenerator_Str(&(*gen)._, gen_tag, shift_len0, shift);
	Factor(&(*gen), gen_tag, ps->next->expr);
	TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
}

static void Predefined_Call_Expression_Len(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *e) {
	struct Ast_RSelector *sel = NULL;
	int i = O7C_INT_UNDEF;
	struct Ast_Designator_s *des = NULL;
	struct Ast_RExpression *count = NULL;
	o7c_bool sizeof_ = O7C_BOOL_UNDEF;

	count = O7C_GUARD(Ast_RArray, &e->type)->count;
	if (o7c_is(e, Ast_Designator_s_tag)) {
		des = O7C_GUARD(Ast_Designator_s, &e);
		sizeof_ = !(o7c_is(O7C_GUARD(Ast_Designator_s, &e)->decl, Ast_Const_s_tag)) && ((o7c_cmp(des->decl->type->_._.id, Ast_IdArray_cnst) !=  0) || !(o7c_is(des->decl, Ast_FormalParam_s_tag)));
	} else {
		sizeof_ = false;
	}
	if ((count != NULL) && !sizeof_) {
		Expression(&(*gen), gen_tag, count);
	} else if (o7c_bl(sizeof_)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"O7C_LEN(");
		Designator(&(*gen), gen_tag, des);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	} else {
		GlobalName(&(*gen), gen_tag, des->decl);
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"_len");
		i = 0;
		sel = des->sel;
		while (sel != NULL) {
			i = o7c_add(i, 1);
			sel = sel->next;
		}
		TextGenerator_Int(&(*gen)._, gen_tag, i);
	}
}

static void Predefined_Call_Expression_New(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *e) {
	struct Ast_RType *tagType = NULL;

	tagType = TypeForTag(O7C_GUARD(Ast_Record_s, &e->type->_.type));
	if ((tagType != NULL) && (o7c_cmp((*gen).opt->varInit, GeneratorC_VarInitUndefined_cnst) ==  0)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 10, (o7c_char *)"O7C_NEW(&");
		Expression(&(*gen), gen_tag, e);
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
		GlobalName(&(*gen), gen_tag, &tagType->_);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 11, (o7c_char *)"O7C_NEW2(&");
		Expression(&(*gen), gen_tag, e);
		if (tagType != NULL) {
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
			GlobalName(&(*gen), gen_tag, &tagType->_);
			TextGenerator_Str(&(*gen)._, gen_tag, 12, (o7c_char *)"_tag, NULL)");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 14, (o7c_char *)", NULL, NULL)");
		}
	}
}

static void Predefined_Call_Expression_Ord(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *e) {
	TextGenerator_Str(&(*gen)._, gen_tag, 6, (o7c_char *)"(int)");
	Factor(&(*gen), gen_tag, e);
}

static void Predefined_Call_Expression_Inc(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *e1, struct Ast_Parameter_s *p2) {
	Expression(&(*gen), gen_tag, e1);
	if (o7c_bl((*gen).opt->checkArith)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 12, (o7c_char *)" = o7c_add(");
		Expression(&(*gen), gen_tag, e1);
		if (p2 == NULL) {
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)", 1)");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
			Expression(&(*gen), gen_tag, p2->expr);
			TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
		}
	} else if (p2 == NULL) {
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"++");
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" += ");
		Expression(&(*gen), gen_tag, p2->expr);
	}
}

static void Predefined_Call_Expression_Dec(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *e1, struct Ast_Parameter_s *p2) {
	Expression(&(*gen), gen_tag, e1);
	if (o7c_bl((*gen).opt->checkArith)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 12, (o7c_char *)" = o7c_sub(");
		Expression(&(*gen), gen_tag, e1);
		if (p2 == NULL) {
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)", 1)");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
			Expression(&(*gen), gen_tag, p2->expr);
			TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
		}
	} else if (p2 == NULL) {
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"--");
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" -= ");
		Expression(&(*gen), gen_tag, p2->expr);
	}
}

static void Call_Expression_Predefined(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprCall_s *call) {
	struct Ast_RExpression *e1 = NULL;
	struct Ast_Parameter_s *p2 = NULL;

	e1 = call->params->expr;
	p2 = call->params->next;
	switch (call->designator->decl->_.id) {
	case 90:
		if (o7c_cmp(call->_._.type->_._.id, Ast_IdInteger_cnst) ==  0) {
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"abs(");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 6, (o7c_char *)"fabs(");
		}
		Expression(&(*gen), gen_tag, e1);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
		break;
	case 107:
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"(");
		Factor(&(*gen), gen_tag, e1);
		TextGenerator_Str(&(*gen)._, gen_tag, 11, (o7c_char *)" % 2 == 1)");
		break;
	case 104:
		Predefined_Call_Expression_Len(&(*gen), gen_tag, e1);
		break;
	case 105:
		Predefined_Call_Expression_Shift(&(*gen), gen_tag, 5, (o7c_char *)" << ", call->params);
		break;
	case 91:
		Predefined_Call_Expression_Shift(&(*gen), gen_tag, 5, (o7c_char *)" >> ", call->params);
		break;
	case 111:
		TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"o7_ror(");
		Expression(&(*gen), gen_tag, e1);
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
		Expression(&(*gen), gen_tag, p2->expr);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
		break;
	case 99:
		TextGenerator_Str(&(*gen)._, gen_tag, 6, (o7c_char *)"(int)");
		Factor(&(*gen), gen_tag, e1);
		break;
	case 100:
		TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"(double)");
		Factor(&(*gen), gen_tag, e1);
		break;
	case 108:
		Predefined_Call_Expression_Ord(&(*gen), gen_tag, e1);
		break;
	case 96:
		if (o7c_bl((*gen).opt->checkArith) && (e1->value_ == NULL)) {
			TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"o7c_chr(");
			Expression(&(*gen), gen_tag, e1);
			TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 16, (o7c_char *)"(char unsigned)");
			Factor(&(*gen), gen_tag, e1);
		}
		break;
	case 101:
		Predefined_Call_Expression_Inc(&(*gen), gen_tag, e1, p2);
		break;
	case 97:
		Predefined_Call_Expression_Dec(&(*gen), gen_tag, e1, p2);
		break;
	case 102:
		Expression(&(*gen), gen_tag, e1);
		TextGenerator_Str(&(*gen)._, gen_tag, 11, (o7c_char *)" |= 1u << ");
		Factor(&(*gen), gen_tag, p2->expr);
		break;
	case 98:
		Expression(&(*gen), gen_tag, e1);
		TextGenerator_Str(&(*gen)._, gen_tag, 13, (o7c_char *)" &= ~(1u << ");
		Factor(&(*gen), gen_tag, p2->expr);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
		break;
	case 106:
		Predefined_Call_Expression_New(&(*gen), gen_tag, e1);
		break;
	case 92:
		TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"assert(");
		CheckExpr(&(*gen), gen_tag, e1);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
		break;
	case 109:
		Expression(&(*gen), gen_tag, e1);
		TextGenerator_Str(&(*gen)._, gen_tag, 10, (o7c_char *)" *= 1 << ");
		Expression(&(*gen), gen_tag, p2->expr);
		break;
	case 113:
		Expression(&(*gen), gen_tag, e1);
		TextGenerator_Str(&(*gen)._, gen_tag, 10, (o7c_char *)" /= 1 << ");
		Expression(&(*gen), gen_tag, p2->expr);
		break;
	default:
		abort();
		break;
	}
}

static void Call_Expression_ActualParam(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Parameter_s **p, struct Ast_RDeclaration **fp);
static int ActualParam_Call_Expression_ArrayDeep(struct Ast_RType *t) {
	int d = O7C_INT_UNDEF;

	d = 0;
	while (o7c_cmp(t->_._.id, Ast_IdArray_cnst) ==  0) {
		t = t->_.type;
		d = o7c_add(d, 1);
	}
	return d;
}

static void Call_Expression_ActualParam(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Parameter_s **p, struct Ast_RDeclaration **fp) {
	struct Ast_RType *t = NULL;
	int i = O7C_INT_UNDEF, j = O7C_INT_UNDEF, dist = O7C_INT_UNDEF;

	t = (*fp)->type;
	if ((o7c_cmp(t->_._.id, Ast_IdByte_cnst) ==  0) && (o7c_cmp((*p)->expr->type->_._.id, Ast_IdInteger_cnst) ==  0) && o7c_bl((*gen).opt->checkArith) && ((*p)->expr->value_ == NULL)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 10, (o7c_char *)"o7c_byte(");
		Expression(&(*gen), gen_tag, (*p)->expr);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	} else {
		j = 1;
		if (o7c_cmp((*fp)->type->_._.id, Ast_IdChar_cnst) !=  0) {
			i =  - 1;
			t = (*p)->expr->type;
			while ((o7c_cmp(t->_._.id, Ast_IdArray_cnst) ==  0) && (O7C_GUARD(Ast_RArray, &(*fp)->type)->count == NULL)) {
				if ((o7c_cmp(i,  - 1) ==  0) && (o7c_is((*p)->expr, Ast_Designator_s_tag))) {
					i = o7c_sub(ActualParam_Call_Expression_ArrayDeep(O7C_GUARD(Ast_Designator_s, &(*p)->expr)->decl->type), ActualParam_Call_Expression_ArrayDeep((*fp)->type));
					if (!(o7c_is(O7C_GUARD(Ast_Designator_s, &(*p)->expr)->decl, Ast_FormalParam_s_tag))) {
						j = ActualParam_Call_Expression_ArrayDeep(O7C_GUARD(Ast_Designator_s, &(*p)->expr)->_._.type);
					}
				}
				if (O7C_GUARD(Ast_RArray, &t)->count != NULL) {
					Expression(&(*gen), gen_tag, O7C_GUARD(Ast_RArray, &t)->count);
				} else {
					Name(&(*gen), gen_tag, O7C_GUARD(Ast_Designator_s, &(*p)->expr)->decl);
					TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"_len");
					TextGenerator_Int(&(*gen)._, gen_tag, i);
				}
				TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
				i = o7c_add(i, 1);
				t = t->_.type;
			}
			t = (*fp)->type;
		}
		dist = (*p)->distance;
		if ((o7c_bl(O7C_GUARD(Ast_FormalParam_s, &(*fp))->isVar) && !(o7c_is(t, Ast_RArray_tag))) || (o7c_is(t, Ast_Record_s_tag)) || (o7c_cmp(t->_._.id, Ast_IdPointer_cnst) ==  0) && (o7c_cmp(dist, 0) >  0) && !(*gen).opt->plan9) {
			TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"&");
		}
		(*gen).opt->lastSelectorDereference = false;
		Expression(&(*gen), gen_tag, (*p)->expr);
		if (!(*gen).opt->vla) {
			while (o7c_cmp(j, 1) >  0) {
				j = o7c_sub(j, 1);
				TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)"[0]");
			}
		}
		if ((o7c_cmp(dist, 0) >  0) && !(*gen).opt->plan9) {
			if (o7c_cmp(t->_._.id, Ast_IdPointer_cnst) ==  0) {
				dist = o7c_sub(dist, 1);
				TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)"->_");
			}
			while (o7c_cmp(dist, 0) >  0) {
				dist = o7c_sub(dist, 1);
				TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"._");
			}
		}
		t = (*p)->expr->type;
		if (o7c_cmp(t->_._.id, Ast_IdRecord_cnst) ==  0) {
			if (o7c_bl((*gen).opt->lastSelectorDereference)) {
				TextGenerator_Str(&(*gen)._, gen_tag, 7, (o7c_char *)", NULL");
			} else {
				TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
				if ((o7c_is(O7C_GUARD(Ast_Designator_s, &(*p)->expr)->decl, Ast_FormalParam_s_tag)) && (O7C_GUARD(Ast_Designator_s, &(*p)->expr)->sel == NULL)) {
					Name(&(*gen), gen_tag, O7C_GUARD(Ast_Designator_s, &(*p)->expr)->decl);
				} else {
					GlobalName(&(*gen), gen_tag, &t->_);
				}
				TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"_tag");
			}
		}
	}
	(*p) = (*p)->next;
	(*fp) = (*fp)->next;
}

static void Expression_Call(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprCall_s *call) {
	struct Ast_Parameter_s *p = NULL;
	struct Ast_RDeclaration *fp = NULL;

	if (o7c_is(call->designator->decl, Ast_PredefinedProcedure_s_tag)) {
		Call_Expression_Predefined(&(*gen), gen_tag, call);
	} else {
		Designator(&(*gen), gen_tag, call->designator);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"(");
		p = call->params;
		fp = (&(O7C_GUARD(Ast_RProcType, &call->designator->_._.type)->params)->_._);
		if (p != NULL) {
			Call_Expression_ActualParam(&(*gen), gen_tag, &p, &fp);
			while (p != NULL) {
				TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
				Call_Expression_ActualParam(&(*gen), gen_tag, &p, &fp);
			}
		}
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	}
}

static void Expression_Relation(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprRelation_s *rel);
static void Relation_Expression_Simple(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprRelation_s *rel, int str_len0, o7c_char str[/*len0*/]);
static void Simple_Relation_Expression_Expr(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *e, int dist) {
	o7c_bool brace = O7C_BOOL_UNDEF;

	brace = (o7c_in(e->type->_._.id, ((1 << Ast_IdSet_cnst) | (1 << Ast_IdBoolean_cnst)))) && !(o7c_is(e, Ast_RFactor_tag));
	if (o7c_bl(brace)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"(");
	} else if ((o7c_cmp(dist, 0) >  0) && (o7c_cmp(e->type->_._.id, Ast_IdPointer_cnst) ==  0) && !(*gen).opt->plan9) {
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"&");
	}
	Expression(&(*gen), gen_tag, e);
	if ((o7c_cmp(dist, 0) >  0) && !(*gen).opt->plan9) {
		if (o7c_cmp(e->type->_._.id, Ast_IdPointer_cnst) ==  0) {
			dist = o7c_sub(dist, 1);
			TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)"->_");
		}
		while (o7c_cmp(dist, 0) >  0) {
			dist = o7c_sub(dist, 1);
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"._");
		}
	}
	if (o7c_bl(brace)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	}
}

static void Simple_Relation_Expression_Len(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *e) {
	struct Ast_Designator_s *des = NULL;

	if (O7C_GUARD(Ast_RArray, &e->type)->count != NULL) {
		Expression(&(*gen), gen_tag, O7C_GUARD(Ast_RArray, &e->type)->count);
	} else {
		des = O7C_GUARD(Ast_Designator_s, &e);
		ArrayDeclLen(&(*gen), gen_tag, des->_._.type, des->decl, des->sel, 0);
	}
}

static void Relation_Expression_Simple(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprRelation_s *rel, int str_len0, o7c_char str[/*len0*/]) {
	if ((o7c_cmp(rel->exprs[0]->type->_._.id, Ast_IdArray_cnst) ==  0) && ((rel->exprs[0]->value_ == NULL) || !O7C_GUARD(Ast_ExprString_s, &rel->exprs[0]->value_)->asChar)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 12, (o7c_char *)"o7c_strcmp(");
		Simple_Relation_Expression_Len(&(*gen), gen_tag, rel->exprs[0]);
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
		Simple_Relation_Expression_Expr(&(*gen), gen_tag, rel->exprs[0], o7c_sub(0, rel->distance));
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
		Simple_Relation_Expression_Len(&(*gen), gen_tag, rel->exprs[1]);
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
		Simple_Relation_Expression_Expr(&(*gen), gen_tag, rel->exprs[1], rel->distance);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
		TextGenerator_Str(&(*gen)._, gen_tag, str_len0, str);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"0");
	} else if ((o7c_cmp((*gen).opt->varInit, GeneratorC_VarInitUndefined_cnst) ==  0) && (rel->_.value_ == NULL) && (o7c_cmp(rel->exprs[0]->type->_._.id, Ast_IdInteger_cnst) ==  0)) {
		/* TODO */
		TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"o7c_cmp(");
		Simple_Relation_Expression_Expr(&(*gen), gen_tag, rel->exprs[0], o7c_sub(0, rel->distance));
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
		Simple_Relation_Expression_Expr(&(*gen), gen_tag, rel->exprs[1], rel->distance);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
		TextGenerator_Str(&(*gen)._, gen_tag, str_len0, str);
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)" 0");
	} else {
		Simple_Relation_Expression_Expr(&(*gen), gen_tag, rel->exprs[0], o7c_sub(0, rel->distance));
		TextGenerator_Str(&(*gen)._, gen_tag, str_len0, str);
		Simple_Relation_Expression_Expr(&(*gen), gen_tag, rel->exprs[1], rel->distance);
	}
}

static void Relation_Expression_In(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprRelation_s *rel) {
	if ((rel->exprs[0]->value_ != NULL) && (o7c_in(O7C_GUARD(Ast_RExprInteger, &rel->exprs[0]->value_)->int_, O7C_SET(0, Limits_SetMax_cnst)))) {
		TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)"!!(");
		TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)" (1u << ");
		Factor(&(*gen), gen_tag, rel->exprs[0]);
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)") & ");
		Factor(&(*gen), gen_tag, rel->exprs[1]);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	} else {
		if (rel->_.value_ != NULL) {
			TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"O7C_IN(");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"o7c_in(");
		}
		Expression(&(*gen), gen_tag, rel->exprs[0]);
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
		Expression(&(*gen), gen_tag, rel->exprs[1]);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	}
}

static void Expression_Relation(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprRelation_s *rel) {
	switch (rel->relation) {
	case 21:
		Relation_Expression_Simple(&(*gen), gen_tag, rel, 5, (o7c_char *)" == ");
		break;
	case 22:
		Relation_Expression_Simple(&(*gen), gen_tag, rel, 5, (o7c_char *)" != ");
		break;
	case 23:
		Relation_Expression_Simple(&(*gen), gen_tag, rel, 4, (o7c_char *)" < ");
		break;
	case 24:
		Relation_Expression_Simple(&(*gen), gen_tag, rel, 5, (o7c_char *)" <= ");
		break;
	case 25:
		Relation_Expression_Simple(&(*gen), gen_tag, rel, 4, (o7c_char *)" > ");
		break;
	case 26:
		Relation_Expression_Simple(&(*gen), gen_tag, rel, 5, (o7c_char *)" >= ");
		break;
	case 27:
		Relation_Expression_In(&(*gen), gen_tag, rel);
		break;
	default:
		abort();
		break;
	}
}

static void Expression_Sum(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprSum_s *sum) {
	o7c_bool first = O7C_BOOL_UNDEF;

	first = true;
	do {
		if (o7c_cmp(sum->add, Scanner_Minus_cnst) ==  0) {
			if (o7c_cmp(sum->_.type->_._.id, Ast_IdSet_cnst) !=  0) {
				TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" - ");
			} else if (o7c_bl(first)) {
				TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)" ~");
			} else {
				TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" & ~");
			}
		} else if (o7c_cmp(sum->add, Scanner_Plus_cnst) ==  0) {
			if (o7c_cmp(sum->_.type->_._.id, Ast_IdSet_cnst) ==  0) {
				TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" | ");
			} else {
				TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" + ");
			}
		} else if (o7c_cmp(sum->add, Scanner_Or_cnst) ==  0) {
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" || ");
		}
		CheckExpr(&(*gen), gen_tag, sum->term);
		sum = sum->next;
		first = false;
	} while (!(sum == NULL));
}

static void Expression_SumCheck(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprSum_s *sum) {
	struct Ast_ExprSum_s *arr[TranslatorLimits_MaxTermsInSum_cnst];
	int i = O7C_INT_UNDEF, last = O7C_INT_UNDEF;
	memset(&arr, 0, sizeof(arr));

	i =  - 1;
	do {
		i = o7c_add(i, 1);
		arr[o7c_ind(TranslatorLimits_MaxTermsInSum_cnst, i)] = sum;
		sum = sum->next;
	} while (!(sum == NULL));
	last = i;
	if (o7c_cmp(arr[0]->_.type->_._.id, Ast_IdInteger_cnst) ==  0) {
		while (o7c_cmp(i, 0) >  0) {
			switch (arr[o7c_ind(TranslatorLimits_MaxTermsInSum_cnst, i)]->add) {
			case 11:
				TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"o7c_sub(");
				break;
			case 10:
				TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"o7c_add(");
				break;
			default:
				abort();
				break;
			}
			i = o7c_sub(i, 1);
		}
	} else {
		assert(o7c_cmp(arr[0]->_.type->_._.id, Ast_IdReal_cnst) ==  0);
		while (o7c_cmp(i, 0) >  0) {
			switch (arr[o7c_ind(TranslatorLimits_MaxTermsInSum_cnst, i)]->add) {
			case 11:
				TextGenerator_Str(&(*gen)._, gen_tag, 10, (o7c_char *)"o7c_fsub(");
				break;
			case 10:
				TextGenerator_Str(&(*gen)._, gen_tag, 10, (o7c_char *)"o7c_fadd(");
				break;
			default:
				abort();
				break;
			}
			i = o7c_sub(i, 1);
		}
	}
	if (o7c_cmp(arr[0]->add, Scanner_Minus_cnst) ==  0) {
		if (o7c_cmp(arr[0]->_.type->_._.id, Ast_IdInteger_cnst) ==  0) {
			TextGenerator_Str(&(*gen)._, gen_tag, 12, (o7c_char *)"o7c_sub(0, ");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 13, (o7c_char *)"o7c_fsub(0, ");
		}
		Expression(&(*gen), gen_tag, arr[0]->term);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	} else {
		Expression(&(*gen), gen_tag, arr[0]->term);
	}
	while (o7c_cmp(i, last) <  0) {
		i = o7c_add(i, 1);
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
		Expression(&(*gen), gen_tag, arr[o7c_ind(TranslatorLimits_MaxTermsInSum_cnst, i)]->term);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	}
}

static void Expression_Term(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprTerm_s *term) {
	do {
		CheckExpr(&(*gen), gen_tag, &term->factor->_);
		switch (term->mult) {
		case 150:
			if (o7c_cmp(term->_.type->_._.id, Ast_IdSet_cnst) ==  0) {
				TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" & ");
			} else {
				TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" * ");
			}
			break;
		case 151:
		case 153:
			if (o7c_cmp(term->_.type->_._.id, Ast_IdSet_cnst) ==  0) {
				assert(o7c_cmp(term->mult, Scanner_Slash_cnst) ==  0);
				TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" ^ ");
			} else {
				TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" / ");
			}
			break;
		case 152:
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" && ");
			break;
		case 154:
			TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" % ");
			break;
		default:
			abort();
			break;
		}
		if (o7c_is(term->expr, Ast_ExprTerm_s_tag)) {
			term = O7C_GUARD(Ast_ExprTerm_s, &term->expr);
		} else {
			CheckExpr(&(*gen), gen_tag, term->expr);
			term = NULL;
		}
	} while (!(term == NULL));
}

static void Expression_TermCheck(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprTerm_s *term) {
	struct Ast_ExprTerm_s *arr[TranslatorLimits_MaxFactorsInTerm_cnst];
	int i = O7C_INT_UNDEF, last = O7C_INT_UNDEF;
	memset(&arr, 0, sizeof(arr));

	arr[0] = term;
	i = 0;
	while (o7c_is(term->expr, Ast_ExprTerm_s_tag)) {
		i = o7c_add(i, 1);
		term = O7C_GUARD(Ast_ExprTerm_s, &term->expr);
		arr[o7c_ind(TranslatorLimits_MaxFactorsInTerm_cnst, i)] = term;
	}
	last = i;
	if (o7c_cmp(term->_.type->_._.id, Ast_IdInteger_cnst) ==  0) {
		while (o7c_cmp(i, 0) >=  0) {
			switch (arr[o7c_ind(TranslatorLimits_MaxFactorsInTerm_cnst, i)]->mult) {
			case 150:
				TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"o7c_mul(");
				break;
			case 153:
				TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"o7c_div(");
				break;
			case 154:
				TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"o7c_mod(");
				break;
			default:
				abort();
				break;
			}
			i = o7c_sub(i, 1);
		}
	} else {
		assert(o7c_cmp(term->_.type->_._.id, Ast_IdReal_cnst) ==  0);
		while (o7c_cmp(i, 0) >=  0) {
			switch (arr[o7c_ind(TranslatorLimits_MaxFactorsInTerm_cnst, i)]->mult) {
			case 150:
				TextGenerator_Str(&(*gen)._, gen_tag, 10, (o7c_char *)"o7c_fmul(");
				break;
			case 151:
				TextGenerator_Str(&(*gen)._, gen_tag, 10, (o7c_char *)"o7c_fdiv(");
				break;
			default:
				abort();
				break;
			}
			i = o7c_sub(i, 1);
		}
	}
	Expression(&(*gen), gen_tag, &arr[0]->factor->_);
	i = 0;
	while (o7c_cmp(i, last) <  0) {
		i = o7c_add(i, 1);
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
		Expression(&(*gen), gen_tag, &arr[o7c_ind(TranslatorLimits_MaxFactorsInTerm_cnst, i)]->factor->_);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	}
	TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
	Expression(&(*gen), gen_tag, arr[o7c_ind(TranslatorLimits_MaxFactorsInTerm_cnst, last)]->expr);
	TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
}

static void Expression_Boolean(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprBoolean_s *e) {
	if (o7c_cmp((*gen).opt->std, GeneratorC_IsoC90_cnst) ==  0) {
		if (o7c_bl(e->bool_)) {
			TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"(0 < 1)");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"(0 > 1)");
		}
	} else {
		if (o7c_bl(e->bool_)) {
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"true");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 6, (o7c_char *)"false");
		}
	}
}

static void Expression_CString(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprString_s *e);
static o7c_char CString_Expression_ToHex(int d) {
	assert((o7c_cmp(d, 0) >=  0) && (o7c_cmp(d, 16) <  0));
	if (o7c_cmp(d, 10) <  0) {
		d = o7c_add(d, (int)(char unsigned)'0');
	} else {
		d = o7c_add(d, (int)(char unsigned)'A' - 10);
	}
	return o7c_chr(d);
}

static void Expression_CString(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprString_s *e) {
	o7c_char s1[7];
	o7c_char s2[4];
	o7c_char ch = '\0';
	struct StringStore_String w;
	memset(&s1, 0, sizeof(s1));
	memset(&s2, 0, sizeof(s2));
	StringStore_String_undef(&w);

	w = e->string;
	if (o7c_bl(e->asChar)) {
		ch = o7c_chr(e->_.int_);
		if (ch == (char unsigned)'\'') {
			TextGenerator_Str(&(*gen)._, gen_tag, 20, (o7c_char *)"(char unsigned)'\\''");
		} else if (ch == (char unsigned)'\\') {
			TextGenerator_Str(&(*gen)._, gen_tag, 20, (o7c_char *)"(char unsigned)'\\\\'");
		} else if ((ch >= (char unsigned)' ') && (ch <= (char unsigned)127)) {
			TextGenerator_Str(&(*gen)._, gen_tag, 16, (o7c_char *)"(char unsigned)");
			s2[0] = (char unsigned)'\'';
			s2[1] = ch;
			s2[2] = (char unsigned)'\'';
			s2[3] = 0x00u;
			TextGenerator_Str(&(*gen)._, gen_tag, 4, s2);
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"0x");
			s2[0] = CString_Expression_ToHex(o7c_div(e->_.int_, 16));
			s2[1] = CString_Expression_ToHex(o7c_mod(e->_.int_, 16));
			s2[2] = (char unsigned)'u';
			s2[3] = 0x00u;
			TextGenerator_Str(&(*gen)._, gen_tag, 4, s2);
		}
	} else {
		if (!(*gen).insideSizeOf) {
			TextGenerator_Str(&(*gen)._, gen_tag, 13, (o7c_char *)"(o7c_char *)");
		}
		if (w.block->s[o7c_ind(StringStore_BlockSize_cnst + 1, w.ofs)] == (char unsigned)'"') {
			TextGenerator_ScreeningString(&(*gen)._, gen_tag, &w, StringStore_String_tag);
		} else {
			s1[0] = (char unsigned)'"';
			s1[1] = (char unsigned)'\\';
			s1[2] = (char unsigned)'x';
			s1[3] = CString_Expression_ToHex(o7c_div(e->_.int_, 16));
			s1[4] = CString_Expression_ToHex(o7c_mod(e->_.int_, 16));
			s1[5] = (char unsigned)'"';
			s1[6] = 0x00u;
			TextGenerator_Str(&(*gen)._, gen_tag, 7, s1);
		}
	}
}

static void Expression_ExprInt(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, int int_) {
	if (o7c_cmp(int_, 0) >=  0) {
		TextGenerator_Int(&(*gen)._, gen_tag, int_);
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"(-");
		TextGenerator_Int(&(*gen)._, gen_tag, o7c_sub(0, int_));
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	}
}

static void Expression_Set(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprSet_s *set);
static void Set_Expression_Item(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprSet_s *set) {
	if (set->exprs[0] == NULL) {
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"0");
	} else {
		if (set->exprs[1] == NULL) {
			TextGenerator_Str(&(*gen)._, gen_tag, 7, (o7c_char *)"(1 << ");
			Factor(&(*gen), gen_tag, set->exprs[0]);
		} else {
			if ((set->exprs[0]->value_ == NULL) || (set->exprs[1]->value_ == NULL)) {
				TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"o7c_set(");
			} else {
				TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"O7C_SET(");
			}
			Expression(&(*gen), gen_tag, set->exprs[0]);
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
			Expression(&(*gen), gen_tag, set->exprs[1]);
		}
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	}
}

static void Expression_Set(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprSet_s *set) {
	if (set->next == NULL) {
		Set_Expression_Item(&(*gen), gen_tag, set);
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"(");
		Set_Expression_Item(&(*gen), gen_tag, set);
		do {
			TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" | ");
			set = set->next;
			Set_Expression_Item(&(*gen), gen_tag, set);
		} while (!(set->next == NULL));
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	}
}

static void Expression_IsExtension(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_ExprIsExtension_s *is) {
	struct Ast_RDeclaration *decl = NULL;
	struct Ast_RType *extType = NULL;
	o7c_bool ret = O7C_BOOL_UNDEF;

	decl = is->designator->decl;
	extType = is->extType;
	if (o7c_cmp(is->designator->_._.type->_._.id, Ast_IdPointer_cnst) ==  0) {
		extType = extType->_.type;
		ret = CheckStructName(&(*gen), gen_tag, O7C_GUARD(Ast_Record_s, &extType));
		assert(o7c_bl(ret));
		TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"o7c_is(");
		Expression(&(*gen), gen_tag, &is->designator->_._);
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 10, (o7c_char *)"o7c_is_r(");
		GlobalName(&(*gen), gen_tag, decl);
		TextGenerator_Str(&(*gen)._, gen_tag, 7, (o7c_char *)"_tag, ");
		GlobalName(&(*gen), gen_tag, decl);
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
	}
	GlobalName(&(*gen), gen_tag, &extType->_);
	TextGenerator_Str(&(*gen)._, gen_tag, 6, (o7c_char *)"_tag)");
}

static void Expression(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *expr) {
	switch (expr->_.id) {
	case 0:
		Expression_ExprInt(&(*gen), gen_tag, O7C_GUARD(Ast_RExprInteger, &expr)->int_);
		break;
	case 1:
		Expression_Boolean(&(*gen), gen_tag, O7C_GUARD(Ast_ExprBoolean_s, &expr));
		break;
	case 4:
		if (StringStore_IsDefined(&O7C_GUARD(Ast_ExprReal_s, &expr)->str, StringStore_String_tag)) {
			TextGenerator_String(&(*gen)._, gen_tag, &O7C_GUARD(Ast_ExprReal_s, &expr)->str, StringStore_String_tag);
		} else {
			TextGenerator_Real(&(*gen)._, gen_tag, O7C_GUARD(Ast_ExprReal_s, &expr)->real);
		}
		break;
	case 12:
		Expression_CString(&(*gen), gen_tag, O7C_GUARD(Ast_ExprString_s, &expr));
		break;
	case 5:
		Expression_Set(&(*gen), gen_tag, O7C_GUARD(Ast_ExprSet_s, &expr));
		break;
	case 25:
		Expression_Call(&(*gen), gen_tag, O7C_GUARD(Ast_ExprCall_s, &expr));
		break;
	case 20:
		Log_Str(27, (o7c_char *)"Expr Designator type.id = ");
		Log_Int(expr->type->_._.id);
		Log_Str(23, (o7c_char *)" (expr.value # NIL) = ");
		Log_Int((int)(expr->value_ != NULL));
		Log_Ln();
		if ((expr->value_ != NULL) && (o7c_cmp(expr->value_->_._.id, Ast_IdString_cnst) ==  0)) {
			Expression_CString(&(*gen), gen_tag, O7C_GUARD(Ast_ExprString_s, &expr->value_));
		} else {
			Designator(&(*gen), gen_tag, O7C_GUARD(Ast_Designator_s, &expr));
		}
		break;
	case 21:
		Expression_Relation(&(*gen), gen_tag, O7C_GUARD(Ast_ExprRelation_s, &expr));
		break;
	case 22:
		if (o7c_bl((*gen).opt->checkArith) && (o7c_in(expr->type->_._.id, ((1 << Ast_IdInteger_cnst) | (1 << Ast_IdReal_cnst)))) && (expr->value_ == NULL)) {
			Expression_SumCheck(&(*gen), gen_tag, O7C_GUARD(Ast_ExprSum_s, &expr));
		} else {
			Expression_Sum(&(*gen), gen_tag, O7C_GUARD(Ast_ExprSum_s, &expr));
		}
		break;
	case 23:
		if (o7c_bl((*gen).opt->checkArith) && (o7c_in(expr->type->_._.id, ((1 << Ast_IdInteger_cnst) | (1 << Ast_IdReal_cnst)))) && (expr->value_ == NULL)) {
			Expression_TermCheck(&(*gen), gen_tag, O7C_GUARD(Ast_ExprTerm_s, &expr));
		} else {
			Expression_Term(&(*gen), gen_tag, O7C_GUARD(Ast_ExprTerm_s, &expr));
		}
		break;
	case 24:
		if (o7c_cmp(expr->type->_._.id, Ast_IdSet_cnst) ==  0) {
			TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"~");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"!");
		}
		Expression(&(*gen), gen_tag, O7C_GUARD(Ast_ExprNegate_s, &expr)->expr);
		break;
	case 26:
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"(");
		Expression(&(*gen), gen_tag, O7C_GUARD(Ast_ExprBraces_s, &expr)->expr);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
		break;
	case 6:
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"NULL");
		break;
	case 27:
		Expression_IsExtension(&(*gen), gen_tag, O7C_GUARD(Ast_ExprIsExtension_s, &expr));
		break;
	default:
		abort();
		break;
	}
}

static void Invert(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag) {
	O7C_GUARD(GeneratorC_MemoryOut, &(*gen)._.out)->invert = !O7C_GUARD(GeneratorC_MemoryOut, &(*gen)._.out)->invert;
}

static void ProcHead(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RProcType *proc);
static void ProcHead_Parameters(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RProcType *proc);
static void Parameters_ProcHead_Par(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_FormalParam_s *fp) {
	struct Ast_RType *t = NULL;
	int i = O7C_INT_UNDEF;

	i = 0;
	t = fp->_._.type;
	while ((o7c_cmp(t->_._.id, Ast_IdArray_cnst) ==  0) && (O7C_GUARD(Ast_RArray, &t)->count == NULL)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"int ");
		Name(&(*gen), gen_tag, &fp->_._);
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"_len");
		TextGenerator_Int(&(*gen)._, gen_tag, i);
		TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
		i = o7c_add(i, 1);
		t = t->_.type;
	}
	t = fp->_._.type;
	declarator(&(*gen), gen_tag, &fp->_._, false, false, false);
	if (o7c_cmp(t->_._.id, Ast_IdRecord_cnst) ==  0) {
		TextGenerator_Str(&(*gen)._, gen_tag, 13, (o7c_char *)", o7c_tag_t ");
		Name(&(*gen), gen_tag, &fp->_._);
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"_tag");
	}
}

static void ProcHead_Parameters(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RProcType *proc) {
	struct Ast_RDeclaration *p = NULL;

	if (proc->params == NULL) {
		TextGenerator_Str(&(*gen)._, gen_tag, 7, (o7c_char *)"(void)");
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"(");
		p = (&(proc->params)->_._);
		while (p != &proc->end->_._) {
			Parameters_ProcHead_Par(&(*gen), gen_tag, O7C_GUARD(Ast_FormalParam_s, &p));
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
			p = p->next;
		}
		Parameters_ProcHead_Par(&(*gen), gen_tag, O7C_GUARD(Ast_FormalParam_s, &p));
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	}
}

static void ProcHead(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RProcType *proc) {
	ProcHead_Parameters(&(*gen), gen_tag, proc);
	Invert(&(*gen), gen_tag);
	type(&(*gen), gen_tag, NULL, proc->_._._.type, false, false);
	MemWriteInvert(&(*O7C_GUARD(GeneratorC_MemoryOut, &(*gen)._.out)), NULL);
}

static void Declarator(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *decl, o7c_bool typeDecl, o7c_bool sameType, o7c_bool global) {
	struct GeneratorC_Generator g;
	struct GeneratorC_MemoryOut *mo = NULL;
	GeneratorC_Generator_undef(&g);

	mo = PMemoryOutGet((*gen).opt);
	TextGenerator_Init(&g._, GeneratorC_Generator_tag, &mo->_);
	TextGenerator_SetTabs(&g._, GeneratorC_Generator_tag, &(*gen)._, gen_tag);
	g.module = (*gen).module;
	g.interface_ = (*gen).interface_;
	g.opt = (*gen).opt;
	if ((o7c_is(decl, Ast_FormalParam_s_tag)) && ((o7c_bl(O7C_GUARD(Ast_FormalParam_s, &decl)->isVar) && !(o7c_is(decl->type, Ast_RArray_tag))) || (o7c_is(decl->type, Ast_Record_s_tag)))) {
		TextGenerator_Str(&g._, GeneratorC_Generator_tag, 2, (o7c_char *)"*");
	} else if (o7c_is(decl, Ast_Const_s_tag)) {
		TextGenerator_Str(&g._, GeneratorC_Generator_tag, 7, (o7c_char *)"const ");
	}
	if (o7c_bl(global)) {
		GlobalName(&g, GeneratorC_Generator_tag, decl);
	} else {
		Name(&g, GeneratorC_Generator_tag, decl);
	}
	if (o7c_is(decl, Ast_RProcedure_tag)) {
		ProcHead(&g, GeneratorC_Generator_tag, O7C_GUARD(Ast_RProcedure, &decl)->_.header);
	} else {
		mo->invert = !mo->invert;
		if (o7c_is(decl, Ast_RType_tag)) {
			type(&g, GeneratorC_Generator_tag, decl, O7C_GUARD(Ast_RType, &decl), typeDecl, false);
		} else {
			type(&g, GeneratorC_Generator_tag, decl, decl->type, false, sameType);
		}
	}
	MemWriteDirect(&(*gen), gen_tag, &(*mo), GeneratorC_MemoryOut_tag);
	PMemoryOutBack((*gen).opt, mo);
}

static void VarInit(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *var_);
static void VarInit_InitZero(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *var_) {
	switch (var_->type->_._.id) {
	case 0:
	case 2:
	case 4:
	case 5:
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" = 0");
		break;
	case 1:
		TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)" = 0 > 1");
		break;
	case 3:
		TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)" = '\\0'");
		break;
	case 6:
	case 10:
		TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)" = NULL");
		break;
	case 7:
	case 8:
		break;
	default:
		abort();
		break;
	}
}

static void VarInit_InitUndef(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *var_) {
	switch (var_->type->_._.id) {
	case 0:
		TextGenerator_Str(&(*gen)._, gen_tag, 17, (o7c_char *)" = O7C_INT_UNDEF");
		break;
	case 1:
		TextGenerator_Str(&(*gen)._, gen_tag, 18, (o7c_char *)" = O7C_BOOL_UNDEF");
		break;
	case 2:
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" = 0");
		break;
	case 3:
		TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)" = '\\0'");
		break;
	case 4:
		TextGenerator_Str(&(*gen)._, gen_tag, 17, (o7c_char *)" = O7C_DBL_UNDEF");
		break;
	case 5:
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" = 0");
		break;
	case 6:
	case 10:
		TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)" = NULL");
		break;
	case 7:
	case 8:
		break;
	default:
		abort();
		break;
	}
}

static void VarInit(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *var_) {
	switch ((*gen).opt->varInit) {
	case 0:
		VarInit_InitUndef(&(*gen), gen_tag, var_);
		break;
	case 1:
		VarInit_InitZero(&(*gen), gen_tag, var_);
		break;
	case 2:
		if ((o7c_cmp(var_->type->_._.id, Ast_IdPointer_cnst) ==  0) && (o7c_cmp((*gen).opt->memManager, GeneratorC_MemManagerCounter_cnst) ==  0)) {
			TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)" = NULL");
		}
		break;
	default:
		abort();
		break;
	}
}

static void RecordUndefHeader(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Record_s *rec, o7c_bool interf) {
	if (o7c_bl(rec->_._._.mark) && !(*gen).opt->main_) {
		TextGenerator_Str(&(*gen)._, gen_tag, 13, (o7c_char *)"extern void ");
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 13, (o7c_char *)"static void ");
	}
	GlobalName(&(*gen), gen_tag, &rec->_._._);
	TextGenerator_Str(&(*gen)._, gen_tag, 15, (o7c_char *)"_undef(struct ");
	GlobalName(&(*gen), gen_tag, &rec->_._._);
	if (o7c_bl(interf)) {
		TextGenerator_StrLn(&(*gen)._, gen_tag, 6, (o7c_char *)" *r);");
	} else {
		TextGenerator_StrOpen(&(*gen)._, gen_tag, 7, (o7c_char *)" *r) {");
	}
}

static o7c_bool IsArrayTypeSimpleUndef(struct Ast_RType *typ, int *id, int *deep) {
	(*deep) = 0;
	while (o7c_cmp(typ->_._.id, Ast_IdArray_cnst) ==  0) {
		(*deep) = o7c_add((*deep), 1);
		typ = typ->_.type;
	}
	(*id) = typ->_._.id;
	return o7c_in((*id), ((1 << Ast_IdReal_cnst) | (1 << Ast_IdInteger_cnst) | (1 << Ast_IdBoolean_cnst)));
}

static void ArraySimpleUndef(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, int arrTypeId, struct Ast_RDeclaration *d, o7c_bool inRec) {
	switch (arrTypeId) {
	case 0:
		TextGenerator_Str(&(*gen)._, gen_tag, 16, (o7c_char *)"O7C_INTS_UNDEF(");
		break;
	case 4:
		TextGenerator_Str(&(*gen)._, gen_tag, 19, (o7c_char *)"O7C_DOUBLES_UNDEF(");
		break;
	case 1:
		TextGenerator_Str(&(*gen)._, gen_tag, 17, (o7c_char *)"O7C_BOOLS_UNDEF(");
		break;
	default:
		abort();
		break;
	}
	if (o7c_bl(inRec)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)"r->");
	}
	Name(&(*gen), gen_tag, d);
	/*
	FOR i := 2 TO arrDeep DO
		Text.Str(gen, "[0]")
	END;
	Text.Str(gen, "), ");
	Name(gen, d);
	FOR i := 2 TO arrDeep DO
		Text.Str(gen, "[0]")
	END;
	*/
	TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)");");
}

static void RecordUndefCall(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *var_) {
	GlobalName(&(*gen), gen_tag, &var_->type->_);
	TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"_undef(&");
	GlobalName(&(*gen), gen_tag, var_);
	TextGenerator_StrLn(&(*gen)._, gen_tag, 3, (o7c_char *)");");
}

static struct Ast_RType *TypeForUndef(struct Ast_RType *t) {
	if ((o7c_cmp(t->_._.id, Ast_IdRecord_cnst) !=  0) || (t->_._.ext == NULL) || !O7C_GUARD(RecExt_s, &t->_._.ext)->undef) {
		t = NULL;
	}
	return t;
}

static void RecordUndef(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Record_s *rec);
static void RecordUndef_IteratorIfNeed(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *var_) {
	int id = O7C_INT_UNDEF, deep = O7C_INT_UNDEF;

	while ((var_ != NULL) && ((o7c_cmp(var_->type->_._.id, Ast_IdArray_cnst) !=  0) || IsArrayTypeSimpleUndef(var_->type, &id, &deep) || (TypeForUndef(var_->type->_.type) == NULL))) {
		var_ = var_->next;
	}
	if (var_ != NULL) {
		TextGenerator_StrLn(&(*gen)._, gen_tag, 13, (o7c_char *)"o7c_int_t i;");
	}
}

static void RecordUndef_Memset(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *var_) {
	TextGenerator_Str(&(*gen)._, gen_tag, 12, (o7c_char *)"memset(&r->");
	Name(&(*gen), gen_tag, var_);
	TextGenerator_Str(&(*gen)._, gen_tag, 16, (o7c_char *)", 0, sizeof(r->");
	Name(&(*gen), gen_tag, var_);
	TextGenerator_StrLn(&(*gen)._, gen_tag, 4, (o7c_char *)"));");
}

/* TODO Навести порядок */
static void RecordUndef(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Record_s *rec) {
	struct Ast_RDeclaration *var_ = NULL;
	int arrTypeId = O7C_INT_UNDEF, arrDeep = O7C_INT_UNDEF;
	struct Ast_RType *typeUndef = NULL;

	RecordUndefHeader(&(*gen), gen_tag, rec, false);
	RecordUndef_IteratorIfNeed(&(*gen), gen_tag, &rec->vars->_);
	if (rec->base != NULL) {
		GlobalName(&(*gen), gen_tag, &rec->base->_._._);
		if (!(*gen).opt->plan9) {
			TextGenerator_StrLn(&(*gen)._, gen_tag, 15, (o7c_char *)"_undef(&r->_);");
		} else {
			TextGenerator_StrLn(&(*gen)._, gen_tag, 12, (o7c_char *)"_undef(&r);");
		}
	}
	O7C_GUARD(RecExt_s, &rec->_._._._.ext)->undef = true;
	var_ = (&(rec->vars)->_);
	while (var_ != NULL) {
		if (!(o7c_in(var_->type->_._.id, ((1 << Ast_IdArray_cnst) | (1 << Ast_IdRecord_cnst))))) {
			TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)"r->");
			Name(&(*gen), gen_tag, var_);
			VarInit(&(*gen), gen_tag, var_);
			TextGenerator_StrLn(&(*gen)._, gen_tag, 2, (o7c_char *)";");
		} else if (o7c_cmp(var_->type->_._.id, Ast_IdArray_cnst) ==  0) {
			typeUndef = TypeForUndef(var_->type->_.type);
			if (IsArrayTypeSimpleUndef(var_->type, &arrTypeId, &arrDeep)) {
				ArraySimpleUndef(&(*gen), gen_tag, arrTypeId, var_, true);
			} else if (typeUndef != NULL) {
				/* TODO вложенные циклы */
				TextGenerator_Str(&(*gen)._, gen_tag, 28, (o7c_char *)"for (i = 0; i < O7C_LEN(r->");
				Name(&(*gen), gen_tag, var_);
				TextGenerator_StrOpen(&(*gen)._, gen_tag, 13, (o7c_char *)"); i += 1) {");
				GlobalName(&(*gen), gen_tag, &typeUndef->_);
				TextGenerator_Str(&(*gen)._, gen_tag, 11, (o7c_char *)"_undef(r->");
				Name(&(*gen), gen_tag, var_);
				TextGenerator_StrLn(&(*gen)._, gen_tag, 7, (o7c_char *)" + i);");
				TextGenerator_StrLnClose(&(*gen)._, gen_tag, 2, (o7c_char *)"}");
			} else {
				RecordUndef_Memset(&(*gen), gen_tag, var_);
			}
		} else if ((o7c_cmp(var_->type->_._.id, Ast_IdRecord_cnst) ==  0) && (var_->type->_._.ext != NULL)) {
			GlobalName(&(*gen), gen_tag, &var_->type->_);
			TextGenerator_Str(&(*gen)._, gen_tag, 12, (o7c_char *)"_undef(&r->");
			Name(&(*gen), gen_tag, var_);
			TextGenerator_StrLn(&(*gen)._, gen_tag, 3, (o7c_char *)");");
		} else {
			RecordUndef_Memset(&(*gen), gen_tag, var_);
		}
		var_ = var_->next;
	}
	TextGenerator_StrLnClose(&(*gen)._, gen_tag, 2, (o7c_char *)"}");
}

static void Type(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *decl, struct Ast_RType *typ, o7c_bool typeDecl, o7c_bool sameType);
static void Type_Simple(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, int str_len0, o7c_char str[/*len0*/]) {
	TextGenerator_Str(&(*gen)._, gen_tag, str_len0, str);
	MemWriteInvert(&(*O7C_GUARD(GeneratorC_MemoryOut, &(*gen)._.out)), NULL);
}

static void Type_Record(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Record_s *rec) {
	struct Ast_RDeclaration *v = NULL;

	rec->_._._.module = (*gen).module;
	TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"struct ");
	if (CheckStructName(&(*gen), gen_tag, rec)) {
		GlobalName(&(*gen), gen_tag, &rec->_._._);
	}
	v = (&(rec->vars)->_);
	if ((v == NULL) && (rec->base == NULL) && !(*gen).opt->gnu) {
		TextGenerator_Str(&(*gen)._, gen_tag, 19, (o7c_char *)" { int nothing; } ");
	} else {
		TextGenerator_StrOpen(&(*gen)._, gen_tag, 3, (o7c_char *)" {");
		if (rec->base != NULL) {
			GlobalName(&(*gen), gen_tag, &rec->base->_._._);
			if (o7c_bl((*gen).opt->plan9)) {
				TextGenerator_StrLn(&(*gen)._, gen_tag, 2, (o7c_char *)";");
			} else {
				TextGenerator_StrLn(&(*gen)._, gen_tag, 4, (o7c_char *)" _;");
			}
		}
		while (v != NULL) {
			Declarator(&(*gen), gen_tag, v, false, false, false);
			TextGenerator_StrLn(&(*gen)._, gen_tag, 2, (o7c_char *)";");
			v = v->next;
		}
		TextGenerator_StrClose(&(*gen)._, gen_tag, 3, (o7c_char *)"} ");
	}
	MemWriteInvert(&(*O7C_GUARD(GeneratorC_MemoryOut, &(*gen)._.out)), NULL);
}

static void Type_Array(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *decl, struct Ast_RArray *arr, o7c_bool sameType) {
	struct Ast_RType *t = NULL;
	int i = O7C_INT_UNDEF;

	t = arr->_._._.type;
	MemWriteInvert(&(*O7C_GUARD(GeneratorC_MemoryOut, &(*gen)._.out)), NULL);
	if (arr->count != NULL) {
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"[");
		Expression(&(*gen), gen_tag, arr->count);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"]");
	} else if (o7c_bl((*gen).opt->vla)) {
		i = 0;
		t = (&(arr)->_._);
		do {
			TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"[");
			Name(&(*gen), gen_tag, decl);
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"_len");
			TextGenerator_Int(&(*gen)._, gen_tag, i);
			TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"]");
			t = t->_.type;
			i = o7c_add(i, 1);
		} while (!(o7c_cmp(t->_._.id, Ast_IdArray_cnst) !=  0));
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"[/*len0");
		i = 0;
		while (o7c_cmp(t->_._.id, Ast_IdArray_cnst) ==  0) {
			i = o7c_add(i, 1);
			TextGenerator_Str(&(*gen)._, gen_tag, 6, (o7c_char *)", len");
			TextGenerator_Int(&(*gen)._, gen_tag, i);
			t = t->_.type;
		}
		TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)"*/]");
	}
	Invert(&(*gen), gen_tag);
	Type(&(*gen), gen_tag, decl, t, false, sameType);
}

static void Type(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *decl, struct Ast_RType *typ, o7c_bool typeDecl, o7c_bool sameType) {
	if (typ == NULL) {
		TextGenerator_Str(&(*gen)._, gen_tag, 6, (o7c_char *)"void ");
		MemWriteInvert(&(*O7C_GUARD(GeneratorC_MemoryOut, &(*gen)._.out)), NULL);
	} else {
		if (!typeDecl && StringStore_IsDefined(&typ->_.name, StringStore_String_tag)) {
			if (o7c_bl(sameType)) {
				if ((o7c_is(typ, Ast_RPointer_tag)) && StringStore_IsDefined(&typ->_.type->_.name, StringStore_String_tag)) {
					TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"*");
				}
			} else {
				if ((o7c_is(typ, Ast_RPointer_tag)) && StringStore_IsDefined(&typ->_.type->_.name, StringStore_String_tag)) {
					TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"struct ");
					GlobalName(&(*gen), gen_tag, &typ->_.type->_);
					TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)" *");
				} else if (o7c_is(typ, Ast_Record_s_tag)) {
					TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"struct ");
					if (CheckStructName(&(*gen), gen_tag, O7C_GUARD(Ast_Record_s, &typ))) {
						GlobalName(&(*gen), gen_tag, &typ->_);
						TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)" ");
					}
				} else {
					GlobalName(&(*gen), gen_tag, &typ->_);
					TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)" ");
				}
				if (o7c_is((*gen)._.out, GeneratorC_MemoryOut_tag)) {
					MemWriteInvert(&(*O7C_GUARD(GeneratorC_MemoryOut, &(*gen)._.out)), NULL);
				}
			}
		} else if (!sameType || (o7c_in(typ->_._.id, ((1 << Ast_IdPointer_cnst) | (1 << Ast_IdArray_cnst) | (1 << Ast_IdProcType_cnst))))) {
			switch (typ->_._.id) {
			case 0:
				Type_Simple(&(*gen), gen_tag, 5, (o7c_char *)"int ");
				break;
			case 5:
				Type_Simple(&(*gen), gen_tag, 10, (o7c_char *)"unsigned ");
				break;
			case 1:
				if ((o7c_cmp((*gen).opt->std, GeneratorC_IsoC99_cnst) >=  0) && (o7c_cmp((*gen).opt->varInit, GeneratorC_VarInitUndefined_cnst) !=  0)) {
					Type_Simple(&(*gen), gen_tag, 6, (o7c_char *)"bool ");
				} else {
					Type_Simple(&(*gen), gen_tag, 10, (o7c_char *)"o7c_bool ");
				}
				break;
			case 2:
				Type_Simple(&(*gen), gen_tag, 15, (o7c_char *)"char unsigned ");
				break;
			case 3:
				Type_Simple(&(*gen), gen_tag, 10, (o7c_char *)"o7c_char ");
				break;
			case 4:
				Type_Simple(&(*gen), gen_tag, 8, (o7c_char *)"double ");
				break;
			case 6:
				TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"*");
				MemWriteInvert(&(*O7C_GUARD(GeneratorC_MemoryOut, &(*gen)._.out)), NULL);
				Invert(&(*gen), gen_tag);
				Type(&(*gen), gen_tag, decl, typ->_.type, false, sameType);
				break;
			case 7:
				Type_Array(&(*gen), gen_tag, decl, O7C_GUARD(Ast_RArray, &typ), sameType);
				break;
			case 8:
				Type_Record(&(*gen), gen_tag, O7C_GUARD(Ast_Record_s, &typ));
				break;
			case 10:
				TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"(*");
				MemWriteInvert(&(*O7C_GUARD(GeneratorC_MemoryOut, &(*gen)._.out)), NULL);
				TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
				ProcHead(&(*gen), gen_tag, O7C_GUARD(Ast_RProcType, &typ));
				break;
			default:
				abort();
				break;
			}
		}
		if (o7c_is((*gen)._.out, GeneratorC_MemoryOut_tag)) {
			MemWriteInvert(&(*O7C_GUARD(GeneratorC_MemoryOut, &(*gen)._.out)), NULL);
		}
	}
}

static void RecordTag(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Record_s *rec) {
	if (!rec->_._._.mark || o7c_bl((*gen).opt->main_)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 18, (o7c_char *)"static o7c_tag_t ");
	} else if (o7c_bl((*gen).interface_)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 18, (o7c_char *)"extern o7c_tag_t ");
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 11, (o7c_char *)"o7c_tag_t ");
	}
	GlobalName(&(*gen), gen_tag, &rec->_._._);
	TextGenerator_StrLn(&(*gen)._, gen_tag, 6, (o7c_char *)"_tag;");
	if (!rec->_._._.mark || o7c_bl((*gen).opt->main_) || o7c_bl((*gen).interface_)) {
		TextGenerator_Ln(&(*gen)._, gen_tag);
	}
}

static void TypeDecl(struct MOut *out, o7c_tag_t out_tag, struct Ast_RType *typ);
static void TypeDecl_Typedef(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RType *typ) {
	TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"typedef ");
	Declarator(&(*gen), gen_tag, &typ->_, true, false, true);
	TextGenerator_StrLn(&(*gen)._, gen_tag, 2, (o7c_char *)";");
}

static void TypeDecl_LinkRecord(struct GeneratorC_Options_s *opt, struct Ast_Record_s *rec) {
	struct RecExt_s *ext = NULL;

	assert(rec->_._._._.ext == NULL);
	O7C_NEW(&ext, RecExt_s);
	V_Init(&(*ext)._, RecExt_s_tag);
	StringStore_Undef(&ext->anonName, StringStore_String_tag);
	ext->next = NULL;
	ext->undef = false;
	rec->_._._._.ext = (&(ext)->_);
	if (opt->records == NULL) {
		opt->records = rec;
	} else {
		O7C_GUARD(RecExt_s, &opt->recordLast->_._._._.ext)->next = rec;
	}
	opt->recordLast = rec;
}

static void TypeDecl(struct MOut *out, o7c_tag_t out_tag, struct Ast_RType *typ) {
	TypeDecl_Typedef(&(*out).g[o7c_ind(2, (int)(o7c_bl(typ->_.mark) && !(*out).opt->main_))], GeneratorC_Generator_tag, typ);
	if ((o7c_cmp(typ->_._.id, Ast_IdRecord_cnst) ==  0) || (o7c_cmp(typ->_._.id, Ast_IdPointer_cnst) ==  0) && (typ->_.type->_.next == NULL)) {
		if (o7c_cmp(typ->_._.id, Ast_IdPointer_cnst) ==  0) {
			typ = typ->_.type;
		}
		typ->_.mark = o7c_bl(typ->_.mark) || (O7C_GUARD(Ast_Record_s, &typ)->pointer != NULL) && (O7C_GUARD(Ast_Record_s, &typ)->pointer->_._._.mark);
		TypeDecl_LinkRecord((*out).opt, O7C_GUARD(Ast_Record_s, &typ));
		if (o7c_bl(typ->_.mark) && !(*out).opt->main_) {
			RecordTag(&(*out).g[Interface_cnst], GeneratorC_Generator_tag, O7C_GUARD(Ast_Record_s, &typ));
			if (o7c_cmp((*out).opt->varInit, GeneratorC_VarInitUndefined_cnst) ==  0) {
				RecordUndefHeader(&(*out).g[Interface_cnst], GeneratorC_Generator_tag, O7C_GUARD(Ast_Record_s, &typ), true);
			}
		}
		RecordTag(&(*out).g[Implementation_cnst], GeneratorC_Generator_tag, O7C_GUARD(Ast_Record_s, &typ));
		if (o7c_cmp((*out).opt->varInit, GeneratorC_VarInitUndefined_cnst) ==  0) {
			RecordUndef(&(*out).g[Implementation_cnst], GeneratorC_Generator_tag, O7C_GUARD(Ast_Record_s, &typ));
		}
	}
}

static void Mark(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, o7c_bool mark) {
	if (o7c_cmp((*gen).localDeep, 0) ==  0) {
		if (o7c_bl(mark) && !(*gen).opt->main_) {
			TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"extern ");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"static ");
		}
	}
}

static void Comment(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct StringStore_String *com, o7c_tag_t com_tag) {
	struct StringStore_Iterator i;
	o7c_char prev = '\0';
	StringStore_Iterator_undef(&i);

	if (o7c_bl((*gen).opt->comment) && StringStore_GetIter(&i, StringStore_Iterator_tag, &(*com), com_tag, 0)) {
		do {
			prev = i.char_;
		} while (!(!StringStore_IterNext(&i, StringStore_Iterator_tag) || (prev == (char unsigned)'/') && (i.char_ == (char unsigned)'*') || (prev == (char unsigned)'*') && (i.char_ == (char unsigned)'/')));
		if (i.char_ == 0x00u) {
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"/*");
			TextGenerator_String(&(*gen)._, gen_tag, &(*com), com_tag);
			TextGenerator_StrLn(&(*gen)._, gen_tag, 3, (o7c_char *)"*/");
		}
	}
}

static void Const(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Const_s *const_) {
	Comment(&(*gen), gen_tag, &const_->_._.comment, StringStore_String_tag);
	TextGenerator_StrIgnoreIndent(&(*gen)._, gen_tag, 2, (o7c_char *)"#");
	TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"define ");
	GlobalName(&(*gen), gen_tag, &const_->_);
	TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)" ");
	if (o7c_bl(const_->_.mark) && (const_->expr != NULL)) {
		Factor(&(*gen), gen_tag, &const_->expr->value_->_);
	} else {
		Factor(&(*gen), gen_tag, const_->expr);
	}
	TextGenerator_Ln(&(*gen)._, gen_tag);
}

static void Var(struct MOut *out, o7c_tag_t out_tag, struct Ast_RDeclaration *prev, struct Ast_RDeclaration *var_, o7c_bool last) {
	o7c_bool same = O7C_BOOL_UNDEF, mark = O7C_BOOL_UNDEF;

	mark = o7c_bl(var_->mark) && !(*out).opt->main_;
	Comment(&(*out).g[o7c_ind(2, (int)mark)], GeneratorC_Generator_tag, &var_->_.comment, StringStore_String_tag);
	same = (prev != NULL) && (prev->mark == mark) && (prev->type == var_->type);
	if (!same) {
		if (prev != NULL) {
			TextGenerator_StrLn(&(*out).g[o7c_ind(2, (int)mark)]._, GeneratorC_Generator_tag, 2, (o7c_char *)";");
		}
		Mark(&(*out).g[o7c_ind(2, (int)mark)], GeneratorC_Generator_tag, mark);
	} else {
		TextGenerator_Str(&(*out).g[o7c_ind(2, (int)mark)]._, GeneratorC_Generator_tag, 3, (o7c_char *)", ");
	}
	if (o7c_bl(mark)) {
		Declarator(&(*out).g[Interface_cnst], GeneratorC_Generator_tag, var_, false, same, true);
		if (o7c_bl(last)) {
			TextGenerator_StrLn(&(*out).g[Interface_cnst]._, GeneratorC_Generator_tag, 2, (o7c_char *)";");
		}
		if (o7c_bl(same)) {
			TextGenerator_Str(&(*out).g[Implementation_cnst]._, GeneratorC_Generator_tag, 3, (o7c_char *)", ");
		} else if (prev != NULL) {
			TextGenerator_StrLn(&(*out).g[Implementation_cnst]._, GeneratorC_Generator_tag, 2, (o7c_char *)";");
		}
	}
	Declarator(&(*out).g[Implementation_cnst], GeneratorC_Generator_tag, var_, false, same, true);
	VarInit(&(*out).g[Implementation_cnst], GeneratorC_Generator_tag, var_);
	if (o7c_bl(last)) {
		TextGenerator_StrLn(&(*out).g[Implementation_cnst]._, GeneratorC_Generator_tag, 2, (o7c_char *)";");
	}
}

static void ExprThenStats(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RWhileIf **wi) {
	CheckExpr(&(*gen), gen_tag, (*wi)->_.expr);
	TextGenerator_StrOpen(&(*gen)._, gen_tag, 4, (o7c_char *)") {");
	statements(&(*gen), gen_tag, (*wi)->stats);
	(*wi) = (*wi)->elsif;
}

static o7c_bool IsCaseElementWithRange(struct Ast_CaseElement_s *elem) {
	struct Ast_CaseLabel_s *r = NULL;

	r = elem->labels;
	while ((r != NULL) && (r->right == NULL)) {
		r = r->next;
	}
	return r != NULL;
}

static void ExprSameType(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *expr, struct Ast_RType *expectType) {
	o7c_bool reref = O7C_BOOL_UNDEF, brace = O7C_BOOL_UNDEF;
	struct Ast_Record_s *base = NULL, *extend = NULL;

	base = NULL;
	reref = (o7c_cmp(expr->type->_._.id, Ast_IdPointer_cnst) ==  0) && (expr->type->_.type != expectType->_.type) && (o7c_cmp(expr->_.id, Ast_IdPointer_cnst) !=  0);
	brace = reref;
	if (!reref) {
		Expression(&(*gen), gen_tag, expr);
		if (o7c_cmp(expr->type->_._.id, Ast_IdRecord_cnst) ==  0) {
			base = O7C_GUARD(Ast_Record_s, &expectType);
			extend = O7C_GUARD(Ast_Record_s, &expr->type);
		}
	} else if (o7c_bl((*gen).opt->plan9)) {
		Expression(&(*gen), gen_tag, expr);
		brace = false;
	} else {
		base = O7C_GUARD(Ast_Record_s, &expectType->_.type);
		extend = O7C_GUARD(Ast_Record_s, &expr->type->_.type)->base;
		TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)"(&(");
		Expression(&(*gen), gen_tag, expr);
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)")->_");
	}
	if ((base != NULL) && (extend != base)) {
		/*ASSERT(expectType.id = Ast.IdRecord);*/
		if (o7c_bl((*gen).opt->plan9)) {
			TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)".");
			GlobalName(&(*gen), gen_tag, &expectType->_);
		} else {
			while (extend != base) {
				TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"._");
				extend = extend->base;
			}
		}
	}
	if (o7c_bl(brace)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	}
}

static void ExprForSize(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RExpression *e) {
	(*gen).insideSizeOf = true;
	Expression(&(*gen), gen_tag, e);
	(*gen).insideSizeOf = false;
}

static void Statement(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RStatement *st);
static void Statement_WhileIf(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RWhileIf *wi);
static void WhileIf_Statement_Elsif(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RWhileIf **wi) {
	while (((*wi) != NULL) && ((*wi)->_.expr != NULL)) {
		TextGenerator_StrClose(&(*gen)._, gen_tag, 12, (o7c_char *)"} else if (");
		ExprThenStats(&(*gen), gen_tag, &(*wi));
	}
}

static void Statement_WhileIf(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RWhileIf *wi) {
	if (o7c_is(wi, Ast_If_s_tag)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"if (");
		ExprThenStats(&(*gen), gen_tag, &wi);
		WhileIf_Statement_Elsif(&(*gen), gen_tag, &wi);
		if (wi != NULL) {
			TextGenerator_IndentClose(&(*gen)._, gen_tag);
			TextGenerator_StrOpen(&(*gen)._, gen_tag, 9, (o7c_char *)"} else {");
			statements(&(*gen), gen_tag, wi->stats);
		}
		TextGenerator_StrLnClose(&(*gen)._, gen_tag, 2, (o7c_char *)"}");
	} else if (wi->elsif == NULL) {
		TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"while (");
		ExprThenStats(&(*gen), gen_tag, &wi);
		TextGenerator_StrLnClose(&(*gen)._, gen_tag, 2, (o7c_char *)"}");
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 15, (o7c_char *)"while (1) if (");
		ExprThenStats(&(*gen), gen_tag, &wi);
		WhileIf_Statement_Elsif(&(*gen), gen_tag, &wi);
		TextGenerator_StrLnClose(&(*gen)._, gen_tag, 14, (o7c_char *)"} else break;");
	}
}

static void Statement_Repeat(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Repeat_s *st) {
	TextGenerator_StrOpen(&(*gen)._, gen_tag, 5, (o7c_char *)"do {");
	statements(&(*gen), gen_tag, st->stats);
	if (o7c_cmp(st->_.expr->_.id, Ast_IdNegate_cnst) ==  0) {
		TextGenerator_StrClose(&(*gen)._, gen_tag, 10, (o7c_char *)"} while (");
		Expression(&(*gen), gen_tag, O7C_GUARD(Ast_ExprNegate_s, &st->_.expr)->expr);
		TextGenerator_StrLn(&(*gen)._, gen_tag, 3, (o7c_char *)");");
	} else {
		TextGenerator_StrClose(&(*gen)._, gen_tag, 12, (o7c_char *)"} while (!(");
		CheckExpr(&(*gen), gen_tag, st->_.expr);
		TextGenerator_StrLn(&(*gen)._, gen_tag, 4, (o7c_char *)"));");
	}
}

static void Statement_For(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_For_s *st);
static o7c_bool For_Statement_IsEndMinus1(struct Ast_ExprSum_s *sum) {
	return (sum->next != NULL) && (sum->next->next == NULL) && (o7c_cmp(sum->next->add, Scanner_Minus_cnst) ==  0) && (sum->next->term->value_ != NULL) && (o7c_cmp(O7C_GUARD(Ast_RExprInteger, &sum->next->term->value_)->int_, 1) ==  0);
}

static void Statement_For(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_For_s *st) {
	TextGenerator_Str(&(*gen)._, gen_tag, 6, (o7c_char *)"for (");
	GlobalName(&(*gen), gen_tag, &st->var_->_);
	TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" = ");
	Expression(&(*gen), gen_tag, st->_.expr);
	TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"; ");
	GlobalName(&(*gen), gen_tag, &st->var_->_);
	if (o7c_cmp(st->by, 0) >  0) {
		if ((o7c_is(st->to, Ast_ExprSum_s_tag)) && For_Statement_IsEndMinus1(O7C_GUARD(Ast_ExprSum_s, &st->to))) {
			TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" < ");
			Expression(&(*gen), gen_tag, O7C_GUARD(Ast_ExprSum_s, &st->to)->term);
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" <= ");
			Expression(&(*gen), gen_tag, st->to);
		}
		if (o7c_cmp(st->by, 1) ==  0) {
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"; ++");
			GlobalName(&(*gen), gen_tag, &st->var_->_);
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"; ");
			GlobalName(&(*gen), gen_tag, &st->var_->_);
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" += ");
			TextGenerator_Int(&(*gen)._, gen_tag, st->by);
		}
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" >= ");
		Expression(&(*gen), gen_tag, st->to);
		if (o7c_cmp(st->by,  - 1) ==  0) {
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"; --");
			GlobalName(&(*gen), gen_tag, &st->var_->_);
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)"; ");
			GlobalName(&(*gen), gen_tag, &st->var_->_);
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" -= ");
			TextGenerator_Int(&(*gen)._, gen_tag, o7c_sub(0, st->by));
		}
	}
	TextGenerator_StrOpen(&(*gen)._, gen_tag, 4, (o7c_char *)") {");
	statements(&(*gen), gen_tag, st->stats);
	TextGenerator_StrLnClose(&(*gen)._, gen_tag, 2, (o7c_char *)"}");
}

static void Statement_Assign(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Assign_s *st);
static void Assign_Statement_AssertArraySize(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Designator_s *des, struct Ast_RExpression *e) {
	if (o7c_bl((*gen).opt->checkIndex) && ((O7C_GUARD(Ast_RArray, &des->_._.type)->count == NULL) || (O7C_GUARD(Ast_RArray, &e->type)->count == NULL))) {
		TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"assert(");
		ArrayLen(&(*gen), gen_tag, &des->_._);
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" >= ");
		ArrayLen(&(*gen), gen_tag, e);
		TextGenerator_StrLn(&(*gen)._, gen_tag, 3, (o7c_char *)");");
	}
}

static void Statement_Assign(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Assign_s *st) {
	o7c_bool retain = O7C_BOOL_UNDEF, toByte = O7C_BOOL_UNDEF;

	toByte = (o7c_cmp(st->designator->_._.type->_._.id, Ast_IdByte_cnst) ==  0) && (o7c_cmp(st->_.expr->type->_._.id, Ast_IdInteger_cnst) ==  0) && o7c_bl((*gen).opt->checkArith) && (st->_.expr->value_ == NULL);
	retain = (o7c_cmp(st->designator->_._.type->_._.id, Ast_IdPointer_cnst) ==  0) && (o7c_cmp((*gen).opt->memManager, GeneratorC_MemManagerCounter_cnst) ==  0);
	if (o7c_bl(retain) && (o7c_cmp(st->_.expr->_.id, Ast_IdPointer_cnst) ==  0)) {
		TextGenerator_Str(&(*gen)._, gen_tag, 11, (o7c_char *)"O7C_NULL(&");
		Designator(&(*gen), gen_tag, st->designator);
	} else {
		if (o7c_bl(retain)) {
			TextGenerator_Str(&(*gen)._, gen_tag, 13, (o7c_char *)"O7C_ASSIGN(&");
			Designator(&(*gen), gen_tag, st->designator);
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
		} else if ((o7c_cmp(st->designator->_._.type->_._.id, Ast_IdArray_cnst) ==  0)) {
			/*    & (st.designator.type.type.id # Ast.IdString) */
			Assign_Statement_AssertArraySize(&(*gen), gen_tag, st->designator, st->_.expr);
			TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"memcpy(");
			Designator(&(*gen), gen_tag, st->designator);
			TextGenerator_Str(&(*gen)._, gen_tag, 3, (o7c_char *)", ");
		} else if (o7c_bl(toByte)) {
			Designator(&(*gen), gen_tag, st->designator);
			TextGenerator_Str(&(*gen)._, gen_tag, 13, (o7c_char *)" = o7c_byte(");
		} else {
			Designator(&(*gen), gen_tag, st->designator);
			TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)" = ");
		}
		ExprSameType(&(*gen), gen_tag, st->_.expr, st->designator->_._.type);
		if (o7c_cmp(st->designator->_._.type->_._.id, Ast_IdArray_cnst) !=  0) {
		} else if (O7C_GUARD(Ast_RArray, &st->_.expr->type)->count != NULL) {
			TextGenerator_Str(&(*gen)._, gen_tag, 10, (o7c_char *)", sizeof(");
			ExprForSize(&(*gen), gen_tag, st->_.expr);
			TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)", (");
			ArrayLen(&(*gen), gen_tag, st->_.expr);
			TextGenerator_Str(&(*gen)._, gen_tag, 12, (o7c_char *)") * sizeof(");
			ExprForSize(&(*gen), gen_tag, st->_.expr);
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"[0])");
		}
	}
	{ int o7c_case_expr = o7c_add(o7c_add((int)retain, (int)toByte), (int)((o7c_cmp(st->designator->_._.type->_._.id, Ast_IdArray_cnst) ==  0) && (o7c_cmp(st->designator->_._.type->_.type->_._.id, Ast_IdString_cnst) !=  0)));
		switch (o7c_case_expr) {
		case 0:
			TextGenerator_StrLn(&(*gen)._, gen_tag, 2, (o7c_char *)";");
			break;
		case 1:
			TextGenerator_StrLn(&(*gen)._, gen_tag, 3, (o7c_char *)");");
			break;
		case 2:
			TextGenerator_StrLn(&(*gen)._, gen_tag, 4, (o7c_char *)"));");
			break;
		default:
			abort();
			break;
		}
	}
}

static void Statement_Case(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Case_s *st);
static void Case_Statement_CaseElement(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_CaseElement_s *elem) {
	struct Ast_CaseLabel_s *r = NULL;

	if (!IsCaseElementWithRange(elem)) {
		r = elem->labels;
		while (r != NULL) {
			TextGenerator_Str(&(*gen)._, gen_tag, 6, (o7c_char *)"case ");
			TextGenerator_Int(&(*gen)._, gen_tag, r->value_);
			assert(r->right == NULL);
			TextGenerator_StrLn(&(*gen)._, gen_tag, 2, (o7c_char *)":");
			r = r->next;
		}
		TextGenerator_IndentOpen(&(*gen)._, gen_tag);
		statements(&(*gen), gen_tag, elem->stats);
		TextGenerator_StrLn(&(*gen)._, gen_tag, 7, (o7c_char *)"break;");
		TextGenerator_IndentClose(&(*gen)._, gen_tag);
	}
}

static void Case_Statement_CaseElementAsIf(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_CaseElement_s *elem, struct Ast_RExpression *caseExpr);
static void CaseElementAsIf_Case_Statement_CaseRange(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_CaseLabel_s *r, struct Ast_RExpression *caseExpr) {
	if (r->right == NULL) {
		if (caseExpr == NULL) {
			TextGenerator_Str(&(*gen)._, gen_tag, 19, (o7c_char *)"(o7c_case_expr == ");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"(");
			Expression(&(*gen), gen_tag, caseExpr);
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" == ");
		}
		TextGenerator_Int(&(*gen)._, gen_tag, r->value_);
	} else {
		assert(o7c_cmp(r->value_, r->right->value_) <=  0);
		TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)"(");
		TextGenerator_Int(&(*gen)._, gen_tag, r->value_);
		if (caseExpr == NULL) {
			TextGenerator_Str(&(*gen)._, gen_tag, 39, (o7c_char *)" <= o7c_case_expr && o7c_case_expr <= ");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" <= ");
			Expression(&(*gen), gen_tag, caseExpr);
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" && ");
			Expression(&(*gen), gen_tag, caseExpr);
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" <= ");
		}
		TextGenerator_Int(&(*gen)._, gen_tag, r->right->value_);
	}
	TextGenerator_Str(&(*gen)._, gen_tag, 2, (o7c_char *)")");
}

static void Case_Statement_CaseElementAsIf(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_CaseElement_s *elem, struct Ast_RExpression *caseExpr) {
	struct Ast_CaseLabel_s *r = NULL;

	TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"if (");
	r = elem->labels;
	assert(r != NULL);
	CaseElementAsIf_Case_Statement_CaseRange(&(*gen), gen_tag, r, caseExpr);
	while (r->next != NULL) {
		r = r->next;
		TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)" || ");
		CaseElementAsIf_Case_Statement_CaseRange(&(*gen), gen_tag, r, caseExpr);
	}
	TextGenerator_StrOpen(&(*gen)._, gen_tag, 4, (o7c_char *)") {");
	statements(&(*gen), gen_tag, elem->stats);
	TextGenerator_StrClose(&(*gen)._, gen_tag, 2, (o7c_char *)"}");
}

static void Statement_Case(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_Case_s *st) {
	struct Ast_CaseElement_s *elem = NULL, *elemWithRange = NULL;
	struct Ast_RExpression *caseExpr = NULL;

	elemWithRange = st->elements;
	while ((elemWithRange != NULL) && !IsCaseElementWithRange(elemWithRange)) {
		elemWithRange = elemWithRange->next;
	}
	if ((elemWithRange == NULL) && !((o7c_is(st->_.expr, Ast_RFactor_tag)) && !(o7c_is(st->_.expr, Ast_ExprBraces_s_tag)))) {
		caseExpr = NULL;
		TextGenerator_Str(&(*gen)._, gen_tag, 23, (o7c_char *)"{ int o7c_case_expr = ");
		Expression(&(*gen), gen_tag, st->_.expr);
		TextGenerator_StrOpen(&(*gen)._, gen_tag, 2, (o7c_char *)";");
		TextGenerator_StrLn(&(*gen)._, gen_tag, 25, (o7c_char *)"switch (o7c_case_expr) {");
	} else {
		caseExpr = st->_.expr;
		TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"switch (");
		Expression(&(*gen), gen_tag, caseExpr);
		TextGenerator_StrLn(&(*gen)._, gen_tag, 4, (o7c_char *)") {");
	}
	elem = st->elements;
	do {
		Case_Statement_CaseElement(&(*gen), gen_tag, elem);
		elem = elem->next;
	} while (!(elem == NULL));
	TextGenerator_StrOpen(&(*gen)._, gen_tag, 9, (o7c_char *)"default:");
	if (elemWithRange != NULL) {
		elem = elemWithRange;
		Case_Statement_CaseElementAsIf(&(*gen), gen_tag, elem, caseExpr);
		elem = elem->next;
		while (elem != NULL) {
			if (IsCaseElementWithRange(elem)) {
				TextGenerator_Str(&(*gen)._, gen_tag, 7, (o7c_char *)" else ");
				Case_Statement_CaseElementAsIf(&(*gen), gen_tag, elem, caseExpr);
			}
			elem = elem->next;
		}
		if (o7c_bl((*gen).opt->caseAbort)) {
			TextGenerator_StrLn(&(*gen)._, gen_tag, 15, (o7c_char *)" else abort();");
		}
	} else if (o7c_bl((*gen).opt->caseAbort)) {
		TextGenerator_StrLn(&(*gen)._, gen_tag, 9, (o7c_char *)"abort();");
	}
	TextGenerator_StrLn(&(*gen)._, gen_tag, 7, (o7c_char *)"break;");
	TextGenerator_StrLnClose(&(*gen)._, gen_tag, 2, (o7c_char *)"}");
	if (caseExpr == NULL) {
		TextGenerator_StrLnClose(&(*gen)._, gen_tag, 2, (o7c_char *)"}");
	}
}

static void Statement(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RStatement *st) {
	Comment(&(*gen), gen_tag, &st->_.comment, StringStore_String_tag);
	if (o7c_is(st, Ast_Assign_s_tag)) {
		Statement_Assign(&(*gen), gen_tag, O7C_GUARD(Ast_Assign_s, &st));
	} else if (o7c_is(st, Ast_Call_s_tag)) {
		(*gen).expressionSemicolon = true;
		Expression(&(*gen), gen_tag, st->expr);
		if (o7c_bl((*gen).expressionSemicolon)) {
			TextGenerator_StrLn(&(*gen)._, gen_tag, 2, (o7c_char *)";");
		} else {
			TextGenerator_Ln(&(*gen)._, gen_tag);
		}
	} else if (o7c_is(st, Ast_RWhileIf_tag)) {
		Statement_WhileIf(&(*gen), gen_tag, O7C_GUARD(Ast_RWhileIf, &st));
	} else if (o7c_is(st, Ast_Repeat_s_tag)) {
		Statement_Repeat(&(*gen), gen_tag, O7C_GUARD(Ast_Repeat_s, &st));
	} else if (o7c_is(st, Ast_For_s_tag)) {
		Statement_For(&(*gen), gen_tag, O7C_GUARD(Ast_For_s, &st));
	} else if (o7c_is(st, Ast_Case_s_tag)) {
		Statement_Case(&(*gen), gen_tag, O7C_GUARD(Ast_Case_s, &st));
	} else {
		assert(false);
	}
}

static void Statements(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RStatement *stats) {
	while (stats != NULL) {
		Statement(&(*gen), gen_tag, stats);
		stats = stats->next;
	}
}

static void ProcDecl(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RProcedure *proc) {
	if (o7c_bl(proc->_._._.mark) && !(*gen).opt->main_) {
		TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"extern ");
	} else {
		TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"static ");
	}
	Declarator(&(*gen), gen_tag, &proc->_._._, false, false, true);
	TextGenerator_StrLn(&(*gen)._, gen_tag, 2, (o7c_char *)";");
}

static void Qualifier(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RType *typ) {
	switch (typ->_._.id) {
	case 0:
		TextGenerator_Str(&(*gen)._, gen_tag, 4, (o7c_char *)"int");
		break;
	case 5:
		TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"unsigned");
		break;
	case 1:
		if ((o7c_cmp((*gen).opt->std, GeneratorC_IsoC99_cnst) >=  0) && (o7c_cmp((*gen).opt->varInit, GeneratorC_VarInitUndefined_cnst) !=  0)) {
			TextGenerator_Str(&(*gen)._, gen_tag, 5, (o7c_char *)"bool");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"o7c_bool");
		}
		break;
	case 2:
		TextGenerator_Str(&(*gen)._, gen_tag, 14, (o7c_char *)"char unsigned");
		break;
	case 3:
		TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"o7c_char");
		break;
	case 4:
		TextGenerator_Str(&(*gen)._, gen_tag, 7, (o7c_char *)"double");
		break;
	case 6:
	case 10:
		GlobalName(&(*gen), gen_tag, &typ->_);
		break;
	default:
		abort();
		break;
	}
}

static void Procedure(struct MOut *out, o7c_tag_t out_tag, struct Ast_RProcedure *proc);
static void Procedure_Implement(struct MOut *out, o7c_tag_t out_tag, struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RProcedure *proc);
static void Implement_Procedure_CloseConsts(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *consts) {
	while ((consts != NULL) && (o7c_is(consts, Ast_Const_s_tag))) {
		TextGenerator_StrIgnoreIndent(&(*gen)._, gen_tag, 2, (o7c_char *)"#");
		TextGenerator_Str(&(*gen)._, gen_tag, 7, (o7c_char *)"undef ");
		Name(&(*gen), gen_tag, consts);
		TextGenerator_Ln(&(*gen)._, gen_tag);
		consts = consts->next;
	}
}

static struct Ast_RDeclaration *Implement_Procedure_SearchRetain(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *fp) {
	while ((fp != NULL) && ((o7c_cmp(fp->type->_._.id, Ast_IdPointer_cnst) !=  0) || o7c_bl(O7C_GUARD(Ast_FormalParam_s, &fp)->isVar))) {
		fp = fp->next;
	}
	return fp;
}

static void Implement_Procedure_RetainParams(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *fp) {
	if (fp != NULL) {
		TextGenerator_Str(&(*gen)._, gen_tag, 12, (o7c_char *)"o7c_retain(");
		Name(&(*gen), gen_tag, fp);
		fp = fp->next;
		while (fp != NULL) {
			if ((o7c_cmp(fp->type->_._.id, Ast_IdPointer_cnst) ==  0) && !O7C_GUARD(Ast_FormalParam_s, &fp)->isVar) {
				TextGenerator_Str(&(*gen)._, gen_tag, 15, (o7c_char *)"); o7c_retain(");
				Name(&(*gen), gen_tag, fp);
			}
			fp = fp->next;
		}
		TextGenerator_StrLn(&(*gen)._, gen_tag, 3, (o7c_char *)");");
	}
}

static void Implement_Procedure_ReleaseParams(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *fp) {
	if (fp != NULL) {
		TextGenerator_Str(&(*gen)._, gen_tag, 13, (o7c_char *)"o7c_release(");
		Name(&(*gen), gen_tag, fp);
		fp = fp->next;
		while (fp != NULL) {
			if ((o7c_cmp(fp->type->_._.id, Ast_IdPointer_cnst) ==  0) && !O7C_GUARD(Ast_FormalParam_s, &fp)->isVar) {
				TextGenerator_Str(&(*gen)._, gen_tag, 16, (o7c_char *)"); o7c_release(");
				Name(&(*gen), gen_tag, fp);
			}
			fp = fp->next;
		}
		TextGenerator_StrLn(&(*gen)._, gen_tag, 3, (o7c_char *)");");
	}
}

static void Implement_Procedure_ReleaseVars(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *var_) {
	o7c_bool first = O7C_BOOL_UNDEF;

	if (o7c_cmp((*gen).opt->memManager, GeneratorC_MemManagerCounter_cnst) ==  0) {
		first = true;
		while ((var_ != NULL) && (o7c_is(var_, Ast_RVar_tag))) {
			if (o7c_cmp(var_->type->_._.id, Ast_IdPointer_cnst) ==  0) {
				if (o7c_bl(first)) {
					first = false;
					TextGenerator_Str(&(*gen)._, gen_tag, 13, (o7c_char *)"o7c_release(");
				} else {
					TextGenerator_Str(&(*gen)._, gen_tag, 16, (o7c_char *)"); o7c_release(");
				}
				Name(&(*gen), gen_tag, var_);
			}
			var_ = var_->next;
		}
		if (!first) {
			TextGenerator_StrLn(&(*gen)._, gen_tag, 3, (o7c_char *)");");
		}
	}
}

static void Procedure_Implement(struct MOut *out, o7c_tag_t out_tag, struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RProcedure *proc) {
	struct Ast_RDeclaration *retainParams = NULL;

	Comment(&(*gen), gen_tag, &proc->_._._._.comment, StringStore_String_tag);
	Mark(&(*gen), gen_tag, proc->_._._.mark);
	Declarator(&(*gen), gen_tag, &proc->_._._, false, false, true);
	TextGenerator_StrOpen(&(*gen)._, gen_tag, 3, (o7c_char *)" {");
	(*gen).localDeep = o7c_add((*gen).localDeep, 1);
	(*gen).fixedLen = (*gen)._.len;
	if (o7c_cmp((*gen).opt->memManager, GeneratorC_MemManagerCounter_cnst) !=  0) {
		retainParams = NULL;
	} else {
		retainParams = Implement_Procedure_SearchRetain(&(*gen), gen_tag, &proc->_.header->params->_._);
		if (proc->_.return_ != NULL) {
			Qualifier(&(*gen), gen_tag, proc->_.return_->type);
			if (o7c_cmp(proc->_.return_->type->_._.id, Ast_IdPointer_cnst) ==  0) {
				TextGenerator_StrLn(&(*gen)._, gen_tag, 20, (o7c_char *)" o7c_return = NULL;");
			} else {
				TextGenerator_StrLn(&(*gen)._, gen_tag, 13, (o7c_char *)" o7c_return;");
			}
		}
	}
	declarations(&(*out), out_tag, &proc->_._);
	Implement_Procedure_RetainParams(&(*gen), gen_tag, retainParams);
	Statements(&(*gen), gen_tag, proc->_._.stats);
	if (proc->_.return_ == NULL) {
		Implement_Procedure_ReleaseVars(&(*gen), gen_tag, &proc->_._.vars->_);
		Implement_Procedure_ReleaseParams(&(*gen), gen_tag, retainParams);
	} else {
		if (o7c_cmp((*gen).opt->memManager, GeneratorC_MemManagerCounter_cnst) ==  0) {
			if (o7c_cmp(proc->_.return_->type->_._.id, Ast_IdPointer_cnst) ==  0) {
				TextGenerator_Str(&(*gen)._, gen_tag, 25, (o7c_char *)"O7C_ASSIGN(&o7c_return, ");
				CheckExpr(&(*gen), gen_tag, proc->_.return_);
				TextGenerator_StrLn(&(*gen)._, gen_tag, 3, (o7c_char *)");");
			} else {
				TextGenerator_Str(&(*gen)._, gen_tag, 14, (o7c_char *)"o7c_return = ");
				CheckExpr(&(*gen), gen_tag, proc->_.return_);
				TextGenerator_StrLn(&(*gen)._, gen_tag, 2, (o7c_char *)";");
			}
			Implement_Procedure_ReleaseVars(&(*gen), gen_tag, &proc->_._.vars->_);
			Implement_Procedure_ReleaseParams(&(*gen), gen_tag, retainParams);
			if (o7c_cmp(proc->_.return_->type->_._.id, Ast_IdPointer_cnst) ==  0) {
				TextGenerator_StrLn(&(*gen)._, gen_tag, 24, (o7c_char *)"o7c_unhold(o7c_return);");
			}
			TextGenerator_StrLn(&(*gen)._, gen_tag, 19, (o7c_char *)"return o7c_return;");
		} else {
			Implement_Procedure_ReleaseVars(&(*gen), gen_tag, &proc->_._.vars->_);
			Implement_Procedure_ReleaseParams(&(*gen), gen_tag, retainParams);
			TextGenerator_Str(&(*gen)._, gen_tag, 8, (o7c_char *)"return ");
			ExprSameType(&(*gen), gen_tag, proc->_.return_, proc->_.header->_._._.type);
			TextGenerator_StrLn(&(*gen)._, gen_tag, 2, (o7c_char *)";");
		}
	}
	(*gen).localDeep = o7c_sub((*gen).localDeep, 1);
	Implement_Procedure_CloseConsts(&(*gen), gen_tag, proc->_._.start);
	TextGenerator_StrLnClose(&(*gen)._, gen_tag, 2, (o7c_char *)"}");
	TextGenerator_Ln(&(*gen)._, gen_tag);
}

static void Procedure_LocalProcs(struct MOut *out, o7c_tag_t out_tag, struct Ast_RProcedure *proc) {
	struct Ast_RDeclaration *p = NULL, *t = NULL;

	t = (&(proc->_._.types)->_);
	while ((t != NULL) && (o7c_is(t, Ast_RType_tag))) {
		TypeDecl(&(*out), out_tag, O7C_GUARD(Ast_RType, &t));
		/*IF t IS Ast.Record THEN
				RecordTag(out.g[Implementation], t(Ast.Record))
			END;*/
		t = t->next;
	}
	p = (&(proc->_._.procedures)->_._._);
	if ((p != NULL) && !(*out).opt->procLocal) {
		if (!proc->_._._.mark) {
			/* TODO также проверить наличие рекурсии из локальных процедур*/
			ProcDecl(&(*out).g[Implementation_cnst], GeneratorC_Generator_tag, proc);
		}
		do {
			Procedure(&(*out), out_tag, O7C_GUARD(Ast_RProcedure, &p));
			p = p->next;
		} while (!(p == NULL));
	}
}

static void Procedure(struct MOut *out, o7c_tag_t out_tag, struct Ast_RProcedure *proc) {
	Procedure_LocalProcs(&(*out), out_tag, proc);
	if (o7c_bl(proc->_._._.mark) && !(*out).opt->main_) {
		ProcDecl(&(*out).g[Interface_cnst], GeneratorC_Generator_tag, proc);
	}
	Procedure_Implement(&(*out), out_tag, &(*out).g[Implementation_cnst], GeneratorC_Generator_tag, proc);
}

static void LnIfWrote(struct MOut *out, o7c_tag_t out_tag);
static void LnIfWrote_Write(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag) {
	if (o7c_cmp((*gen).fixedLen, (*gen)._.len) !=  0) {
		TextGenerator_Ln(&(*gen)._, gen_tag);
		(*gen).fixedLen = (*gen)._.len;
	}
}

static void LnIfWrote(struct MOut *out, o7c_tag_t out_tag) {
	if (!(*out).opt->main_) {
		LnIfWrote_Write(&(*out).g[Interface_cnst], GeneratorC_Generator_tag);
	}
	LnIfWrote_Write(&(*out).g[Implementation_cnst], GeneratorC_Generator_tag);
}

static void VarsInit(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *d) {
	int arrDeep = O7C_INT_UNDEF, arrTypeId = O7C_INT_UNDEF;

	while ((d != NULL) && (o7c_is(d, Ast_RVar_tag))) {
		if (o7c_in(d->type->_._.id, ((1 << Ast_IdArray_cnst) | (1 << Ast_IdRecord_cnst)))) {
			if ((o7c_cmp((*gen).opt->varInit, GeneratorC_VarInitUndefined_cnst) ==  0) && (d->type->_._.ext != NULL)) {
				RecordUndefCall(&(*gen), gen_tag, d);
			} else if ((o7c_cmp((*gen).opt->varInit, GeneratorC_VarInitZero_cnst) ==  0) || (o7c_cmp(d->type->_._.id, Ast_IdRecord_cnst) ==  0) || (o7c_cmp(d->type->_._.id, Ast_IdArray_cnst) ==  0) && !IsArrayTypeSimpleUndef(d->type, &arrTypeId, &arrDeep)) {
				TextGenerator_Str(&(*gen)._, gen_tag, 9, (o7c_char *)"memset(&");
				Name(&(*gen), gen_tag, d);
				TextGenerator_Str(&(*gen)._, gen_tag, 13, (o7c_char *)", 0, sizeof(");
				Name(&(*gen), gen_tag, d);
				TextGenerator_StrLn(&(*gen)._, gen_tag, 4, (o7c_char *)"));");
			} else {
				assert(o7c_cmp((*gen).opt->varInit, GeneratorC_VarInitUndefined_cnst) ==  0);
				ArraySimpleUndef(&(*gen), gen_tag, arrTypeId, d, false);
			}
		}
		d = d->next;
	}
}

static void Declarations(struct MOut *out, o7c_tag_t out_tag, struct Ast_RDeclarations *ds) {
	struct Ast_RDeclaration *d = NULL, *prev = NULL;

	d = ds->start;
	assert((d == NULL) || !(o7c_is(d, Ast_RModule_tag)));
	while ((d != NULL) && (o7c_is(d, Ast_Import_s_tag))) {
		Import(&(*out).g[o7c_ind(2, (int)!(*out).opt->main_)], GeneratorC_Generator_tag, d);
		d = d->next;
	}
	LnIfWrote(&(*out), out_tag);
	while ((d != NULL) && (o7c_is(d, Ast_Const_s_tag))) {
		Const(&(*out).g[o7c_ind(2, (int)(o7c_bl(d->mark) && !(*out).opt->main_))], GeneratorC_Generator_tag, O7C_GUARD(Ast_Const_s, &d));
		d = d->next;
	}
	LnIfWrote(&(*out), out_tag);
	if (o7c_is(ds, Ast_RModule_tag)) {
		while ((d != NULL) && (o7c_is(d, Ast_RType_tag))) {
			TypeDecl(&(*out), out_tag, O7C_GUARD(Ast_RType, &d));
			d = d->next;
		}
		LnIfWrote(&(*out), out_tag);
		while ((d != NULL) && (o7c_is(d, Ast_RVar_tag))) {
			Var(&(*out), out_tag, NULL, d, true);
			d = d->next;
		}
	} else {
		d = (&(ds->vars)->_);
		prev = NULL;
		while ((d != NULL) && (o7c_is(d, Ast_RVar_tag))) {
			Var(&(*out), out_tag, prev, d, (d->next == NULL) || !(o7c_is(d->next, Ast_RVar_tag)));
			prev = d;
			d = d->next;
		}
		if (o7c_cmp((*out).opt->varInit, GeneratorC_VarInitNo_cnst) !=  0) {
			VarsInit(&(*out).g[Implementation_cnst], GeneratorC_Generator_tag, &ds->vars->_);
		}
		d = (&(ds->procedures)->_._._);
	}
	LnIfWrote(&(*out), out_tag);
	if (o7c_bl((*out).opt->procLocal) || (o7c_is(ds, Ast_RModule_tag))) {
		while (d != NULL) {
			Procedure(&(*out), out_tag, O7C_GUARD(Ast_RProcedure, &d));
			d = d->next;
		}
	}
}

extern struct GeneratorC_Options_s *GeneratorC_DefaultOptions(void) {
	struct GeneratorC_Options_s *o = NULL;

	O7C_NEW(&o, GeneratorC_Options_s);
	if (o != NULL) {
		V_Init(&(*o)._, GeneratorC_Options_s_tag);
		o->std = GeneratorC_IsoC99_cnst;
		o->gnu = false;
		o->plan9 = false;
		o->procLocal = false;
		o->checkIndex = true;
		o->vla = false && (o7c_cmp(o->std, GeneratorC_IsoC99_cnst) >=  0);
		o->checkArith = true;
		o->caseAbort = true;
		o->comment = true;
		o->generatorNote = true;
		o->varInit = GeneratorC_VarInitUndefined_cnst;
		o->memManager = GeneratorC_MemManagerNoFree_cnst;
		o->main_ = false;
		o->memOuts = NULL;
	}
	return o;
}

static void MarkExpression(struct Ast_RExpression *e) {
	if (e != NULL) {
		if (o7c_cmp(e->_.id, Ast_IdRelation_cnst) ==  0) {
			MarkExpression(O7C_GUARD(Ast_ExprRelation_s, &e)->exprs[0]);
			MarkExpression(O7C_GUARD(Ast_ExprRelation_s, &e)->exprs[1]);
		} else if (o7c_cmp(e->_.id, Ast_IdTerm_cnst) ==  0) {
			MarkExpression(&O7C_GUARD(Ast_ExprTerm_s, &e)->factor->_);
			MarkExpression(O7C_GUARD(Ast_ExprTerm_s, &e)->expr);
		} else if (o7c_cmp(e->_.id, Ast_IdSum_cnst) ==  0) {
			MarkExpression(O7C_GUARD(Ast_ExprSum_s, &e)->term);
			MarkExpression(&O7C_GUARD(Ast_ExprSum_s, &e)->next->_);
		} else if ((o7c_cmp(e->_.id, Ast_IdDesignator_cnst) ==  0) && !O7C_GUARD(Ast_Designator_s, &e)->decl->mark) {
			O7C_GUARD(Ast_Designator_s, &e)->decl->mark = true;
			MarkExpression(O7C_GUARD(Ast_Const_s, &O7C_GUARD(Ast_Designator_s, &e)->decl)->expr);
		}
	}
}

static void MarkType(struct Ast_RType *t) {
	struct Ast_RDeclaration *d = NULL;

	while ((t != NULL) && !t->_.mark) {
		t->_.mark = true;
		if (o7c_cmp(t->_._.id, Ast_IdArray_cnst) ==  0) {
			MarkExpression(O7C_GUARD(Ast_RArray, &t)->count);
			t = t->_.type;
		} else if (o7c_in(t->_._.id, ((1 << Ast_IdRecord_cnst) | (1 << Ast_IdPointer_cnst)))) {
			if (o7c_cmp(t->_._.id, Ast_IdPointer_cnst) ==  0) {
				t = t->_.type;
				t->_.mark = true;
				assert(t->_.module != NULL);
			}
			d = (&(O7C_GUARD(Ast_Record_s, &t)->vars)->_);
			while (d != NULL) {
				MarkType(d->type);
				/*IF Strings.IsDefined(d.name) THEN
					Log.StrLn(d.name.block.s)
				END;*/
				d = d->next;
			}
			t = (&(O7C_GUARD(Ast_Record_s, &t)->base)->_._);
		} else {
			t = NULL;
		}
	}
}

static void MarkUsedInMarked(struct Ast_RModule *m);
static void MarkUsedInMarked_Consts(struct Ast_RDeclaration *c) {
	while ((c != NULL) && (o7c_is(c, Ast_Const_s_tag))) {
		if (o7c_bl(c->mark)) {
			MarkExpression(O7C_GUARD(Ast_Const_s, &c)->expr);
		}
		c = c->next;
	}
}

static void MarkUsedInMarked_Types(struct Ast_RDeclaration *t) {
	while ((t != NULL) && (o7c_is(t, Ast_RType_tag))) {
		if (o7c_bl(t->mark)) {
			t->mark = false;
			MarkType(O7C_GUARD(Ast_RType, &t));
		}
		t = t->next;
	}
}

static void MarkUsedInMarked_Procs(struct Ast_RDeclaration *p) {
	struct Ast_RDeclaration *fp = NULL;

	while ((p != NULL) && (o7c_is(p, Ast_RProcedure_tag))) {
		if (o7c_bl(p->mark)) {
			fp = (&(O7C_GUARD(Ast_RProcedure, &p)->_.header->params)->_._);
			while (fp != NULL) {
				MarkType(fp->type);
				fp = fp->next;
			}
		}
		p = p->next;
	}
}

static void MarkUsedInMarked(struct Ast_RModule *m) {
	struct Ast_RDeclaration *imp = NULL;

	imp = (&(m->import_)->_);
	while ((imp != NULL) && (o7c_is(imp, Ast_Import_s_tag))) {
		MarkUsedInMarked(imp->module);
		imp = imp->next;
	}
	MarkUsedInMarked_Consts(&m->_.consts->_);
	MarkUsedInMarked_Types(&m->_.types->_);
	MarkUsedInMarked_Procs(&m->_.procedures->_._._);
}

static void ImportInit(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RDeclaration *imp) {
	if (imp != NULL) {
		assert(o7c_is(imp, Ast_Import_s_tag));
		do {
			TextGenerator_String(&(*gen)._, gen_tag, &imp->module->_._.name, StringStore_String_tag);
			TextGenerator_StrLn(&(*gen)._, gen_tag, 9, (o7c_char *)"_init();");
			imp = imp->next;
		} while (!((imp == NULL) || !(o7c_is(imp, Ast_Import_s_tag))));
		TextGenerator_Ln(&(*gen)._, gen_tag);
	}
}

static void TagsInit(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag) {
	struct Ast_Record_s *r = NULL;

	r = NULL;
	while ((*gen).opt->records != NULL) {
		r = (*gen).opt->records;
		(*gen).opt->records = O7C_GUARD(RecExt_s, &r->_._._._.ext)->next;
		O7C_GUARD(RecExt_s, &r->_._._._.ext)->next = NULL;
		TextGenerator_Str(&(*gen)._, gen_tag, 14, (o7c_char *)"o7c_tag_init(");
		GlobalName(&(*gen), gen_tag, &r->_._._);
		if (r->base == NULL) {
			TextGenerator_StrLn(&(*gen)._, gen_tag, 13, (o7c_char *)"_tag, NULL);");
		} else {
			TextGenerator_Str(&(*gen)._, gen_tag, 7, (o7c_char *)"_tag, ");
			GlobalName(&(*gen), gen_tag, &r->base->_._._);
			TextGenerator_StrLn(&(*gen)._, gen_tag, 7, (o7c_char *)"_tag);");
		}
	}
	if (r != NULL) {
		TextGenerator_Ln(&(*gen)._, gen_tag);
	}
}

static void Generate_Init(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct VDataStream_Out *out, struct Ast_RModule *module, struct GeneratorC_Options_s *opt, o7c_bool interface_) {
	TextGenerator_Init(&(*gen)._, gen_tag, out);
	(*gen).module = module;
	(*gen).localDeep = 0;
	(*gen).opt = opt;
	(*gen).fixedLen = (*gen)._.len;
	(*gen).interface_ = interface_;
	(*gen).insideSizeOf = false;
}

static void Generate_Includes(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag) {
	TextGenerator_StrLn(&(*gen)._, gen_tag, 20, (o7c_char *)"#include <stdlib.h>");
	TextGenerator_StrLn(&(*gen)._, gen_tag, 20, (o7c_char *)"#include <stddef.h>");
	TextGenerator_StrLn(&(*gen)._, gen_tag, 20, (o7c_char *)"#include <string.h>");
	TextGenerator_StrLn(&(*gen)._, gen_tag, 20, (o7c_char *)"#include <assert.h>");
	TextGenerator_StrLn(&(*gen)._, gen_tag, 18, (o7c_char *)"#include <math.h>");
	if (o7c_cmp((*gen).opt->std, GeneratorC_IsoC99_cnst) >=  0) {
		TextGenerator_StrLn(&(*gen)._, gen_tag, 21, (o7c_char *)"#include <stdbool.h>");
	}
	TextGenerator_Ln(&(*gen)._, gen_tag);
	if (o7c_cmp((*gen).opt->varInit, GeneratorC_VarInitUndefined_cnst) ==  0) {
		TextGenerator_StrLn(&(*gen)._, gen_tag, 27, (o7c_char *)"#define O7C_BOOL_UNDEFINED");
	}
	TextGenerator_StrLn(&(*gen)._, gen_tag, 17, (o7c_char *)"#include <o7c.h>");
	TextGenerator_Ln(&(*gen)._, gen_tag);
}

static void Generate_HeaderGuard(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag) {
	TextGenerator_Str(&(*gen)._, gen_tag, 27, (o7c_char *)"#if !defined(HEADER_GUARD_");
	TextGenerator_String(&(*gen)._, gen_tag, &(*gen).module->_._.name, StringStore_String_tag);
	TextGenerator_StrLn(&(*gen)._, gen_tag, 2, (o7c_char *)")");
	TextGenerator_Str(&(*gen)._, gen_tag, 22, (o7c_char *)"#define HEADER_GUARD_");
	TextGenerator_String(&(*gen)._, gen_tag, &(*gen).module->_._.name, StringStore_String_tag);
	TextGenerator_Ln(&(*gen)._, gen_tag);
	TextGenerator_Ln(&(*gen)._, gen_tag);
}

static void Generate_ModuleInit(struct GeneratorC_Generator *interf, o7c_tag_t interf_tag, struct GeneratorC_Generator *impl, o7c_tag_t impl_tag, struct Ast_RModule *module) {
	if ((module->import_ == NULL) && (module->_.stats == NULL) && ((*impl).opt->records == NULL)) {
		if (o7c_cmp((*impl).opt->std, GeneratorC_IsoC99_cnst) >=  0) {
			TextGenerator_Str(&(*interf)._, interf_tag, 20, (o7c_char *)"static inline void ");
		} else {
			TextGenerator_Str(&(*interf)._, interf_tag, 17, (o7c_char *)"O7C_INLINE void ");
		}
		Name(&(*interf), interf_tag, &module->_._);
		TextGenerator_StrLn(&(*interf)._, interf_tag, 18, (o7c_char *)"_init(void) { ; }");
	} else {
		TextGenerator_Str(&(*interf)._, interf_tag, 13, (o7c_char *)"extern void ");
		Name(&(*interf), interf_tag, &module->_._);
		TextGenerator_StrLn(&(*interf)._, interf_tag, 13, (o7c_char *)"_init(void);");
		TextGenerator_Str(&(*impl)._, impl_tag, 13, (o7c_char *)"extern void ");
		Name(&(*impl), impl_tag, &module->_._);
		TextGenerator_StrOpen(&(*impl)._, impl_tag, 14, (o7c_char *)"_init(void) {");
		TextGenerator_StrLn(&(*impl)._, impl_tag, 28, (o7c_char *)"static int initialized = 0;");
		TextGenerator_StrOpen(&(*impl)._, impl_tag, 24, (o7c_char *)"if (0 == initialized) {");
		ImportInit(&(*impl), impl_tag, &module->import_->_);
		TagsInit(&(*impl), impl_tag);
		Statements(&(*impl), impl_tag, module->_.stats);
		TextGenerator_StrLnClose(&(*impl)._, impl_tag, 2, (o7c_char *)"}");
		TextGenerator_StrLn(&(*impl)._, impl_tag, 15, (o7c_char *)"++initialized;");
		TextGenerator_StrLnClose(&(*impl)._, impl_tag, 2, (o7c_char *)"}");
		TextGenerator_Ln(&(*impl)._, impl_tag);
	}
}

static void Generate_Main(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag, struct Ast_RModule *module, struct Ast_RStatement *cmd) {
	TextGenerator_StrOpen(&(*gen)._, gen_tag, 42, (o7c_char *)"extern int main(int argc, char *argv[]) {");
	TextGenerator_StrLn(&(*gen)._, gen_tag, 22, (o7c_char *)"o7c_init(argc, argv);");
	ImportInit(&(*gen), gen_tag, &module->import_->_);
	TagsInit(&(*gen), gen_tag);
	if (module->_.stats != NULL) {
		Statements(&(*gen), gen_tag, module->_.stats);
	}
	while (cmd != NULL) {
		Statement(&(*gen), gen_tag, cmd);
		cmd = cmd->next;
	}
	TextGenerator_StrLn(&(*gen)._, gen_tag, 22, (o7c_char *)"return o7c_exit_code;");
	TextGenerator_StrLnClose(&(*gen)._, gen_tag, 2, (o7c_char *)"}");
}

static void Generate_GeneratorNotify(struct GeneratorC_Generator *gen, o7c_tag_t gen_tag) {
	if (o7c_bl((*gen).opt->generatorNote)) {
		TextGenerator_StrLn(&(*gen)._, gen_tag, 49, (o7c_char *)"/* Generated by Vostok - Oberon-07 translator */");
		TextGenerator_Ln(&(*gen)._, gen_tag);
	}
}

extern void GeneratorC_Generate(struct VDataStream_Out *interface_, struct VDataStream_Out *implementation, struct Ast_RModule *module, struct Ast_RStatement *cmd, struct GeneratorC_Options_s *opt) {
	struct MOut out;
	MOut_undef(&out);

	assert(!Ast_HasError(module));
	if (opt == NULL) {
		opt = GeneratorC_DefaultOptions();
	}
	out.opt = opt;
	opt->records = NULL;
	opt->recordLast = NULL;
	opt->index = 0;
	opt->main_ = interface_ == NULL;
	if (!opt->main_) {
		MarkUsedInMarked(module);
	}
	if (interface_ != NULL) {
		Generate_Init(&out.g[Interface_cnst], GeneratorC_Generator_tag, interface_, module, opt, true);
		Generate_GeneratorNotify(&out.g[Interface_cnst], GeneratorC_Generator_tag);
	}
	Generate_Init(&out.g[Implementation_cnst], GeneratorC_Generator_tag, implementation, module, opt, false);
	Generate_GeneratorNotify(&out.g[Implementation_cnst], GeneratorC_Generator_tag);
	Comment(&out.g[o7c_ind(2, (int)!opt->main_)], GeneratorC_Generator_tag, &module->_._._.comment, StringStore_String_tag);
	Generate_Includes(&out.g[Implementation_cnst], GeneratorC_Generator_tag);
	if (!opt->main_) {
		Generate_HeaderGuard(&out.g[Interface_cnst], GeneratorC_Generator_tag);
		Import(&out.g[Implementation_cnst], GeneratorC_Generator_tag, &module->_._);
	}
	Declarations(&out, MOut_tag, &module->_);
	if (o7c_bl(opt->main_)) {
		Generate_Main(&out.g[Implementation_cnst], GeneratorC_Generator_tag, module, cmd);
	} else {
		Generate_ModuleInit(&out.g[Interface_cnst], GeneratorC_Generator_tag, &out.g[Implementation_cnst], GeneratorC_Generator_tag, module);
		TextGenerator_StrLn(&out.g[Interface_cnst]._, GeneratorC_Generator_tag, 7, (o7c_char *)"#endif");
	}
}

extern void GeneratorC_init(void) {
	static int initialized = 0;
	if (0 == initialized) {
		V_init();
		Ast_init();
		StringStore_init();
		Scanner_init();
		VDataStream_init();
		TextGenerator_init();
		Utf8_init();
		Log_init();
		Limits_init();
		TranslatorLimits_init();

		o7c_tag_init(GeneratorC_MemoryOut_tag, VDataStream_Out_tag);
		o7c_tag_init(GeneratorC_Options_s_tag, V_Base_tag);
		o7c_tag_init(GeneratorC_Generator_tag, TextGenerator_Out_tag);
		o7c_tag_init(MOut_tag, NULL);
		o7c_tag_init(Selectors_tag, NULL);
		o7c_tag_init(RecExt_s_tag, V_Base_tag);

		type = Type;
		declarator = Declarator;
		declarations = Declarations;
		statements = Statements;
		expression = Expression;
	}
	++initialized;
}

