/* Generated by Vostok - Oberon-07 translator */

#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <assert.h>
#include <math.h>
#include <stdbool.h>

#define O7C_BOOL_UNDEFINED
#include <o7c.h>

#include "Parser.h"

#define ErrNo_cnst 0
#define ErrMin_cnst Parser_ErrAstEnd_cnst

o7c_tag_t Parser_Options_tag;
extern void Parser_Options_undef(struct Parser_Options *r) {
	V_Base_undef(&r->_);
	r->strictSemicolon = O7C_BOOL_UNDEF;
	r->strictReturn = O7C_BOOL_UNDEF;
	r->saveComments = O7C_BOOL_UNDEF;
	r->multiErrors = O7C_BOOL_UNDEF;
	r->printError = NULL;
}
typedef struct Parser {
	V_Base _;
	struct Parser_Options opt;
	o7c_bool err;
	int errorsCount;
	o7c_bool varParam;
	struct Scanner_Scanner s;
	int l;
	struct Parser_anon_0000 {
		int ofs;
		int end;
	} comment;
	int inLoops;
	int inConditions;
	struct Ast_RModule *module;
	struct Ast_RProvider *provider;
} Parser;
static o7c_tag_t Parser_tag;

static void Parser_undef(struct Parser *r) {
	V_Base_undef(&r->_);
	Parser_Options_undef(&r->opt);
	r->err = O7C_BOOL_UNDEF;
	r->errorsCount = O7C_INT_UNDEF;
	r->varParam = O7C_BOOL_UNDEF;
	Scanner_Scanner_undef(&r->s);
	r->l = O7C_INT_UNDEF;
	memset(&r->comment, 0, sizeof(r->comment));
	r->inLoops = O7C_INT_UNDEF;
	r->inConditions = O7C_INT_UNDEF;
	r->module = NULL;
	r->provider = NULL;
}

static void (*declarations)(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) = NULL;
static struct Ast_RType *(*type)(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, int nameBegin, int nameEnd) = NULL;
static struct Ast_RStatement *(*statements)(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) = NULL;
static struct Ast_RExpression *(*expression)(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) = NULL;

static void AddError(struct Parser *p, o7c_tag_t p_tag, int err) {
	if ((o7c_cmp((*p).errorsCount, 0) ==  0) || o7c_bl((*p).opt.multiErrors)) {
		(*p).errorsCount = o7c_add((*p).errorsCount, 1);
		Log_Str(10, (o7c_char *)"AddError ");
		Log_Int(err);
		Log_Str(5, (o7c_char *)" at ");
		Log_Int((*p).s.line);
		Log_Str(2, (o7c_char *)":");
		Log_Int(o7c_add((*p).s.column, o7c_mul((*p).s.tabs, 3)));
		Log_Ln();
		(*p).err = o7c_cmp(err, Parser_ErrAstBegin_cnst) >  0;
		if ((*p).module != NULL) {
			Ast_AddError((*p).module, err, (*p).s.line, (*p).s.column, (*p).s.tabs);
		}
	}
	if (o7c_bl((*p).opt.multiErrors)) {
		(*p).opt.printError(err);
		Out_String(3, (o7c_char *)". ");
		Out_Int(o7c_add((*p).s.line, 1), 2);
		Out_String(2, (o7c_char *)":");
		Out_Int(o7c_add((*p).s.column, o7c_mul((*p).s.tabs, 3)), 2);
		Out_Ln();
	}
}

static void CheckAst(struct Parser *p, o7c_tag_t p_tag, int err) {
	if (o7c_cmp(err, Ast_ErrNo_cnst) !=  0) {
		assert((o7c_cmp(err, ErrNo_cnst) <  0) && (o7c_cmp(err, Ast_ErrMin_cnst) >=  0));
		AddError(&(*p), p_tag, o7c_add(Parser_ErrAstBegin_cnst, err));
	}
}

static void Scan(struct Parser *p, o7c_tag_t p_tag) {
	if ((o7c_cmp((*p).errorsCount, 0) ==  0) || o7c_bl((*p).opt.multiErrors)) {
		(*p).l = Scanner_Next(&(*p).s, Scanner_Scanner_tag);
		if (o7c_cmp((*p).l, ErrNo_cnst) <  0) {
			AddError(&(*p), p_tag, (*p).l);
			if (o7c_cmp((*p).l, Scanner_ErrNumberTooBig_cnst) ==  0) {
				(*p).l = Scanner_Number_cnst;
			}
		} else if (o7c_cmp((*p).l, Scanner_Semicolon_cnst) ==  0) {
			Scanner_ResetComment(&(*p).s, Scanner_Scanner_tag);
		}
	} else {
		(*p).l = Scanner_EndOfFile_cnst;
	}
}

static void Expect(struct Parser *p, o7c_tag_t p_tag, int expect, int error) {
	if (o7c_cmp((*p).l, expect) ==  0) {
		Scan(&(*p), p_tag);
	} else {
		AddError(&(*p), p_tag, error);
	}
}

static o7c_bool ScanIfEqual(struct Parser *p, o7c_tag_t p_tag, int lex) {
	if (o7c_cmp((*p).l, lex) ==  0) {
		Scan(&(*p), p_tag);
		lex = (*p).l;
	}
	return o7c_cmp((*p).l, lex) ==  0;
}

static void ExpectIdent(struct Parser *p, o7c_tag_t p_tag, int *begin, int *end, int error) {
	if (o7c_cmp((*p).l, Scanner_Ident_cnst) ==  0) {
		(*begin) = (*p).s.lexStart;
		(*end) = (*p).s.lexEnd;
		Scan(&(*p), p_tag);
	} else {
		/* p.l > ErrNo THEN */
		AddError(&(*p), p_tag, error);
		(*begin) =  - 1;
		(*end) =  - 1;
	}
}

static struct Ast_ExprSet_s *Set(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds);
static int Set_Element(struct Ast_ExprSet_s **e, struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_RExpression *left = NULL;
	int err = O7C_INT_UNDEF;

	left = expression(&(*p), p_tag, ds);
	if (o7c_cmp((*p).l, Scanner_Range_cnst) ==  0) {
		Scan(&(*p), p_tag);
		err = Ast_ExprSetNew(&(*e), left, expression(&(*p), p_tag, ds));
	} else {
		err = Ast_ExprSetNew(&(*e), left, NULL);
	}
	return err;
}

static struct Ast_ExprSet_s *Set(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_ExprSet_s *e = NULL, *next = NULL;
	int err = O7C_INT_UNDEF;

	assert(o7c_cmp((*p).l, Scanner_Brace3Open_cnst) ==  0);
	Scan(&(*p), p_tag);
	if (o7c_cmp((*p).l, Scanner_Brace3Close_cnst) !=  0) {
		err = Set_Element(&e, &(*p), p_tag, ds);
		CheckAst(&(*p), p_tag, err);
		next = e;
		while (ScanIfEqual(&(*p), p_tag, Scanner_Comma_cnst)) {
			err = Set_Element(&next->next, &(*p), p_tag, ds);
			CheckAst(&(*p), p_tag, err);
			next = next->next;
		}
		Expect(&(*p), p_tag, Scanner_Brace3Close_cnst, Parser_ErrExpectBrace3Close_cnst);
	} else {
		/* Пустое множество */
		CheckAst(&(*p), p_tag, Ast_ExprSetNew(&e, NULL, NULL));
		Scan(&(*p), p_tag);
	}
	return e;
}

static struct Ast_RDeclaration *DeclarationGet(struct Ast_RDeclarations *ds, struct Parser *p, o7c_tag_t p_tag) {
	struct Ast_RDeclaration *d = NULL;

	Log_StrLn(15, (o7c_char *)"DeclarationGet");
	CheckAst(&(*p), p_tag, Ast_DeclarationGet(&d, ds, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, (*p).s.lexStart, (*p).s.lexEnd));
	return d;
}

static struct Ast_RDeclaration *ExpectDecl(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_RDeclaration *d = NULL;

	if (o7c_cmp((*p).l, Scanner_Ident_cnst) !=  0) {
		d = Ast_DeclErrorNew(ds, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf,  - 1,  - 1);
		AddError(&(*p), p_tag, Parser_ErrExpectIdent_cnst);
	} else {
		d = DeclarationGet(ds, &(*p), p_tag);
		Scan(&(*p), p_tag);
	}
	return d;
}

static struct Ast_RDeclaration *Qualident(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_RDeclaration *d = NULL;

	Log_StrLn(10, (o7c_char *)"Qualident");
	d = ExpectDecl(&(*p), p_tag, ds);
	if (o7c_is(d, Ast_Import_s_tag)) {
		Expect(&(*p), p_tag, Scanner_Dot_cnst, Parser_ErrExpectDot_cnst);
		d = ExpectDecl(&(*p), p_tag, &O7C_GUARD(Ast_Import_s, &d)->_.module->_);
	}
	return d;
}

static struct Ast_RDeclaration *ExpectRecordExtend(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, struct Ast_RConstruct *base) {
	struct Ast_RDeclaration *d = NULL;

	/*TODO*/
	d = Qualident(&(*p), p_tag, ds);
	return d;
}

static struct Ast_Designator_s *Designator(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds);
static void Designator_SetSel(struct Ast_RSelector **prev, struct Ast_RSelector *sel, struct Ast_Designator_s *des) {
	if ((*prev) == NULL) {
		des->sel = sel;
	} else {
		(*prev)->next = sel;
	}
	(*prev) = sel;
}

static struct Ast_Designator_s *Designator(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_Designator_s *des = NULL;
	struct Ast_RDeclaration *decl = NULL, *var_ = NULL;
	struct Ast_RSelector *prev = NULL, *sel = NULL;
	int nameBegin = O7C_INT_UNDEF, nameEnd = O7C_INT_UNDEF;

	Log_StrLn(11, (o7c_char *)"Designator");
	assert(o7c_cmp((*p).l, Scanner_Ident_cnst) ==  0);
	decl = Qualident(&(*p), p_tag, ds);
	CheckAst(&(*p), p_tag, Ast_DesignatorNew(&des, decl));
	if (decl != NULL) {
		if (o7c_is(decl, Ast_RVar_tag)) {
			prev = NULL;
			do {
				sel = NULL;
				if (o7c_cmp((*p).l, Scanner_Dot_cnst) ==  0) {
					Scan(&(*p), p_tag);
					ExpectIdent(&(*p), p_tag, &nameBegin, &nameEnd, Parser_ErrExpectIdent_cnst);
					if (o7c_cmp(nameBegin, 0) >=  0) {
						CheckAst(&(*p), p_tag, Ast_SelRecordNew(&sel, &des->_._.type, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, nameBegin, nameEnd));
					}
				} else if (o7c_cmp((*p).l, Scanner_Brace1Open_cnst) ==  0) {
					if (o7c_in(des->_._.type->_._.id, ((1 << Ast_IdRecord_cnst) | (1 << Ast_IdPointer_cnst)))) {
						Scan(&(*p), p_tag);
						var_ = ExpectRecordExtend(&(*p), p_tag, ds, O7C_GUARD(Ast_RConstruct, &des->_._.type));
						CheckAst(&(*p), p_tag, Ast_SelGuardNew(&sel, &des->_._.type, var_));
						Expect(&(*p), p_tag, Scanner_Brace1Close_cnst, Parser_ErrExpectBrace1Close_cnst);
					} else if (!(o7c_is(des->_._.type, Ast_RProcType_tag))) {
						AddError(&(*p), p_tag, Parser_ErrExpectVarRecordOrPointer_cnst);
					}
				} else if (o7c_cmp((*p).l, Scanner_Brace2Open_cnst) ==  0) {
					Scan(&(*p), p_tag);
					CheckAst(&(*p), p_tag, Ast_SelArrayNew(&sel, &des->_._.type, expression(&(*p), p_tag, ds)));
					while (ScanIfEqual(&(*p), p_tag, Scanner_Comma_cnst)) {
						Designator_SetSel(&prev, sel, des);
						CheckAst(&(*p), p_tag, Ast_SelArrayNew(&sel, &des->_._.type, expression(&(*p), p_tag, ds)));
					}
					Expect(&(*p), p_tag, Scanner_Brace2Close_cnst, Parser_ErrExpectBrace2Close_cnst);
				} else if (o7c_cmp((*p).l, Scanner_Dereference_cnst) ==  0) {
					CheckAst(&(*p), p_tag, Ast_SelPointerNew(&sel, &des->_._.type));
					Scan(&(*p), p_tag);
				}
				Designator_SetSel(&prev, sel, des);
			} while (!(sel == NULL));
		} else if (!((o7c_is(decl, Ast_Const_s_tag)) || (o7c_is(decl, Ast_RGeneralProcedure_tag)) || (o7c_cmp(decl->_.id, Ast_IdError_cnst) ==  0))) {
			AddError(&(*p), p_tag, Parser_ErrExpectDesignator_cnst);
		}
	}
	return des;
}

static void CallParams(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, struct Ast_ExprCall_s *e) {
	struct Ast_Parameter_s *par = NULL;
	struct Ast_FormalParam_s *fp = NULL;

	assert(o7c_cmp((*p).l, Scanner_Brace1Open_cnst) ==  0);
	Scan(&(*p), p_tag);
	if (o7c_is(e->designator->_._.type, Ast_RProcType_tag)) {
		fp = O7C_GUARD(Ast_RProcType, &e->designator->_._.type)->params;
	} else {
		fp = NULL;
	}
	if (!ScanIfEqual(&(*p), p_tag, Scanner_Brace1Close_cnst)) {
		par = NULL;
		(*p).varParam = (fp == NULL) || o7c_bl(fp->isVar) || (o7c_cmp(e->designator->decl->_.id, Scanner_Len_cnst) ==  0);
		CheckAst(&(*p), p_tag, Ast_CallParamNew(e, &par, expression(&(*p), p_tag, ds), &fp));
		(*p).varParam = false;
		e->params = par;
		while (ScanIfEqual(&(*p), p_tag, Scanner_Comma_cnst)) {
			(*p).varParam = (fp == NULL) || o7c_bl(fp->isVar);
			CheckAst(&(*p), p_tag, Ast_CallParamNew(e, &par, expression(&(*p), p_tag, ds), &fp));
			(*p).varParam = false;
		}
		Expect(&(*p), p_tag, Scanner_Brace1Close_cnst, Parser_ErrExpectBrace1Close_cnst);
	}
	CheckAst(&(*p), p_tag, Ast_CallParamsEnd(e, fp));
}

static struct Ast_ExprCall_s *ExprCall(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, struct Ast_Designator_s *des) {
	struct Ast_ExprCall_s *e = NULL;

	CheckAst(&(*p), p_tag, Ast_ExprCallNew(&e, des));
	CallParams(&(*p), p_tag, ds, e);
	return e;
}

static struct Ast_RExpression *Factor(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds);
static void Factor_Ident(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, struct Ast_RExpression **e) {
	struct Ast_Designator_s *des = NULL;

	des = Designator(&(*p), p_tag, ds);
	if (o7c_cmp((*p).l, Scanner_Brace1Open_cnst) !=  0) {
		if (o7c_bl((*p).varParam)) {
			(*p).varParam = false;
			if (o7c_is(des->decl, Ast_RVar_tag)) {
				O7C_GUARD(Ast_RVar, &des->decl)->inited = true;
			}
		} else if (o7c_cmp((*p).inConditions, 0) ==  0) {
			/* TODO */
			CheckAst(&(*p), p_tag, Ast_CheckDesignatorAsValue(des));
		} else {
		}
		(*e) = (&(des)->_._);
	} else {
		(*e) = (&(ExprCall(&(*p), p_tag, ds, des))->_._);
	}
}

static struct Ast_ExprNegate_s *Factor_Negate(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_ExprNegate_s *neg = NULL;

	assert(o7c_cmp((*p).l, Scanner_Negate_cnst) ==  0);
	Scan(&(*p), p_tag);
	CheckAst(&(*p), p_tag, Ast_ExprNegateNew(&neg, Factor(&(*p), p_tag, ds)));
	return neg;
}

static struct Ast_RExpression *Factor(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_RExpression *e = NULL;

	Log_StrLn(7, (o7c_char *)"Factor");
	if (o7c_cmp((*p).l, Scanner_Number_cnst) ==  0) {
		if (o7c_bl((*p).s.isReal)) {
			e = (&(Ast_ExprRealNew((*p).s.real, (*p).module, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, (*p).s.lexStart, (*p).s.lexEnd))->_._._);
		} else {
			e = (&(Ast_ExprIntegerNew((*p).s.integer))->_._._);
		}
		Scan(&(*p), p_tag);
	} else if ((o7c_cmp((*p).l, Scanner_True_cnst) ==  0) || (o7c_cmp((*p).l, Scanner_False_cnst) ==  0)) {
		e = (&(Ast_ExprBooleanGet(o7c_cmp((*p).l, Scanner_True_cnst) ==  0))->_._);
		Scan(&(*p), p_tag);
	} else if (o7c_cmp((*p).l, Scanner_Nil_cnst) ==  0) {
		e = (&(Ast_ExprNilNew())->_._);
		Scan(&(*p), p_tag);
	} else if (o7c_cmp((*p).l, Scanner_String_cnst) ==  0) {
		e = (&(Ast_ExprStringNew((*p).module, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, (*p).s.lexStart, (*p).s.lexEnd))->_._._._);
		if ((e != NULL) && o7c_bl((*p).s.isChar)) {
			O7C_GUARD(Ast_ExprString_s, &e)->_.int_ = (*p).s.integer;
		}
		Scan(&(*p), p_tag);
	} else if (o7c_cmp((*p).l, Scanner_Brace1Open_cnst) ==  0) {
		Scan(&(*p), p_tag);
		e = (&(Ast_ExprBracesNew(expression(&(*p), p_tag, ds)))->_._);
		Expect(&(*p), p_tag, Scanner_Brace1Close_cnst, Parser_ErrExpectBrace1Close_cnst);
	} else if (o7c_cmp((*p).l, Scanner_Ident_cnst) ==  0) {
		Factor_Ident(&(*p), p_tag, ds, &e);
	} else if (o7c_cmp((*p).l, Scanner_Brace3Open_cnst) ==  0) {
		e = (&(Set(&(*p), p_tag, ds))->_._);
	} else if (o7c_cmp((*p).l, Scanner_Negate_cnst) ==  0) {
		e = (&(Factor_Negate(&(*p), p_tag, ds))->_._);
	} else {
		AddError(&(*p), p_tag, Parser_ErrExpectExpression_cnst);
		e = Ast_ExprErrNew();
	}
	return e;
}

static struct Ast_RExpression *Term(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_RExpression *e = NULL;
	struct Ast_ExprTerm_s *term = NULL;
	int l = O7C_INT_UNDEF;
	o7c_bool inc = O7C_BOOL_UNDEF;

	Log_StrLn(5, (o7c_char *)"Term");
	e = Factor(&(*p), p_tag, ds);
	if ((o7c_cmp((*p).l, Scanner_MultFirst_cnst) >=  0) && (o7c_cmp((*p).l, Scanner_MultLast_cnst) <=  0)) {
		l = (*p).l;
		inc = (o7c_cmp(l, Scanner_And_cnst) ==  0) && (o7c_cmp((*p).inLoops, 0) >  0);
		if (o7c_bl(inc)) {
			(*p).inConditions = o7c_add((*p).inConditions, 1);
		}
		Scan(&(*p), p_tag);
		term = NULL;
		CheckAst(&(*p), p_tag, Ast_ExprTermNew(&term, O7C_GUARD(Ast_RFactor, &e), l, Factor(&(*p), p_tag, ds)));
		assert((term->expr != NULL) && (term->factor != NULL));
		e = (&(term)->_);
		while ((o7c_cmp((*p).l, Scanner_MultFirst_cnst) >=  0) && (o7c_cmp((*p).l, Scanner_MultLast_cnst) <=  0)) {
			l = (*p).l;
			Scan(&(*p), p_tag);
			CheckAst(&(*p), p_tag, Ast_ExprTermAdd(e, &term, l, Factor(&(*p), p_tag, ds)));
		}
		if (o7c_bl(inc)) {
			(*p).inConditions = o7c_sub((*p).inConditions, 1);
			assert(o7c_cmp((*p).inConditions, 0) >=  0);
		}
	}
	return e;
}

static struct Ast_RExpression *Sum(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_RExpression *e = NULL;
	struct Ast_ExprSum_s *sum = NULL;
	int l = O7C_INT_UNDEF;
	o7c_bool inc = O7C_BOOL_UNDEF;

	Log_StrLn(4, (o7c_char *)"Sum");
	l = (*p).l;
	inc = false;
	if (o7c_in(l, ((1 << Scanner_Plus_cnst) | (1 << Scanner_Minus_cnst)))) {
		Scan(&(*p), p_tag);
		CheckAst(&(*p), p_tag, Ast_ExprSumNew(&sum, l, Term(&(*p), p_tag, ds)));
		e = (&(sum)->_);
	} else {
		e = Term(&(*p), p_tag, ds);
		if (o7c_in((*p).l, ((1 << Scanner_Plus_cnst) | (1 << Scanner_Minus_cnst) | (1 << Scanner_Or_cnst)))) {
			if ((o7c_cmp((*p).l, Scanner_Or_cnst) ==  0) && (o7c_cmp((*p).inLoops, 0) >  0)) {
				(*p).inConditions = o7c_add((*p).inConditions, 1);
				inc = true;
			}
			CheckAst(&(*p), p_tag, Ast_ExprSumNew(&sum,  - 1, e));
			e = (&(sum)->_);
		}
	}
	while (o7c_in((*p).l, ((1 << Scanner_Plus_cnst) | (1 << Scanner_Minus_cnst) | (1 << Scanner_Or_cnst)))) {
		l = (*p).l;
		Scan(&(*p), p_tag);
		CheckAst(&(*p), p_tag, Ast_ExprSumAdd(e, &sum, l, Term(&(*p), p_tag, ds)));
	}
	if (o7c_bl(inc)) {
		(*p).inConditions = o7c_sub((*p).inConditions, 1);
		assert(o7c_cmp((*p).inConditions, 0) >=  0);
	}
	return e;
}

static struct Ast_RExpression *Expression(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_RExpression *expr = NULL;
	struct Ast_ExprRelation_s *e = NULL;
	struct Ast_ExprIsExtension_s *isExt = NULL;
	int rel = O7C_INT_UNDEF;

	expr = Sum(&(*p), p_tag, ds);
	if ((o7c_cmp((*p).l, Scanner_RelationFirst_cnst) >=  0) && (o7c_cmp((*p).l, Scanner_RelationLast_cnst) <  0)) {
		rel = (*p).l;
		Scan(&(*p), p_tag);
		CheckAst(&(*p), p_tag, Ast_ExprRelationNew(&e, expr, rel, Sum(&(*p), p_tag, ds)));
		expr = (&(e)->_);
	} else if (ScanIfEqual(&(*p), p_tag, Scanner_Is_cnst)) {
		CheckAst(&(*p), p_tag, Ast_ExprIsExtensionNew(&isExt, &expr, type(&(*p), p_tag, ds,  - 1,  - 1)));
		expr = (&(isExt)->_);
	}
	return expr;
}

static void DeclComment(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclaration *d) {
	int comOfs = O7C_INT_UNDEF, comEnd = O7C_INT_UNDEF;

	if (o7c_bl((*p).opt.saveComments) && Scanner_TakeCommentPos(&(*p).s, Scanner_Scanner_tag, &comOfs, &comEnd)) {
		Ast_DeclSetComment(d, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, comOfs, comEnd);
	}
}

static void Mark(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclaration *d) {
	DeclComment(&(*p), p_tag, d);
	d->mark = ScanIfEqual(&(*p), p_tag, Scanner_Asterisk_cnst);
}

static void Consts(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	int begin = O7C_INT_UNDEF, end = O7C_INT_UNDEF;
	struct Ast_Const_s *const_ = NULL;

	Scan(&(*p), p_tag);
	while (o7c_cmp((*p).l, Scanner_Ident_cnst) ==  0) {
		if (!(*p).err) {
			ExpectIdent(&(*p), p_tag, &begin, &end, Parser_ErrExpectConstName_cnst);
			CheckAst(&(*p), p_tag, Ast_ConstAdd(ds, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, begin, end));
			const_ = O7C_GUARD(Ast_Const_s, &ds->end);
			Mark(&(*p), p_tag, &const_->_);
			Expect(&(*p), p_tag, Scanner_Equal_cnst, Parser_ErrExpectEqual_cnst);
			CheckAst(&(*p), p_tag, Ast_ConstSetExpression(const_, Expression(&(*p), p_tag, ds)));
			Expect(&(*p), p_tag, Scanner_Semicolon_cnst, Parser_ErrExpectSemicolon_cnst);
		}
		if (o7c_bl((*p).err)) {
			while ((o7c_cmp(Scanner_EndOfFile_cnst, (*p).l) <  0) && (o7c_cmp((*p).l, Scanner_Import_cnst) <  0) && (o7c_cmp((*p).l, Scanner_Semicolon_cnst) !=  0)) {
				/* TODO */
				Scan(&(*p), p_tag);
			}
			(*p).err = false;
		}
	}
}

static struct Ast_RArray *Array(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, int nameBegin, int nameEnd) {
	struct Ast_RArray *a = NULL;
	struct Ast_RType *t = NULL;
	struct Ast_RExpression *exprLen = NULL;
	struct Ast_RExpression *lens[16];
	int i = O7C_INT_UNDEF, size = O7C_INT_UNDEF;
	memset(&lens, 0, sizeof(lens));

	Log_StrLn(6, (o7c_char *)"Array");
	assert(o7c_cmp((*p).l, Scanner_Array_cnst) ==  0);
	Scan(&(*p), p_tag);
	a = Ast_ArrayGet(NULL, Expression(&(*p), p_tag, ds));
	if (o7c_cmp(nameBegin, 0) >=  0) {
		t = (&(a)->_._);
		CheckAst(&(*p), p_tag, Ast_TypeAdd(ds, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, nameBegin, nameEnd, &t));
	}
	size = 1;
	CheckAst(&(*p), p_tag, Ast_MultArrayLenByExpr(&size, a->count));
	i = 0;
	while (ScanIfEqual(&(*p), p_tag, Scanner_Comma_cnst)) {
		exprLen = Expression(&(*p), p_tag, ds);
		CheckAst(&(*p), p_tag, Ast_MultArrayLenByExpr(&size, exprLen));
		if (o7c_cmp(i, O7C_LEN(lens)) <  0) {
			lens[o7c_ind(16, i)] = exprLen;
		}
		i = o7c_add(i, 1);
	}
	if (o7c_cmp(i, O7C_LEN(lens)) >  0) {
		AddError(&(*p), p_tag, Parser_ErrArrayDimensionsTooMany_cnst);
	}
	Expect(&(*p), p_tag, Scanner_Of_cnst, Parser_ErrExpectOf_cnst);
	a->_._._.type = type(&(*p), p_tag, ds,  - 1,  - 1);
	while (o7c_cmp(i, 0) >  0) {
		i = o7c_sub(i, 1);
		a->_._._.type = (&(Ast_ArrayGet(a->_._._.type, lens[o7c_ind(16, i)]))->_._);
	}
	return a;
}

static struct Ast_RType *TypeNamed(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_RDeclaration *d = NULL;
	struct Ast_RType *t = NULL;

	t = NULL;
	d = Qualident(&(*p), p_tag, ds);
	if (d != NULL) {
		if (o7c_is(d, Ast_RType_tag)) {
			t = O7C_GUARD(Ast_RType, &d);
		} else if (o7c_cmp(d->_.id, Ast_IdError_cnst) !=  0) {
			AddError(&(*p), p_tag, Parser_ErrExpectType_cnst);
		}
	}
	if (t == NULL) {
		t = Ast_TypeErrorNew();
	}
	return t;
}

static void VarDeclaration(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *dsAdd, struct Ast_RDeclarations *dsTypes);
static void VarDeclaration_Name(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	int begin = O7C_INT_UNDEF, end = O7C_INT_UNDEF;

	ExpectIdent(&(*p), p_tag, &begin, &end, Parser_ErrExpectIdent_cnst);
	CheckAst(&(*p), p_tag, Ast_VarAdd(ds, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, begin, end));
	DeclComment(&(*p), p_tag, ds->end);
	Mark(&(*p), p_tag, ds->end);
}

static void VarDeclaration(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *dsAdd, struct Ast_RDeclarations *dsTypes) {
	struct Ast_RDeclaration *var_ = NULL;
	struct Ast_RType *typ = NULL;

	VarDeclaration_Name(&(*p), p_tag, dsAdd);
	var_ = (&(O7C_GUARD(Ast_RVar, &dsAdd->end))->_);
	while (ScanIfEqual(&(*p), p_tag, Scanner_Comma_cnst)) {
		VarDeclaration_Name(&(*p), p_tag, dsAdd);
	}
	Expect(&(*p), p_tag, Scanner_Colon_cnst, Parser_ErrExpectColon_cnst);
	typ = type(&(*p), p_tag, dsTypes,  - 1,  - 1);
	while (var_ != NULL) {
		var_->type = typ;
		var_ = var_->next;
	}
	CheckAst(&(*p), p_tag, Ast_CheckUndefRecordForward(dsAdd));
}

static void Vars(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	while (o7c_cmp((*p).l, Scanner_Ident_cnst) ==  0) {
		VarDeclaration(&(*p), p_tag, ds, ds);
		Expect(&(*p), p_tag, Scanner_Semicolon_cnst, Parser_ErrExpectSemicolon_cnst);
	}
}

static struct Ast_Record_s *Record(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, int nameBegin, int nameEnd);
static void Record_RecVars(struct Parser *p, o7c_tag_t p_tag, struct Ast_Record_s *dsAdd, struct Ast_RDeclarations *dsTypes);
static void RecVars_Record_Declaration(struct Parser *p, o7c_tag_t p_tag, struct Ast_Record_s *dsAdd, struct Ast_RDeclarations *dsTypes);
static void Declaration_RecVars_Record_Name(struct Ast_RVar **v, struct Parser *p, o7c_tag_t p_tag, struct Ast_Record_s *ds) {
	int begin = O7C_INT_UNDEF, end = O7C_INT_UNDEF;

	ExpectIdent(&(*p), p_tag, &begin, &end, Parser_ErrExpectIdent_cnst);
	CheckAst(&(*p), p_tag, Ast_RecordVarAdd(&(*v), ds, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, begin, end));
	Mark(&(*p), p_tag, &(*v)->_);
}

static void RecVars_Record_Declaration(struct Parser *p, o7c_tag_t p_tag, struct Ast_Record_s *dsAdd, struct Ast_RDeclarations *dsTypes) {
	struct Ast_RVar *var_ = NULL;
	struct Ast_RDeclaration *d = NULL;
	struct Ast_RType *typ = NULL;

	Declaration_RecVars_Record_Name(&var_, &(*p), p_tag, dsAdd);
	d = (&(var_)->_);
	while (ScanIfEqual(&(*p), p_tag, Scanner_Comma_cnst)) {
		Declaration_RecVars_Record_Name(&var_, &(*p), p_tag, dsAdd);
	}
	Expect(&(*p), p_tag, Scanner_Colon_cnst, Parser_ErrExpectColon_cnst);
	typ = type(&(*p), p_tag, dsTypes,  - 1,  - 1);
	while (d != NULL) {
		d->type = typ;
		d = d->next;
	}
}

static void Record_RecVars(struct Parser *p, o7c_tag_t p_tag, struct Ast_Record_s *dsAdd, struct Ast_RDeclarations *dsTypes) {
	if (o7c_cmp((*p).l, Scanner_Ident_cnst) ==  0) {
		RecVars_Record_Declaration(&(*p), p_tag, dsAdd, dsTypes);
		while (ScanIfEqual(&(*p), p_tag, Scanner_Semicolon_cnst)) {
			if (o7c_cmp((*p).l, Scanner_End_cnst) !=  0) {
				RecVars_Record_Declaration(&(*p), p_tag, dsAdd, dsTypes);
			} else if (o7c_bl((*p).opt.strictSemicolon)) {
				AddError(&(*p), p_tag, Parser_ErrExcessSemicolon_cnst);
				(*p).err = false;
			}
		}
	}
}

static struct Ast_Record_s *Record(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, int nameBegin, int nameEnd) {
	struct Ast_Record_s *rec = NULL, *base = NULL;
	struct Ast_RType *t = NULL;
	struct Ast_RDeclaration *decl = NULL;

	assert(o7c_cmp((*p).l, Scanner_Record_cnst) ==  0);
	Scan(&(*p), p_tag);
	base = NULL;
	if (ScanIfEqual(&(*p), p_tag, Scanner_Brace1Open_cnst)) {
		decl = Qualident(&(*p), p_tag, ds);
		if ((decl != NULL) && (o7c_cmp(decl->_.id, Ast_IdRecord_cnst) ==  0)) {
			base = O7C_GUARD(Ast_Record_s, &decl);
		} else {
			AddError(&(*p), p_tag, Parser_ErrExpectRecord_cnst);
		}
		Expect(&(*p), p_tag, Scanner_Brace1Close_cnst, Parser_ErrExpectBrace1Close_cnst);
	}
	rec = Ast_RecordNew(ds, base);
	if (o7c_cmp(nameBegin, 0) >=  0) {
		t = (&(rec)->_._);
		CheckAst(&(*p), p_tag, Ast_TypeAdd(ds, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, nameBegin, nameEnd, &t));
		if (&rec->_._ != t) {
			rec = O7C_GUARD(Ast_Record_s, &t);
			Ast_RecordSetBase(rec, base);
		}
	} else {
		StringStore_Undef(&rec->_._._.name, StringStore_String_tag);
		rec->_._._.module = (*p).module;
	}
	Record_RecVars(&(*p), p_tag, rec, ds);
	Expect(&(*p), p_tag, Scanner_End_cnst, Parser_ErrExpectEnd_cnst);
	return rec;
}

static struct Ast_RPointer *Pointer(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, int nameBegin, int nameEnd) {
	struct Ast_RPointer *tp = NULL;
	struct Ast_RType *t = NULL;
	struct Ast_RDeclaration *decl = NULL;
	struct Ast_Record_s *typeDecl = NULL;

	assert(o7c_cmp((*p).l, Scanner_Pointer_cnst) ==  0);
	Scan(&(*p), p_tag);
	tp = Ast_PointerGet(NULL);
	if (o7c_cmp(nameBegin, 0) >=  0) {
		t = (&(tp)->_._);
		assert(t != NULL);
		CheckAst(&(*p), p_tag, Ast_TypeAdd(ds, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, nameBegin, nameEnd, &t));
	}
	Expect(&(*p), p_tag, Scanner_To_cnst, Parser_ErrExpectTo_cnst);
	if (o7c_cmp((*p).l, Scanner_Record_cnst) ==  0) {
		tp->_._._.type = (&(Record(&(*p), p_tag, ds,  - 1,  - 1))->_._);
		if (tp->_._._.type != NULL) {
			O7C_GUARD(Ast_Record_s, &tp->_._._.type)->pointer = tp;
		}
	} else if (o7c_cmp((*p).l, Scanner_Ident_cnst) ==  0) {
		decl = Ast_DeclarationSearch(ds, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, (*p).s.lexStart, (*p).s.lexEnd);
		if (decl == NULL) {
			/* опережающее объявление ссылка на запись */
			typeDecl = Ast_RecordForwardNew(ds, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, (*p).s.lexStart, (*p).s.lexEnd);
			assert(tp->_._._.next == &typeDecl->_._._);
			Ast_PointerSetRecord(tp, typeDecl);
			Scan(&(*p), p_tag);
		} else if (o7c_is(decl, Ast_Record_s_tag)) {
			Ast_PointerSetRecord(tp, O7C_GUARD(Ast_Record_s, &decl));
			Scan(&(*p), p_tag);
		} else {
			CheckAst(&(*p), p_tag, Ast_PointerSetType(tp, TypeNamed(&(*p), p_tag, ds)));
		}
	} else {
		AddError(&(*p), p_tag, Parser_ErrExpectRecord_cnst);
	}
	return tp;
}

static void FormalParameters(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, struct Ast_RProcType *proc);
static void FormalParameters_Section(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, struct Ast_RProcType *proc);
static void Section_FormalParameters_Name(struct Parser *p, o7c_tag_t p_tag, struct Ast_RProcType *proc) {
	if (o7c_cmp((*p).l, Scanner_Ident_cnst) !=  0) {
		AddError(&(*p), p_tag, Parser_ErrExpectIdent_cnst);
	} else {
		CheckAst(&(*p), p_tag, Ast_ParamAdd((*p).module, proc, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, (*p).s.lexStart, (*p).s.lexEnd));
		Scan(&(*p), p_tag);
	}
}

static struct Ast_RType *Section_FormalParameters_Type(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_RType *t = NULL;
	int arrs = O7C_INT_UNDEF;

	arrs = 0;
	while (ScanIfEqual(&(*p), p_tag, Scanner_Array_cnst)) {
		Expect(&(*p), p_tag, Scanner_Of_cnst, Parser_ErrExpectOf_cnst);
		arrs = o7c_add(arrs, 1);
	}
	t = TypeNamed(&(*p), p_tag, ds);
	while ((t != NULL) && (o7c_cmp(arrs, 0) >  0)) {
		t = (&(Ast_ArrayGet(t, NULL))->_._);
		arrs = o7c_sub(arrs, 1);
	}
	return t;
}

static void FormalParameters_Section(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, struct Ast_RProcType *proc) {
	o7c_bool isVar = O7C_BOOL_UNDEF;
	struct Ast_RDeclaration *param = NULL;
	struct Ast_RType *secType = NULL;

	isVar = ScanIfEqual(&(*p), p_tag, Scanner_Var_cnst);
	Section_FormalParameters_Name(&(*p), p_tag, proc);
	param = (&(proc->end)->_._);
	while (ScanIfEqual(&(*p), p_tag, Scanner_Comma_cnst)) {
		Section_FormalParameters_Name(&(*p), p_tag, proc);
	}
	Expect(&(*p), p_tag, Scanner_Colon_cnst, Parser_ErrExpectColon_cnst);
	secType = Section_FormalParameters_Type(&(*p), p_tag, ds);
	while (param != NULL) {
		O7C_GUARD(Ast_FormalParam_s, &param)->isVar = isVar;
		param->type = secType;
		param = param->next;
	}
}

static void FormalParameters(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, struct Ast_RProcType *proc) {
	o7c_bool braces = O7C_BOOL_UNDEF;

	braces = ScanIfEqual(&(*p), p_tag, Scanner_Brace1Open_cnst);
	if (o7c_bl(braces)) {
		if (!ScanIfEqual(&(*p), p_tag, Scanner_Brace1Close_cnst)) {
			FormalParameters_Section(&(*p), p_tag, ds, proc);
			while (ScanIfEqual(&(*p), p_tag, Scanner_Semicolon_cnst)) {
				FormalParameters_Section(&(*p), p_tag, ds, proc);
			}
			Expect(&(*p), p_tag, Scanner_Brace1Close_cnst, Parser_ErrExpectBrace1Close_cnst);
		}
	}
	if (ScanIfEqual(&(*p), p_tag, Scanner_Colon_cnst)) {
		if (!braces) {
			AddError(&(*p), p_tag, Parser_ErrFunctionWithoutBraces_cnst);
			(*p).err = false;
		}
		CheckAst(&(*p), p_tag, Ast_ProcTypeSetReturn(proc, TypeNamed(&(*p), p_tag, ds)));
	}
}

static struct Ast_RProcType *TypeProcedure(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, int nameBegin, int nameEnd) {
	struct Ast_RProcType *proc = NULL;
	struct Ast_RType *t = NULL;

	assert(o7c_cmp((*p).l, Scanner_Procedure_cnst) ==  0);
	Scan(&(*p), p_tag);
	proc = Ast_ProcTypeNew(true);
	if (o7c_cmp(nameBegin, 0) >=  0) {
		t = (&(proc)->_._);
		CheckAst(&(*p), p_tag, Ast_TypeAdd(ds, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, nameBegin, nameEnd, &t));
	}
	FormalParameters(&(*p), p_tag, ds, proc);
	return proc;
}

static struct Ast_RType *Type(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, int nameBegin, int nameEnd) {
	struct Ast_RType *t = NULL;

	if (o7c_cmp((*p).l, Scanner_Array_cnst) ==  0) {
		t = (&(Array(&(*p), p_tag, ds, nameBegin, nameEnd))->_._);
	} else if (o7c_cmp((*p).l, Scanner_Pointer_cnst) ==  0) {
		t = (&(Pointer(&(*p), p_tag, ds, nameBegin, nameEnd))->_._);
	} else if (o7c_cmp((*p).l, Scanner_Procedure_cnst) ==  0) {
		t = (&(TypeProcedure(&(*p), p_tag, ds, nameBegin, nameEnd))->_._);
	} else if (o7c_cmp((*p).l, Scanner_Record_cnst) ==  0) {
		t = (&(Record(&(*p), p_tag, ds, nameBegin, nameEnd))->_._);
	} else if (o7c_cmp((*p).l, Scanner_Ident_cnst) ==  0) {
		t = TypeNamed(&(*p), p_tag, ds);
	} else {
		t = Ast_TypeErrorNew();
		AddError(&(*p), p_tag, Parser_ErrExpectType_cnst);
	}
	return t;
}

static void Types(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_RType *typ = NULL;
	int begin = O7C_INT_UNDEF, end = O7C_INT_UNDEF;
	o7c_bool mark = O7C_BOOL_UNDEF;

	Scan(&(*p), p_tag);
	while (o7c_cmp((*p).l, Scanner_Ident_cnst) ==  0) {
		begin = (*p).s.lexStart;
		end = (*p).s.lexEnd;
		Scan(&(*p), p_tag);
		mark = ScanIfEqual(&(*p), p_tag, Scanner_Asterisk_cnst);
		Expect(&(*p), p_tag, Scanner_Equal_cnst, Parser_ErrExpectEqual_cnst);
		typ = Type(&(*p), p_tag, ds, begin, end);
		if (typ != NULL) {
			typ->_.mark = mark;
			if (!(o7c_is(typ, Ast_RConstruct_tag))) {
				AddError(&(*p), p_tag, Parser_ErrExpectStructuredType_cnst);
			}
		}
		Expect(&(*p), p_tag, Scanner_Semicolon_cnst, Parser_ErrExpectSemicolon_cnst);
	}
	CheckAst(&(*p), p_tag, Ast_CheckUndefRecordForward(ds));
}

static struct Ast_If_s *If(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds);
static struct Ast_If_s *If_Branch(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, o7c_bool first) {
	struct Ast_If_s *if_ = NULL;

	Scan(&(*p), p_tag);
	CheckAst(&(*p), p_tag, Ast_IfNew(&if_, Expression(&(*p), p_tag, ds), NULL));
	Expect(&(*p), p_tag, Scanner_Then_cnst, Parser_ErrExpectThen_cnst);
	if (o7c_bl(first) && (o7c_cmp((*p).inLoops, 0) >  0)) {
		(*p).inConditions = o7c_add((*p).inConditions, 1);
	}
	if_->_.stats = statements(&(*p), p_tag, ds);
	return if_;
}

static struct Ast_If_s *If(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_If_s *if_ = NULL, *else_ = NULL;
	struct Ast_RWhileIf *elsif = NULL;

	assert(o7c_cmp((*p).l, Scanner_If_cnst) ==  0);
	if_ = If_Branch(&(*p), p_tag, ds, true);
	elsif = (&(if_)->_);
	while (o7c_cmp((*p).l, Scanner_Elsif_cnst) ==  0) {
		elsif->elsif = (&(If_Branch(&(*p), p_tag, ds, false))->_);
		elsif = elsif->elsif;
	}
	if (ScanIfEqual(&(*p), p_tag, Scanner_Else_cnst)) {
		CheckAst(&(*p), p_tag, Ast_IfNew(&else_, NULL, statements(&(*p), p_tag, ds)));
		elsif->elsif = (&(else_)->_);
	}
	if (o7c_cmp((*p).inLoops, 0) >  0) {
		(*p).inConditions = o7c_sub((*p).inConditions, 1);
		assert(o7c_cmp((*p).inConditions, 0) >=  0);
	}
	Expect(&(*p), p_tag, Scanner_End_cnst, Parser_ErrExpectEnd_cnst);
	return if_;
}

static struct Ast_Case_s *Case(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds);
static void Case_Element(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, struct Ast_Case_s *case_);
static struct Ast_CaseLabel_s *Element_Case_LabelList(struct Parser *p, o7c_tag_t p_tag, struct Ast_Case_s *case_, struct Ast_RDeclarations *ds);
static struct Ast_CaseLabel_s *LabelList_Element_Case_LabelRange(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds);
static struct Ast_CaseLabel_s *LabelRange_LabelList_Element_Case_Label(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_CaseLabel_s *l = NULL;
	int i = O7C_INT_UNDEF;

	if ((o7c_cmp((*p).l, Scanner_Number_cnst) ==  0) && !(*p).s.isReal) {
		CheckAst(&(*p), p_tag, Ast_CaseLabelNew(&l, Ast_IdInteger_cnst, (*p).s.integer));
		Scan(&(*p), p_tag);
	} else if (o7c_cmp((*p).l, Scanner_String_cnst) ==  0) {
		if (o7c_bl((*p).s.isChar)) {
			i = (*p).s.integer;
		} else {
			AddError(&(*p), p_tag, Parser_ErrUnexpectStringInCaseLabel_cnst);
			i =  - 1;
		}
		CheckAst(&(*p), p_tag, Ast_CaseLabelNew(&l, Ast_IdChar_cnst, i));
		Scan(&(*p), p_tag);
	} else if (o7c_cmp((*p).l, Scanner_Ident_cnst) ==  0) {
		CheckAst(&(*p), p_tag, Ast_CaseLabelQualNew(&l, Qualident(&(*p), p_tag, ds)));
	} else {
		CheckAst(&(*p), p_tag, Ast_CaseLabelNew(&l, Ast_IdInteger_cnst, 0));
		AddError(&(*p), p_tag, Parser_ErrExpectIntOrStrOrQualident_cnst);
	}
	return l;
}

static struct Ast_CaseLabel_s *LabelList_Element_Case_LabelRange(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_CaseLabel_s *r = NULL;

	r = LabelRange_LabelList_Element_Case_Label(&(*p), p_tag, ds);
	if (o7c_cmp((*p).l, Scanner_Range_cnst) ==  0) {
		Scan(&(*p), p_tag);
		CheckAst(&(*p), p_tag, Ast_CaseRangeNew(r, LabelRange_LabelList_Element_Case_Label(&(*p), p_tag, ds)));
	}
	return r;
}

static struct Ast_CaseLabel_s *Element_Case_LabelList(struct Parser *p, o7c_tag_t p_tag, struct Ast_Case_s *case_, struct Ast_RDeclarations *ds) {
	struct Ast_CaseLabel_s *first = NULL, *last = NULL;

	first = LabelList_Element_Case_LabelRange(&(*p), p_tag, ds);
	/* проверка 1-го диапазона */
	CheckAst(&(*p), p_tag, Ast_CaseRangeListAdd(case_, NULL, first));
	while (o7c_cmp((*p).l, Scanner_Comma_cnst) ==  0) {
		Scan(&(*p), p_tag);
		last = LabelList_Element_Case_LabelRange(&(*p), p_tag, ds);
		CheckAst(&(*p), p_tag, Ast_CaseRangeListAdd(case_, first, last));
	}
	return first;
}

static void Case_Element(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, struct Ast_Case_s *case_) {
	struct Ast_CaseElement_s *elem = NULL;

	elem = Ast_CaseElementNew(Element_Case_LabelList(&(*p), p_tag, case_, ds));
	/*ASSERT(elem.labels # NIL); TODO */
	Expect(&(*p), p_tag, Scanner_Colon_cnst, Parser_ErrExpectColon_cnst);
	elem->stats = statements(&(*p), p_tag, ds);
	CheckAst(&(*p), p_tag, Ast_CaseElementAdd(case_, elem));
}

static struct Ast_Case_s *Case(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_Case_s *case_ = NULL;

	assert(o7c_cmp((*p).l, Scanner_Case_cnst) ==  0);
	Scan(&(*p), p_tag);
	CheckAst(&(*p), p_tag, Ast_CaseNew(&case_, Expression(&(*p), p_tag, ds)));
	Expect(&(*p), p_tag, Scanner_Of_cnst, Parser_ErrExpectOf_cnst);
	Case_Element(&(*p), p_tag, ds, case_);
	while (ScanIfEqual(&(*p), p_tag, Scanner_Alternative_cnst)) {
		Case_Element(&(*p), p_tag, ds, case_);
	}
	Expect(&(*p), p_tag, Scanner_End_cnst, Parser_ErrExpectEnd_cnst);
	return case_;
}

static struct Ast_Repeat_s *Repeat(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_Repeat_s *r = NULL;

	assert(o7c_cmp((*p).l, Scanner_Repeat_cnst) ==  0);
	(*p).inLoops = o7c_add((*p).inLoops, 1);
	Scan(&(*p), p_tag);
	CheckAst(&(*p), p_tag, Ast_RepeatNew(&r, statements(&(*p), p_tag, ds)));
	Expect(&(*p), p_tag, Scanner_Until_cnst, Parser_ErrExpectUntil_cnst);
	(*p).inLoops = o7c_sub((*p).inLoops, 1);
	CheckAst(&(*p), p_tag, Ast_RepeatSetUntil(r, Expression(&(*p), p_tag, ds)));
	return r;
}

static struct Ast_For_s *For(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_For_s *f = NULL;
	struct Ast_RVar *v = NULL;
	o7c_char errName[12];
	memset(&errName, 0, sizeof(errName));

	assert(o7c_cmp((*p).l, Scanner_For_cnst) ==  0);
	Scan(&(*p), p_tag);
	if (o7c_cmp((*p).l, Scanner_Ident_cnst) !=  0) {
		memcpy(errName, (o7c_char *)"FORITERATOR", sizeof("FORITERATOR"));
		AddError(&(*p), p_tag, o7c_add(Parser_ErrExpectIdent_cnst, o7c_mul(Ast_ForIteratorGet(&v, ds, 12, errName, 0, 10), 0)));
	} else {
		CheckAst(&(*p), p_tag, Ast_ForIteratorGet(&v, ds, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, (*p).s.lexStart, (*p).s.lexEnd));
	}
	Scan(&(*p), p_tag);
	Expect(&(*p), p_tag, Scanner_Assign_cnst, Parser_ErrExpectAssign_cnst);
	CheckAst(&(*p), p_tag, Ast_ForNew(&f, v, Expression(&(*p), p_tag, ds), NULL, 1, NULL));
	Expect(&(*p), p_tag, Scanner_To_cnst, Parser_ErrExpectTo_cnst);
	CheckAst(&(*p), p_tag, Ast_ForSetTo(f, Expression(&(*p), p_tag, ds)));
	if (o7c_cmp((*p).l, Scanner_By_cnst) !=  0) {
		CheckAst(&(*p), p_tag, Ast_ForSetBy(f, NULL));
	} else {
		Scan(&(*p), p_tag);
		CheckAst(&(*p), p_tag, Ast_ForSetBy(f, Expression(&(*p), p_tag, ds)));
	}
	(*p).inLoops = o7c_add((*p).inLoops, 1);
	Expect(&(*p), p_tag, Scanner_Do_cnst, Parser_ErrExpectDo_cnst);
	f->stats = statements(&(*p), p_tag, ds);
	Expect(&(*p), p_tag, Scanner_End_cnst, Parser_ErrExpectEnd_cnst);
	(*p).inLoops = o7c_sub((*p).inLoops, 1);
	return f;
}

static struct Ast_While_s *While(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_While_s *w = NULL, *br = NULL;
	struct Ast_RWhileIf *elsif = NULL;

	assert(o7c_cmp((*p).l, Scanner_While_cnst) ==  0);
	(*p).inLoops = o7c_add((*p).inLoops, 1);
	Scan(&(*p), p_tag);
	CheckAst(&(*p), p_tag, Ast_WhileNew(&w, Expression(&(*p), p_tag, ds), NULL));
	elsif = (&(w)->_);
	Expect(&(*p), p_tag, Scanner_Do_cnst, Parser_ErrExpectDo_cnst);
	w->_.stats = statements(&(*p), p_tag, ds);
	while (ScanIfEqual(&(*p), p_tag, Scanner_Elsif_cnst)) {
		CheckAst(&(*p), p_tag, Ast_WhileNew(&br, Expression(&(*p), p_tag, ds), NULL));
		elsif->elsif = (&(br)->_);
		elsif = (&(br)->_);
		Expect(&(*p), p_tag, Scanner_Do_cnst, Parser_ErrExpectDo_cnst);
		elsif->stats = statements(&(*p), p_tag, ds);
	}
	Expect(&(*p), p_tag, Scanner_End_cnst, Parser_ErrExpectEnd_cnst);
	(*p).inLoops = o7c_sub((*p).inLoops, 1);
	return w;
}

static struct Ast_Assign_s *Assign(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, struct Ast_Designator_s *des) {
	struct Ast_Assign_s *st = NULL;

	assert(o7c_cmp((*p).l, Scanner_Assign_cnst) ==  0);
	Scan(&(*p), p_tag);
	CheckAst(&(*p), p_tag, Ast_AssignNew(&st, des, Expression(&(*p), p_tag, ds)));
	return st;
}

static struct Ast_Call_s *Call(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds, struct Ast_Designator_s *des) {
	struct Ast_Call_s *st = NULL;

	CheckAst(&(*p), p_tag, Ast_CallNew(&st, des));
	if (o7c_cmp((*p).l, Scanner_Brace1Open_cnst) ==  0) {
		CallParams(&(*p), p_tag, ds, O7C_GUARD(Ast_ExprCall_s, &st->_.expr));
	} else if ((des != NULL) && (des->_._.type != NULL) && (o7c_is(des->_._.type, Ast_RProcType_tag))) {
		CheckAst(&(*p), p_tag, Ast_CallParamsEnd(O7C_GUARD(Ast_ExprCall_s, &st->_.expr), O7C_GUARD(Ast_RProcType, &des->_._.type)->params));
	}
	return st;
}

static o7c_bool NotEnd(int l) {
	return (o7c_cmp(l, Scanner_End_cnst) !=  0) && (o7c_cmp(l, Scanner_Return_cnst) !=  0) && (o7c_cmp(l, Scanner_Else_cnst) !=  0) && (o7c_cmp(l, Scanner_Elsif_cnst) !=  0) && (o7c_cmp(l, Scanner_Until_cnst) !=  0) && (o7c_cmp(l, Scanner_Alternative_cnst) !=  0) && (o7c_cmp(l, Scanner_EndOfFile_cnst) !=  0);
}

static struct Ast_RStatement *Statements(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds);
static struct Ast_RStatement *Statements_Statement(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_Designator_s *des = NULL;
	struct Ast_RStatement *st = NULL;
	int commentOfs = O7C_INT_UNDEF, commentEnd = O7C_INT_UNDEF;

	/* Log.StrLn("Statement"); */
	if (!(*p).opt.saveComments || !Scanner_TakeCommentPos(&(*p).s, Scanner_Scanner_tag, &commentOfs, &commentEnd)) {
		commentOfs =  - 1;
	}
	if (o7c_cmp((*p).l, Scanner_Ident_cnst) ==  0) {
		des = Designator(&(*p), p_tag, ds);
		if (o7c_cmp((*p).l, Scanner_Assign_cnst) ==  0) {
			st = (&(Assign(&(*p), p_tag, ds, des))->_);
		} else if (o7c_cmp((*p).l, Scanner_Equal_cnst) ==  0) {
			AddError(&(*p), p_tag, Parser_ErrMaybeAssignInsteadEqual_cnst);
		} else {
			st = (&(Call(&(*p), p_tag, ds, des))->_);
		}
	} else if (o7c_cmp((*p).l, Scanner_If_cnst) ==  0) {
		st = (&(If(&(*p), p_tag, ds))->_._);
	} else if (o7c_cmp((*p).l, Scanner_Case_cnst) ==  0) {
		st = (&(Case(&(*p), p_tag, ds))->_);
	} else if (o7c_cmp((*p).l, Scanner_Repeat_cnst) ==  0) {
		st = (&(Repeat(&(*p), p_tag, ds))->_);
	} else if (o7c_cmp((*p).l, Scanner_For_cnst) ==  0) {
		st = (&(For(&(*p), p_tag, ds))->_);
	} else if (o7c_cmp((*p).l, Scanner_While_cnst) ==  0) {
		st = (&(While(&(*p), p_tag, ds))->_._);
	} else {
		st = NULL;
	}
	if ((st != NULL) && (o7c_cmp(commentOfs, 0) >=  0)) {
		Ast_NodeSetComment(&(*st)._, Ast_RStatement_tag, (*p).module, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, commentOfs, commentEnd);
	}
	if (o7c_bl((*p).err)) {
		Log_StrLn(6, (o7c_char *)"Error");
		while ((o7c_cmp((*p).l, Scanner_Semicolon_cnst) !=  0) && NotEnd((*p).l)) {
			Scan(&(*p), p_tag);
		}
		(*p).err = false;
	}
	return st;
}

static struct Ast_RStatement *Statements(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_RStatement *stats = NULL, *last = NULL;

	stats = Statements_Statement(&(*p), p_tag, ds);
	last = stats;
	while (1) if (ScanIfEqual(&(*p), p_tag, Scanner_Semicolon_cnst)) {
		if (stats == NULL) {
			stats = Statements_Statement(&(*p), p_tag, ds);
			last = stats;
		} else {
			last->next = Statements_Statement(&(*p), p_tag, ds);
			if (last->next != NULL) {
				last = last->next;
			}
		}
	} else if (NotEnd((*p).l) && !(*p).module->script) {
		AddError(&(*p), p_tag, Parser_ErrExpectSemicolon_cnst);
		(*p).err = false;
		while ((o7c_cmp((*p).l, Scanner_Semicolon_cnst) !=  0) && NotEnd((*p).l)) {
			Scan(&(*p), p_tag);
		}
	} else break;
	return stats;
}

static void Return(struct Parser *p, o7c_tag_t p_tag, struct Ast_RProcedure *proc) {
	if (o7c_cmp((*p).l, Scanner_Return_cnst) ==  0) {
		Log_StrLn(7, (o7c_char *)"Return");
		Scan(&(*p), p_tag);
		CheckAst(&(*p), p_tag, Ast_ProcedureSetReturn(proc, Expression(&(*p), p_tag, &proc->_._)));
		if (o7c_cmp((*p).l, Scanner_Semicolon_cnst) ==  0) {
			if (o7c_bl((*p).opt.strictSemicolon)) {
				AddError(&(*p), p_tag, Parser_ErrExcessSemicolon_cnst);
				(*p).err = false;
			}
			Scan(&(*p), p_tag);
		}
	} else {
		CheckAst(&(*p), p_tag, Ast_ProcedureEnd(proc));
	}
}

static void ProcBody(struct Parser *p, o7c_tag_t p_tag, struct Ast_RProcedure *proc) {
	declarations(&(*p), p_tag, &proc->_._);
	if (ScanIfEqual(&(*p), p_tag, Scanner_Begin_cnst)) {
		proc->_._.stats = Statements(&(*p), p_tag, &proc->_._);
	}
	Return(&(*p), p_tag, proc);
	Expect(&(*p), p_tag, Scanner_End_cnst, Parser_ErrExpectEnd_cnst);
	if (o7c_cmp((*p).l, Scanner_Ident_cnst) ==  0) {
		if (!StringStore_IsEqualToChars(&proc->_._._.name, StringStore_String_tag, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, (*p).s.lexStart, (*p).s.lexEnd)) {
			AddError(&(*p), p_tag, Parser_ErrEndProcedureNameNotMatch_cnst);
		}
		Scan(&(*p), p_tag);
	} else {
		AddError(&(*p), p_tag, Parser_ErrExpectProcedureName_cnst);
	}
}

static o7c_bool TakeComment(struct Parser *p, o7c_tag_t p_tag) {
	return o7c_bl((*p).opt.saveComments) && Scanner_TakeCommentPos(&(*p).s, Scanner_Scanner_tag, &(*p).comment.ofs, &(*p).comment.end);
}

static void Procedure(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	struct Ast_RProcedure *proc = NULL;
	int nameStart = O7C_INT_UNDEF, nameEnd = O7C_INT_UNDEF;

	assert(o7c_cmp((*p).l, Scanner_Procedure_cnst) ==  0);
	Scan(&(*p), p_tag);
	ExpectIdent(&(*p), p_tag, &nameStart, &nameEnd, Parser_ErrExpectIdent_cnst);
	CheckAst(&(*p), p_tag, Ast_ProcedureAdd(ds, &proc, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, nameStart, nameEnd));
	Mark(&(*p), p_tag, &proc->_._._);
	FormalParameters(&(*p), p_tag, ds, proc->_.header);
	Expect(&(*p), p_tag, Scanner_Semicolon_cnst, Parser_ErrExpectSemicolon_cnst);
	ProcBody(&(*p), p_tag, proc);
}

static void Declarations(struct Parser *p, o7c_tag_t p_tag, struct Ast_RDeclarations *ds) {
	if (o7c_cmp((*p).l, Scanner_Const_cnst) ==  0) {
		Consts(&(*p), p_tag, ds);
	}
	if (o7c_cmp((*p).l, Scanner_Type_cnst) ==  0) {
		Types(&(*p), p_tag, ds);
	}
	if (o7c_cmp((*p).l, Scanner_Var_cnst) ==  0) {
		Scan(&(*p), p_tag);
		Vars(&(*p), p_tag, ds);
	}
	while (o7c_cmp((*p).l, Scanner_Procedure_cnst) ==  0) {
		Procedure(&(*p), p_tag, ds);
		Expect(&(*p), p_tag, Scanner_Semicolon_cnst, Parser_ErrExpectSemicolon_cnst);
	}
}

static void Imports(struct Parser *p, o7c_tag_t p_tag) {
	int nameOfs = O7C_INT_UNDEF, nameEnd = O7C_INT_UNDEF, realOfs = O7C_INT_UNDEF, realEnd = O7C_INT_UNDEF;

	Ast_ImportHandle((*p).module);
	do {
		Scan(&(*p), p_tag);
		ExpectIdent(&(*p), p_tag, &nameOfs, &nameEnd, Parser_ErrExpectModuleName_cnst);
		if (ScanIfEqual(&(*p), p_tag, Scanner_Assign_cnst)) {
			ExpectIdent(&(*p), p_tag, &realOfs, &realEnd, Parser_ErrExpectModuleName_cnst);
		} else {
			realOfs = nameOfs;
			realEnd = nameEnd;
		}
		if (!(*p).err && (o7c_cmp(realOfs, 0) >=  0)) {
			CheckAst(&(*p), p_tag, Ast_ImportAdd((*p).module, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, nameOfs, nameEnd, realOfs, realEnd));
		} else {
			(*p).err = false;
			while ((o7c_cmp((*p).l, Scanner_Import_cnst) <  0) && (o7c_cmp((*p).l, Scanner_Comma_cnst) !=  0) && (o7c_cmp((*p).l, Scanner_Semicolon_cnst) !=  0) && (o7c_cmp((*p).l, Scanner_EndOfFile_cnst) !=  0)) {
				Scan(&(*p), p_tag);
			}
		}
	} while (!(o7c_cmp((*p).l, Scanner_Comma_cnst) !=  0));
	Expect(&(*p), p_tag, Scanner_Semicolon_cnst, Parser_ErrExpectSemicolon_cnst);
	Ast_ImportEnd((*p).module);
}

static void Module(struct Parser *p, o7c_tag_t p_tag, struct Ast_RProvider *prov) {
	Log_StrLn(7, (o7c_char *)"Module");
	Scan(&(*p), p_tag);
	if (o7c_cmp((*p).l, Scanner_Module_cnst) !=  0) {
		(*p).module = Ast_ModuleNew(3, (o7c_char *)"  ", 0, 0, prov);
		AddError(&(*p), p_tag, Parser_ErrExpectModule_cnst);
	} else {
		Scan(&(*p), p_tag);
		if (o7c_cmp((*p).l, Scanner_Ident_cnst) !=  0) {
			(*p).module = Ast_ModuleNew(3, (o7c_char *)"  ", 0, 0, prov);
			AddError(&(*p), p_tag, Parser_ErrExpectIdent_cnst);
		} else {
			(*p).module = Ast_ModuleNew(Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, (*p).s.lexStart, (*p).s.lexEnd, prov);
			if (TakeComment(&(*p), p_tag)) {
				Ast_ModuleSetComment((*p).module, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, (*p).comment.ofs, (*p).comment.end);
			}
			Ast_RegModule(prov, (*p).module);
			Scan(&(*p), p_tag);
		}
		Expect(&(*p), p_tag, Scanner_Semicolon_cnst, Parser_ErrExpectSemicolon_cnst);
		if (o7c_cmp((*p).l, Scanner_Import_cnst) ==  0) {
			Imports(&(*p), p_tag);
		}
		Declarations(&(*p), p_tag, &(*p).module->_);
		if (ScanIfEqual(&(*p), p_tag, Scanner_Begin_cnst)) {
			(*p).module->_.stats = Statements(&(*p), p_tag, &(*p).module->_);
		}
		Expect(&(*p), p_tag, Scanner_End_cnst, Parser_ErrExpectEnd_cnst);
		if (o7c_cmp((*p).l, Scanner_Ident_cnst) ==  0) {
			if (!StringStore_IsEqualToChars(&(*p).module->_._.name, StringStore_String_tag, Scanner_BlockSize_cnst * 2 + 1, (*p).s.buf, (*p).s.lexStart, (*p).s.lexEnd)) {
				AddError(&(*p), p_tag, Parser_ErrEndModuleNameNotMatch_cnst);
			}
			Scan(&(*p), p_tag);
		} else {
			AddError(&(*p), p_tag, Parser_ErrExpectModuleName_cnst);
		}
		if (o7c_cmp((*p).l, Scanner_Dot_cnst) !=  0) {
			AddError(&(*p), p_tag, Parser_ErrExpectDot_cnst);
		}
		CheckAst(&(*p), p_tag, Ast_ModuleEnd((*p).module));
	}
}

static void Blank(int code) {
}

extern void Parser_DefaultOptions(struct Parser_Options *opt, o7c_tag_t opt_tag) {
	V_Init(&(*opt)._, opt_tag);
	(*opt).strictSemicolon = true;
	(*opt).strictReturn = true;
	(*opt).saveComments = true;
	(*opt).multiErrors = false;
	(*opt).printError = Blank;
}

static void ParserInit(struct Parser *p, o7c_tag_t p_tag, struct VDataStream_In *in_, int scr_len0, o7c_char scr[/*len0*/], struct Parser_Options *opt, o7c_tag_t opt_tag) {
	o7c_bool ret = O7C_BOOL_UNDEF;

	V_Init(&(*p)._, p_tag);
	(*p).opt = (*opt);
	(*p).err = false;
	(*p).errorsCount = 0;
	(*p).module = NULL;
	(*p).provider = NULL;
	(*p).varParam = false;
	(*p).inLoops = 0;
	(*p).inConditions = 0;
	if (in_ != NULL) {
		Scanner_Init(&(*p).s, Scanner_Scanner_tag, in_);
	} else {
		ret = Scanner_InitByString(&(*p).s, Scanner_Scanner_tag, scr_len0, scr);
		assert(o7c_bl(ret));
	}
}

extern struct Ast_RModule *Parser_Parse(struct VDataStream_In *in_, struct Ast_RProvider *prov, struct Parser_Options *opt, o7c_tag_t opt_tag) {
	struct Parser p;
	Parser_undef(&p);

	assert(in_ != NULL);
	ParserInit(&p, Parser_tag, in_, 1, (o7c_char *)"", &(*opt), opt_tag);
	Module(&p, Parser_tag, prov);
	return p.module;
}

extern struct Ast_RModule *Parser_Script(int in__len0, o7c_char in_[/*len0*/], struct Ast_RProvider *prov, struct Parser_Options *opt, o7c_tag_t opt_tag) {
	struct Parser p;
	Parser_undef(&p);

	ParserInit(&p, Parser_tag, NULL, in__len0, in_, &(*opt), opt_tag);
	p.module = Ast_ScriptNew(prov);
	Scan(&p, Parser_tag);
	p.module->_.stats = Statements(&p, Parser_tag, &p.module->_);
	assert(p.module->_.stats != NULL);
	return p.module;
}

extern void Parser_init(void) {
	static int initialized = 0;
	if (0 == initialized) {
		V_init();
		Log_init();
		Out_init();
		Utf8_init();
		Scanner_init();
		StringStore_init();
		Ast_init();
		VDataStream_init();

		o7c_tag_init(Parser_Options_tag, V_Base_tag);
		o7c_tag_init(Parser_tag, V_Base_tag);

		declarations = Declarations;
		type = Type;
		statements = Statements;
		expression = Expression;
	}
	++initialized;
}

