/* Generated by Vostok - Oberon-07 translator */

#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <assert.h>
#include <math.h>
#include <stdbool.h>

#define O7C_BOOL_UNDEFINED
#include <o7c.h>

#include "Scanner.h"

#define NewPage_cnst (o7c_char *)"\x0C"
#define IntMax_cnst 2147483647
#define CharMax_cnst (o7c_char *)"\xFF"
#define RealScaleMax_cnst 512

o7c_tag_t Scanner_Scanner_tag;
extern void Scanner_Scanner_undef(struct Scanner_Scanner *r) {
	V_Base_undef(&r->_);
	r->in_ = NULL;
	r->line = O7C_INT_UNDEF;
	r->column = O7C_INT_UNDEF;
	r->tabs = O7C_INT_UNDEF;
	memset(&r->buf, 0, sizeof(r->buf));
	r->ind = O7C_INT_UNDEF;
	r->lexStart = O7C_INT_UNDEF;
	r->lexEnd = O7C_INT_UNDEF;
	r->lexLen = O7C_INT_UNDEF;
	r->isReal = O7C_BOOL_UNDEF;
	r->isChar = O7C_BOOL_UNDEF;
	r->integer = O7C_INT_UNDEF;
	r->real = O7C_DBL_UNDEF;
	r->commentOfs = O7C_INT_UNDEF;
	r->commentEnd = O7C_INT_UNDEF;
}
typedef o7c_bool (*Suit)(o7c_char ch);
typedef int (*SuitDigit)(o7c_char ch);

static void PreInit(struct Scanner_Scanner *s, o7c_tag_t s_tag) {
	V_Init(&(*s)._, s_tag);
	(*s).column = 0;
	(*s).tabs = 0;
	(*s).line = 0;
	(*s).commentOfs =  - 1;
}

extern void Scanner_Init(struct Scanner_Scanner *s, o7c_tag_t s_tag, struct VDataStream_In *in_) {
	assert(in_ != NULL);
	PreInit(&(*s), s_tag);
	(*s).in_ = in_;
	(*s).ind = O7C_LEN((*s).buf) - 1;
	(*s).buf[0] = 0x0Cu;
	(*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] = 0x0Cu;
}

extern o7c_bool Scanner_InitByString(struct Scanner_Scanner *s, o7c_tag_t s_tag, int in__len0, o7c_char in_[/*len0*/]) {
	int len = O7C_INT_UNDEF;
	o7c_bool ret = O7C_BOOL_UNDEF;

	PreInit(&(*s), s_tag);
	(*s).in_ = NULL;
	(*s).ind = 0;
	(*s).buf[0] = (char unsigned)' ';
	len = 1;
	ret = StringStore_CopyCharsNull(Scanner_BlockSize_cnst * 2 + 1, (*s).buf, &len, in__len0, in_);
	(*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, len)] = 0x04u;
	return ret;
}

static void FillBuf(int buf_len0, o7c_char buf[/*len0*/], int *ind, struct VDataStream_In *in_, o7c_tag_t in__tag);
static void FillBuf_Normalize(int buf_len0, o7c_char buf[/*len0*/], int i, int end) {
	while (o7c_cmp(i, end) <  0) {
		if ((buf[o7c_ind(buf_len0, i)] == 0x0Cu) || (buf[o7c_ind(buf_len0, i)] == 0x04u)) {
			buf[o7c_ind(buf_len0, i)] = 0x16u;
		}
		i = o7c_add(i, 1);
	}
}

static void FillBuf(int buf_len0, o7c_char buf[/*len0*/], int *ind, struct VDataStream_In *in_, o7c_tag_t in__tag) {
	int size = O7C_INT_UNDEF;

	assert((buf_len0 % 2 == 1));
	if (o7c_cmp(o7c_mod((*ind), (o7c_div(buf_len0, 2))), 0) !=  0) {
		Log_StrLn(78, (o7c_char *)"индекс новой страницы в неожиданном месте");
		assert(buf[o7c_ind(buf_len0, (*ind))] == 0x0Cu);
		buf[o7c_ind(buf_len0, (*ind))] = 0x00u;
	} else {
		(*ind) = o7c_mod((*ind), (o7c_sub(buf_len0, 1)));
		if (buf[o7c_ind(buf_len0, (*ind))] == 0x0Cu) {
			size = VDataStream_ReadChars(&(*in_), in__tag, buf_len0, buf, (*ind), o7c_div(buf_len0, 2));
			FillBuf_Normalize(buf_len0, buf, (*ind), o7c_add((*ind), size));
			if (o7c_cmp(size, o7c_div(buf_len0, 2)) ==  0) {
				buf[o7c_ind(buf_len0, o7c_mod((o7c_add((*ind), o7c_div(buf_len0, 2))), (o7c_sub(buf_len0, 1))))] = 0x0Cu;
			} else {
				buf[o7c_ind(buf_len0, o7c_add((*ind), size))] = 0x04u;
			}
		}
	}
}

static o7c_char ScanChar(struct Scanner_Scanner *s, o7c_tag_t s_tag) {
	o7c_char ch = '\0';

	(*s).ind = o7c_add((*s).ind, 1);
	ch = (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)];
	if (ch == 0x0Cu) {
		FillBuf(Scanner_BlockSize_cnst * 2 + 1, (*s).buf, &(*s).ind, &(*(*s).in_), NULL);
		ch = (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)];
	}
	return ch;
}

static void ScanChars(int buf_len0, o7c_char buf[/*len0*/], int *i, Suit suit, struct VDataStream_In *in_, o7c_tag_t in__tag) {
	while (1) if (suit(buf[o7c_ind(buf_len0, (*i))])) {
		(*i) = o7c_add((*i), 1);
	} else if (buf[o7c_ind(buf_len0, (*i))] == 0x0Cu) {
		FillBuf(buf_len0, buf, &(*i), &(*in_), in__tag);
	} else break;
}

static o7c_bool IsDigit(o7c_char ch) {
	return (ch >= (char unsigned)'0') && (ch <= (char unsigned)'9');
}

static o7c_bool IsHexDigit(o7c_char ch) {
	return (ch >= (char unsigned)'0') && (ch <= (char unsigned)'9') || (ch >= (char unsigned)'A') && (ch <= (char unsigned)'F');
}

static int ValDigit(o7c_char ch) {
	int i = O7C_INT_UNDEF;

	if ((ch >= (char unsigned)'0') && (ch <= (char unsigned)'9')) {
		i = o7c_sub((int)ch, (int)(char unsigned)'0');
	} else {
		i =  - 1;
	}
	return i;
}

static int ValHexDigit(o7c_char ch) {
	int i = O7C_INT_UNDEF;

	if ((ch >= (char unsigned)'0') && (ch <= (char unsigned)'9')) {
		i = o7c_sub((int)ch, (int)(char unsigned)'0');
	} else if ((ch >= (char unsigned)'A') && (ch <= (char unsigned)'F')) {
		i = o7c_sub(o7c_add(10, (int)ch), (int)(char unsigned)'A');
	} else {
		i =  - 1;
	}
	return i;
}

static int SNumber(struct Scanner_Scanner *s, o7c_tag_t s_tag);
static void SNumber_Val(struct Scanner_Scanner *s, o7c_tag_t s_tag, int *lex, int capacity, SuitDigit valDigit) {
	int d = O7C_INT_UNDEF, val = O7C_INT_UNDEF, i = O7C_INT_UNDEF;

	val = 0;
	i = (*s).lexStart;
	d = valDigit((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)]);
	/*Log.Str("IntMax "); Log.Int(IntMax); Log.Ln;*/
	while (1) if (o7c_cmp(d, 0) >=  0) {
		if (o7c_cmp(o7c_div(IntMax_cnst, capacity), val) >=  0) {
			val = o7c_mul(val, capacity);
			if (o7c_cmp(o7c_sub(IntMax_cnst, d), val) >=  0) {
				val = o7c_add(val, d);
			} else {
				(*lex) = Scanner_ErrNumberTooBig_cnst;
			}
		} else {
			(*lex) = Scanner_ErrNumberTooBig_cnst;
		}
		i = o7c_add(i, 1);
		d = valDigit((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)]);
	} else if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == 0x0Cu) {
		i = 0;
		d = valDigit((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)]);
	} else break;
	(*s).integer = val;
}

static void SNumber_ValReal(struct Scanner_Scanner *s, o7c_tag_t s_tag, int *lex) {
	/* TODO */
	int i = O7C_INT_UNDEF, d = O7C_INT_UNDEF, scale = O7C_INT_UNDEF;
	o7c_bool scMinus = O7C_BOOL_UNDEF;
	double val = O7C_DBL_UNDEF, t = O7C_DBL_UNDEF;

	val = 1.0;
	i = (*s).lexStart;
	d = ValDigit((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)]);
	while (1) if (o7c_cmp(d, 0) >=  0) {
		val = o7c_fadd(o7c_fmul(val, 10.0), (double)d);
		i = o7c_add(i, 1);
		d = ValDigit((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)]);
	} else if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == 0x0Cu) {
		i = 0;
		d = ValDigit((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)]);
	} else break;
	/* skip dot */
	i = o7c_add(i, 1);
	t = 10.0;
	d = ValDigit((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)]);
	while (1) if (o7c_cmp(d, 0) >=  0) {
		val = o7c_fadd(val, o7c_fdiv((double)d, t));
		t = o7c_fmul(t, 10.0);
		i = o7c_add(i, 1);
		d = ValDigit((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)]);
	} else if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == 0x0Cu) {
		FillBuf(Scanner_BlockSize_cnst * 2 + 1, (*s).buf, &i, &(*(*s).in_), NULL);
		d = ValDigit((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)]);
	} else break;
	if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == (char unsigned)'E') {
		i = o7c_add(i, 1);
		if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == 0x0Cu) {
			FillBuf(Scanner_BlockSize_cnst * 2 + 1, (*s).buf, &i, &(*(*s).in_), NULL);
		}
		scMinus = (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == (char unsigned)'-';
		if (o7c_bl(scMinus) || ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == (char unsigned)'+')) {
			i = o7c_add(i, 1);
			if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == 0x0Cu) {
				FillBuf(Scanner_BlockSize_cnst * 2 + 1, (*s).buf, &i, &(*(*s).in_), NULL);
			}
		}
		d = ValDigit((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)]);
		if (o7c_cmp(d, 0) >=  0) {
			scale = 0;
			while (1) if (o7c_cmp(d, 0) >=  0) {
				if (o7c_cmp(scale, IntMax_cnst / 10) <  0) {
					scale = o7c_add(o7c_mul(scale, 10), d);
				}
				i = o7c_add(i, 1);
				d = ValDigit((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)]);
			} else if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == 0x0Cu) {
				FillBuf(Scanner_BlockSize_cnst * 2 + 1, (*s).buf, &i, &(*(*s).in_), NULL);
				d = ValDigit((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)]);
			} else break;
			if (o7c_cmp(scale, RealScaleMax_cnst) <=  0) {
				/* TODO */
				while (o7c_cmp(scale, 0) >  0) {
					if (o7c_bl(scMinus)) {
						val = o7c_fmul(val, 10.0);
					} else {
						val = o7c_fdiv(val, 10.0);
					}
					scale = o7c_sub(scale, 1);
				}
			} else {
				(*lex) = Scanner_ErrRealScaleTooBig_cnst;
			}
		} else {
			(*lex) = Scanner_ErrExpectDigitInScale_cnst;
		}
	}
	(*s).ind = i;
	(*s).real = val;
}

static int SNumber(struct Scanner_Scanner *s, o7c_tag_t s_tag) {
	int lex = O7C_INT_UNDEF;
	o7c_char ch = '\0';

	lex = Scanner_Number_cnst;
	ScanChars(Scanner_BlockSize_cnst * 2 + 1, (*s).buf, &(*s).ind, IsDigit, &(*(*s).in_), NULL);
	ch = (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)];
	(*s).isReal = ch == (char unsigned)'.';
	if (o7c_bl((*s).isReal)) {
		(*s).ind = o7c_add((*s).ind, 1);
		SNumber_ValReal(&(*s), s_tag, &lex);
	} else if ((ch >= (char unsigned)'A') && (ch <= (char unsigned)'F') || (ch == (char unsigned)'H') || (ch == (char unsigned)'X')) {
		ScanChars(Scanner_BlockSize_cnst * 2 + 1, (*s).buf, &(*s).ind, IsHexDigit, &(*(*s).in_), NULL);
		ch = (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)];
		SNumber_Val(&(*s), s_tag, &lex, 16, ValHexDigit);
		if (ch == (char unsigned)'X') {
			if (o7c_cmp((*s).integer, (int)0xFFu) <=  0) {
				lex = Scanner_String_cnst;
				(*s).isChar = true;
			} else {
				lex = Scanner_ErrNumberTooBig_cnst;
			}
		} else if (ch != (char unsigned)'H') {
			lex = Scanner_ErrExpectHOrX_cnst;
		}
		if ((ch == (char unsigned)'X') || (ch == (char unsigned)'H')) {
			(*s).ind = o7c_add((*s).ind, 1);
		}
	} else {
		SNumber_Val(&(*s), s_tag, &lex, 10, ValDigit);
	}
	Log_Str(14, (o7c_char *)"Number lex = ");
	Log_Int(lex);
	Log_Ln();
	return lex;
}

static o7c_bool IsWordEqual(int str_len0, o7c_char str[/*len0*/], int buf_len0, o7c_char buf[/*len0*/], int ind, int end) {
	int i = O7C_INT_UNDEF, j = O7C_INT_UNDEF;

	assert(o7c_cmp(str_len0, o7c_div(buf_len0, 2)) <=  0);
	j = 1;
	i = o7c_add(ind, 1);
	while (1) if (buf[o7c_ind(buf_len0, i)] == str[o7c_ind(str_len0, j)]) {
		i = o7c_add(i, 1);
		j = o7c_add(j, 1);
	} else if (buf[o7c_ind(buf_len0, i)] == 0x0Cu) {
		i = 0;
	} else break;
	return (buf[o7c_ind(buf_len0, i)] == 0x08u) && (str[o7c_ind(str_len0, j)] == 0x00u);
}

static o7c_bool CheckPredefined_Eq(int str_len0, o7c_char str[/*len0*/], int buf_len0, o7c_char buf[/*len0*/], int begin, int end) {
	return IsWordEqual(str_len0, str, buf_len0, buf, begin, end);
}

static int CheckPredefined_O(int str_len0, o7c_char str[/*len0*/], int buf_len0, o7c_char buf[/*len0*/], int begin, int end, int id) {
	if (!IsWordEqual(str_len0, str, buf_len0, buf, begin, end)) {
		id = Scanner_Ident_cnst;
	}
	return id;
}

static int CheckPredefined_T(int s1_len0, o7c_char s1[/*len0*/], int buf_len0, o7c_char buf[/*len0*/], int begin, int end, int id1, int s2_len0, o7c_char s2[/*len0*/], int id2) {
	if (IsWordEqual(s1_len0, s1, buf_len0, buf, begin, end)) {
		id2 = id1;
	} else if (!IsWordEqual(s2_len0, s2, buf_len0, buf, begin, end)) {
		id2 = Scanner_Ident_cnst;
	}
	return id2;
}

extern int Scanner_CheckPredefined(int buf_len0, o7c_char buf[/*len0*/], int begin, int end) {
	int id = O7C_INT_UNDEF;
	o7c_char save = '\0';

	save = buf[o7c_ind(buf_len0, end)];
	buf[o7c_ind(buf_len0, end)] = 0x08u;
	switch (buf[o7c_ind(buf_len0, begin)]) {
	case 65:
		if (CheckPredefined_Eq(4, (o7c_char *)"ABS", buf_len0, buf, begin, end)) {
			id = Scanner_Abs_cnst;
		} else {
			id = CheckPredefined_T(4, (o7c_char *)"ASR", buf_len0, buf, begin, end, Scanner_Asr_cnst, 7, (o7c_char *)"ASSERT", Scanner_Assert_cnst);
		}
		break;
	case 66:
		id = CheckPredefined_T(8, (o7c_char *)"BOOLEAN", buf_len0, buf, begin, end, Scanner_Boolean_cnst, 5, (o7c_char *)"BYTE", Scanner_Byte_cnst);
		break;
	case 67:
		id = CheckPredefined_T(5, (o7c_char *)"CHAR", buf_len0, buf, begin, end, Scanner_Char_cnst, 4, (o7c_char *)"CHR", Scanner_Chr_cnst);
		break;
	case 68:
		id = CheckPredefined_O(4, (o7c_char *)"DEC", buf_len0, buf, begin, end, Scanner_Dec_cnst);
		break;
	case 69:
		id = CheckPredefined_O(5, (o7c_char *)"EXCL", buf_len0, buf, begin, end, Scanner_Excl_cnst);
		break;
	case 70:
		id = CheckPredefined_T(6, (o7c_char *)"FLOOR", buf_len0, buf, begin, end, Scanner_Floor_cnst, 4, (o7c_char *)"FLT", Scanner_Flt_cnst);
		break;
	case 73:
		if (CheckPredefined_Eq(4, (o7c_char *)"INC", buf_len0, buf, begin, end)) {
			id = Scanner_Inc_cnst;
		} else {
			id = CheckPredefined_T(5, (o7c_char *)"INCL", buf_len0, buf, begin, end, Scanner_Incl_cnst, 8, (o7c_char *)"INTEGER", Scanner_Integer_cnst);
		}
		break;
	case 76:
		id = CheckPredefined_T(4, (o7c_char *)"LEN", buf_len0, buf, begin, end, Scanner_Len_cnst, 4, (o7c_char *)"LSL", Scanner_Lsl_cnst);
		break;
	case 78:
		id = CheckPredefined_O(4, (o7c_char *)"NEW", buf_len0, buf, begin, end, Scanner_New_cnst);
		break;
	case 79:
		id = CheckPredefined_T(4, (o7c_char *)"ODD", buf_len0, buf, begin, end, Scanner_Odd_cnst, 4, (o7c_char *)"ORD", Scanner_Ord_cnst);
		break;
	case 80:
		id = CheckPredefined_O(5, (o7c_char *)"PACK", buf_len0, buf, begin, end, Scanner_Pack_cnst);
		break;
	case 82:
		id = CheckPredefined_T(5, (o7c_char *)"REAL", buf_len0, buf, begin, end, Scanner_Real_cnst, 4, (o7c_char *)"ROR", Scanner_Ror_cnst);
		break;
	case 83:
		id = CheckPredefined_O(4, (o7c_char *)"SET", buf_len0, buf, begin, end, Scanner_Set_cnst);
		break;
	case 85:
		id = CheckPredefined_O(5, (o7c_char *)"UNPK", buf_len0, buf, begin, end, Scanner_Unpk_cnst);
		break;
	default:
		if ((buf[o7c_ind(buf_len0, begin)] == 71) || (buf[o7c_ind(buf_len0, begin)] == 72) || (buf[o7c_ind(buf_len0, begin)] == 74) || (buf[o7c_ind(buf_len0, begin)] == 75) || (buf[o7c_ind(buf_len0, begin)] == 77) || (buf[o7c_ind(buf_len0, begin)] == 81) || (buf[o7c_ind(buf_len0, begin)] == 84) || (86 <= buf[o7c_ind(buf_len0, begin)] && buf[o7c_ind(buf_len0, begin)] <= 90) || (97 <= buf[o7c_ind(buf_len0, begin)] && buf[o7c_ind(buf_len0, begin)] <= 122)) {
			id = Scanner_Ident_cnst;
		} else abort();
		break;
	}
	buf[o7c_ind(buf_len0, end)] = save;
	return id;
}

static int CheckWord(int buf_len0, o7c_char buf[/*len0*/], int ind, int end);
static o7c_bool CheckWord_Eq(int str_len0, o7c_char str[/*len0*/], int buf_len0, o7c_char buf[/*len0*/], int ind, int end) {
	return IsWordEqual(str_len0, str, buf_len0, buf, ind, end);
}

static void CheckWord_O(int *lex, int str_len0, o7c_char str[/*len0*/], int buf_len0, o7c_char buf[/*len0*/], int ind, int end, int l) {
	if (IsWordEqual(str_len0, str, buf_len0, buf, ind, end)) {
		(*lex) = l;
	} else {
		(*lex) = Scanner_Ident_cnst;
	}
}

static void CheckWord_T(int *lex, int s1_len0, o7c_char s1[/*len0*/], int l1, int s2_len0, o7c_char s2[/*len0*/], int l2, int buf_len0, o7c_char buf[/*len0*/], int ind, int end) {
	if (IsWordEqual(s1_len0, s1, buf_len0, buf, ind, end)) {
		(*lex) = l1;
	} else if (IsWordEqual(s2_len0, s2, buf_len0, buf, ind, end)) {
		(*lex) = l2;
	} else {
		(*lex) = Scanner_Ident_cnst;
	}
}

static int CheckWord(int buf_len0, o7c_char buf[/*len0*/], int ind, int end) {
	int lex = O7C_INT_UNDEF;
	o7c_char save = '\0';

	save = buf[o7c_ind(buf_len0, end)];
	buf[o7c_ind(buf_len0, end)] = 0x08u;
	/*
	Log.Str("lexStart "); Log.Int(ind); Log.Str(" ");
	Log.Int(ORD(buf[ind])); Log.Ln;
	*/
	switch (buf[o7c_ind(buf_len0, ind)]) {
	case 65:
		CheckWord_O(&lex, 6, (o7c_char *)"ARRAY", buf_len0, buf, ind, end, Scanner_Array_cnst);
		break;
	case 66:
		CheckWord_T(&lex, 6, (o7c_char *)"BEGIN", Scanner_Begin_cnst, 3, (o7c_char *)"BY", Scanner_By_cnst, buf_len0, buf, ind, end);
		break;
	case 67:
		CheckWord_T(&lex, 5, (o7c_char *)"CASE", Scanner_Case_cnst, 6, (o7c_char *)"CONST", Scanner_Const_cnst, buf_len0, buf, ind, end);
		break;
	case 68:
		CheckWord_T(&lex, 4, (o7c_char *)"DIV", Scanner_Div_cnst, 3, (o7c_char *)"DO", Scanner_Do_cnst, buf_len0, buf, ind, end);
		break;
	case 69:
		if (CheckWord_Eq(5, (o7c_char *)"ELSE", buf_len0, buf, ind, end)) {
			lex = Scanner_Else_cnst;
		} else {
			CheckWord_T(&lex, 6, (o7c_char *)"ELSIF", Scanner_Elsif_cnst, 4, (o7c_char *)"END", Scanner_End_cnst, buf_len0, buf, ind, end);
		}
		break;
	case 70:
		CheckWord_T(&lex, 6, (o7c_char *)"FALSE", Scanner_False_cnst, 4, (o7c_char *)"FOR", Scanner_For_cnst, buf_len0, buf, ind, end);
		break;
	case 73:
		if (CheckWord_Eq(3, (o7c_char *)"IF", buf_len0, buf, ind, end)) {
			lex = Scanner_If_cnst;
		} else if (CheckWord_Eq(7, (o7c_char *)"IMPORT", buf_len0, buf, ind, end)) {
			lex = Scanner_Import_cnst;
		} else {
			CheckWord_T(&lex, 3, (o7c_char *)"IN", Scanner_In_cnst, 3, (o7c_char *)"IS", Scanner_Is_cnst, buf_len0, buf, ind, end);
		}
		break;
	case 77:
		CheckWord_T(&lex, 4, (o7c_char *)"MOD", Scanner_Mod_cnst, 7, (o7c_char *)"MODULE", Scanner_Module_cnst, buf_len0, buf, ind, end);
		break;
	case 78:
		CheckWord_O(&lex, 4, (o7c_char *)"NIL", buf_len0, buf, ind, end, Scanner_Nil_cnst);
		break;
	case 79:
		CheckWord_T(&lex, 3, (o7c_char *)"OF", Scanner_Of_cnst, 3, (o7c_char *)"OR", Scanner_Or_cnst, buf_len0, buf, ind, end);
		break;
	case 80:
		CheckWord_T(&lex, 8, (o7c_char *)"POINTER", Scanner_Pointer_cnst, 10, (o7c_char *)"PROCEDURE", Scanner_Procedure_cnst, buf_len0, buf, ind, end);
		break;
	case 82:
		if (CheckWord_Eq(7, (o7c_char *)"RECORD", buf_len0, buf, ind, end)) {
			lex = Scanner_Record_cnst;
		} else {
			CheckWord_T(&lex, 7, (o7c_char *)"REPEAT", Scanner_Repeat_cnst, 7, (o7c_char *)"RETURN", Scanner_Return_cnst, buf_len0, buf, ind, end);
		}
		break;
	case 84:
		if (CheckWord_Eq(5, (o7c_char *)"THEN", buf_len0, buf, ind, end)) {
			lex = Scanner_Then_cnst;
		} else if (CheckWord_Eq(3, (o7c_char *)"TO", buf_len0, buf, ind, end)) {
			lex = Scanner_To_cnst;
		} else {
			CheckWord_T(&lex, 5, (o7c_char *)"TRUE", Scanner_True_cnst, 5, (o7c_char *)"TYPE", Scanner_Type_cnst, buf_len0, buf, ind, end);
		}
		break;
	case 85:
		CheckWord_O(&lex, 6, (o7c_char *)"UNTIL", buf_len0, buf, ind, end, Scanner_Until_cnst);
		break;
	case 86:
		CheckWord_O(&lex, 4, (o7c_char *)"VAR", buf_len0, buf, ind, end, Scanner_Var_cnst);
		break;
	case 87:
		CheckWord_O(&lex, 6, (o7c_char *)"WHILE", buf_len0, buf, ind, end, Scanner_While_cnst);
		break;
	default:
		if ((0 <= buf[o7c_ind(buf_len0, ind)] && buf[o7c_ind(buf_len0, ind)] <= 64) || (buf[o7c_ind(buf_len0, ind)] == 71) || (buf[o7c_ind(buf_len0, ind)] == 72) || (74 <= buf[o7c_ind(buf_len0, ind)] && buf[o7c_ind(buf_len0, ind)] <= 76) || (buf[o7c_ind(buf_len0, ind)] == 81) || (buf[o7c_ind(buf_len0, ind)] == 83) || (88 <= buf[o7c_ind(buf_len0, ind)] && buf[o7c_ind(buf_len0, ind)] <= 255)) {
			lex = Scanner_Ident_cnst;
		} else abort();
		break;
	}
	buf[o7c_ind(buf_len0, end)] = save;
	return lex;
}

static o7c_bool IsLetterOrDigit(o7c_char ch) {
	return (ch >= (char unsigned)'A') && (ch <= (char unsigned)'Z') || (ch >= (char unsigned)'a') && (ch <= (char unsigned)'z') || (ch >= (char unsigned)'0') && (ch <= (char unsigned)'9');
}

static int SWord(struct Scanner_Scanner *s, o7c_tag_t s_tag) {
	int len = O7C_INT_UNDEF, l = O7C_INT_UNDEF;

	ScanChars(Scanner_BlockSize_cnst * 2 + 1, (*s).buf, &(*s).ind, IsLetterOrDigit, &(*(*s).in_), NULL);
	len = o7c_add(o7c_sub((*s).ind, (*s).lexStart), o7c_mul((int)(o7c_cmp((*s).ind, (*s).lexStart) <  0), (O7C_LEN((*s).buf) - 1)));
	assert(o7c_cmp(len, 0) >  0);
	if (o7c_cmp(len, TranslatorLimits_MaxLenName_cnst) <=  0) {
		l = CheckWord(Scanner_BlockSize_cnst * 2 + 1, (*s).buf, (*s).lexStart, (*s).ind);
	} else {
		l = Scanner_ErrWordLenTooBig_cnst;
	}
	return l;
}

/*	TODO поправить обработку комментариев - иногда ложно воспринимаются как
	комментарии строки с '(' и '*' */
static o7c_bool ScanBlank(struct Scanner_Scanner *s, o7c_tag_t s_tag) {
	int start = O7C_INT_UNDEF, i = O7C_INT_UNDEF, comment = O7C_INT_UNDEF, commentsCount = O7C_INT_UNDEF;

	i = (*s).ind;
	/*Log.Str("ScanBlank ind = "); Log.Int(i); Log.Ln;*/
	assert(o7c_cmp(i, 0) >=  0);
	start = i;
	comment = 0;
	commentsCount = 0;
	while (1) if (((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == (char unsigned)' ') || ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == 0x0Du)) {
		i = o7c_add(i, 1);
	} else if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == 0x09u) {
		i = o7c_add(i, 1);
		(*s).tabs = o7c_add((*s).tabs, 1);
	} else if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == 0x0Au) {
		(*s).line = o7c_add((*s).line, 1);
		(*s).column = 0;
		(*s).tabs = 0;
		i = o7c_add(i, 1);
		start = i;
	} else if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == 0x0Cu) {
		FillBuf(Scanner_BlockSize_cnst * 2 + 1, (*s).buf, &i, &(*(*s).in_), NULL);
		start = o7c_sub(start, o7c_mul((int)(o7c_cmp(i, 0) ==  0), (O7C_LEN((*s).buf) - 1)));
	} else if (((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == (char unsigned)'(') && (o7c_cmp(comment, 0) >=  0)) {
		(*s).ind = i;
		if (ScanChar(&(*s), s_tag) == (char unsigned)'*') {
			(*s).ind = o7c_add((*s).ind, 1);
			comment = o7c_add(comment, 1);
			commentsCount = o7c_add(commentsCount, 1);
			if (o7c_cmp(commentsCount, 1) ==  0) {
				if (o7c_cmp((*s).ind, O7C_LEN((*s).buf) - 1) ==  0) {
					(*s).commentOfs = 0;
				} else {
					(*s).commentOfs = (*s).ind;
				}
			}
		} else if (o7c_cmp(comment, 0) ==  0) {
			(*s).ind = i;
			comment =  - 1;
		}
		i = (*s).ind;
	} else if ((o7c_cmp(comment, 0) >  0) && ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] != 0x00u)) {
		/* & ~blank */
		if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == (char unsigned)'*') {
			(*s).ind = i;
			if (ScanChar(&(*s), s_tag) == (char unsigned)')') {
				comment = o7c_sub(comment, 1);
				if (o7c_cmp(comment, 0) ==  0) {
					(*s).commentEnd = i;
				}
				i = (*s).ind;
			}
		}
		i = o7c_add(i, 1);
	} else break;
	(*s).column = o7c_add((*s).column, (o7c_sub(i, start)));
	assert(o7c_cmp((*s).column, 0) >=  0);
	(*s).ind = i;
	return o7c_cmp(comment, 0) <=  0;
}

static int ScanString(struct Scanner_Scanner *s, o7c_tag_t s_tag) {
	int l = O7C_INT_UNDEF, i = O7C_INT_UNDEF, j = O7C_INT_UNDEF, count = O7C_INT_UNDEF;

	i = o7c_add((*s).ind, 1);
	if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == 0x0Cu) {
		FillBuf(Scanner_BlockSize_cnst * 2 + 1, (*s).buf, &i, &(*(*s).in_), NULL);
	}
	j = i;
	count = 0;
	while (1) if (((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] != (char unsigned)'"') && (((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] >= (char unsigned)' ') || ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == 0x09u))) {
		i = o7c_add(i, 1);
		count = o7c_add(count, 1);
	} else if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == 0x0Cu) {
		FillBuf(Scanner_BlockSize_cnst * 2 + 1, (*s).buf, &i, &(*(*s).in_), NULL);
	} else break;
	(*s).isChar = false;
	if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, i)] == (char unsigned)'"') {
		l = Scanner_String_cnst;
		if (o7c_cmp(count, 1) ==  0) {
			(*s).isChar = true;
			(*s).integer = (int)(*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, j)];
		}
		i = o7c_mod((o7c_add(i, 1)), (O7C_LEN((*s).buf) - 1));
	} else {
		l = Scanner_ErrExpectDQuote_cnst;
	}
	(*s).ind = i;
	return l;
}

static void Next_L(int *lex, struct Scanner_Scanner *s, o7c_tag_t s_tag, int l) {
	(*s).ind = o7c_add((*s).ind, 1);
	(*lex) = l;
}

static void Next_Li(int *lex, struct Scanner_Scanner *s, o7c_tag_t s_tag, o7c_char ch, int then, int else_) {
	(*s).ind = o7c_add((*s).ind, 1);
	if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] == 0x0Cu) {
		FillBuf(Scanner_BlockSize_cnst * 2 + 1, (*s).buf, &(*s).ind, &(*(*s).in_), NULL);
	}
	if ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] == ch) {
		(*lex) = then;
		(*s).ind = o7c_add((*s).ind, 1);
	} else {
		(*lex) = else_;
	}
}

extern int Scanner_Next(struct Scanner_Scanner *s, o7c_tag_t s_tag) {
	int lex = O7C_INT_UNDEF;

	if (!ScanBlank(&(*s), s_tag)) {
		lex = Scanner_ErrUnclosedComment_cnst;
	} else {
		(*s).lexStart = (*s).ind;
		switch ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)]) {
		case 4:
			lex = Scanner_EndOfFile_cnst;
			break;
		case 43:
			Next_L(&lex, &(*s), s_tag, Scanner_Plus_cnst);
			break;
		case 45:
			Next_L(&lex, &(*s), s_tag, Scanner_Minus_cnst);
			break;
		case 42:
			Next_L(&lex, &(*s), s_tag, Scanner_Asterisk_cnst);
			break;
		case 47:
			Next_L(&lex, &(*s), s_tag, Scanner_Slash_cnst);
			break;
		case 46:
			Next_Li(&lex, &(*s), s_tag, (char unsigned)'.', Scanner_Range_cnst, Scanner_Dot_cnst);
			break;
		case 44:
			Next_L(&lex, &(*s), s_tag, Scanner_Comma_cnst);
			break;
		case 58:
			Next_Li(&lex, &(*s), s_tag, (char unsigned)'=', Scanner_Assign_cnst, Scanner_Colon_cnst);
			break;
		case 59:
			Next_L(&lex, &(*s), s_tag, Scanner_Semicolon_cnst);
			break;
		case 94:
			Next_L(&lex, &(*s), s_tag, Scanner_Dereference_cnst);
			break;
		case 61:
			Next_L(&lex, &(*s), s_tag, Scanner_Equal_cnst);
			break;
		case 35:
			Next_L(&lex, &(*s), s_tag, Scanner_Inequal_cnst);
			break;
		case 126:
			Next_L(&lex, &(*s), s_tag, Scanner_Negate_cnst);
			break;
		case 60:
			Next_Li(&lex, &(*s), s_tag, (char unsigned)'=', Scanner_LessEqual_cnst, Scanner_Less_cnst);
			break;
		case 62:
			Next_Li(&lex, &(*s), s_tag, (char unsigned)'=', Scanner_GreaterEqual_cnst, Scanner_Greater_cnst);
			break;
		case 38:
			Next_L(&lex, &(*s), s_tag, Scanner_And_cnst);
			break;
		case 124:
			Next_L(&lex, &(*s), s_tag, Scanner_Alternative_cnst);
			break;
		case 40:
			Next_L(&lex, &(*s), s_tag, Scanner_Brace1Open_cnst);
			break;
		case 41:
			Next_L(&lex, &(*s), s_tag, Scanner_Brace1Close_cnst);
			break;
		case 91:
			Next_L(&lex, &(*s), s_tag, Scanner_Brace2Open_cnst);
			break;
		case 93:
			Next_L(&lex, &(*s), s_tag, Scanner_Brace2Close_cnst);
			break;
		case 123:
			Next_L(&lex, &(*s), s_tag, Scanner_Brace3Open_cnst);
			break;
		case 125:
			Next_L(&lex, &(*s), s_tag, Scanner_Brace3Close_cnst);
			break;
		case 34:
			lex = ScanString(&(*s), s_tag);
			break;
		default:
			if ((0 <= (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] && (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] <= 3) || (5 <= (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] && (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] <= 33) || ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] == 36) || ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] == 37) || ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] == 39) || ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] == 63) || ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] == 64) || ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] == 92) || ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] == 95) || ((*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] == 96) || (127 <= (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] && (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] <= 255)) {
				lex = Scanner_ErrUnexpectChar_cnst;
				(*s).ind = o7c_add((*s).ind, 1);
			} else if ((48 <= (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] && (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] <= 57)) {
				lex = SNumber(&(*s), s_tag);
			} else if ((97 <= (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] && (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] <= 122) || (65 <= (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] && (*s).buf[o7c_ind(Scanner_BlockSize_cnst * 2 + 1, (*s).ind)] <= 90)) {
				lex = SWord(&(*s), s_tag);
			} else abort();
			break;
		}
		/*
		Log.Str("Scan "); Log.Int(lex); Log.Ln;
		*/
		(*s).lexEnd = (*s).ind;
		(*s).lexLen = o7c_sub(o7c_add((*s).lexEnd, o7c_mul((int)(o7c_cmp((*s).lexEnd, (*s).lexStart) <  0), (O7C_LEN((*s).buf) - 1))), (*s).lexStart);
		assert((o7c_cmp((*s).lexLen, 0) >  0) || (o7c_cmp(lex, Scanner_EndOfFile_cnst) ==  0));
		(*s).column = o7c_add((*s).column, (*s).lexLen);
		assert(o7c_cmp((*s).column, 0) >=  0);
	}
	return lex;
}

extern o7c_bool Scanner_TakeCommentPos(struct Scanner_Scanner *s, o7c_tag_t s_tag, int *ofs, int *end) {
	o7c_bool ret = O7C_BOOL_UNDEF;

	ret = o7c_cmp((*s).commentOfs, 0) >=  0;
	if (o7c_bl(ret)) {
		(*ofs) = (*s).commentOfs;
		(*end) = (*s).commentEnd;
		(*s).commentOfs =  - 1;
	}
	return ret;
}

extern void Scanner_ResetComment(struct Scanner_Scanner *s, o7c_tag_t s_tag) {
	(*s).commentOfs =  - 1;
}

extern void Scanner_init(void) {
	static int initialized = 0;
	if (0 == initialized) {
		V_init();
		VDataStream_init();
		Utf8_init();
		TranslatorLimits_init();
		StringStore_init();
		Log_init();

		o7c_tag_init(Scanner_Scanner_tag, V_Base_tag);

		assert(TranslatorLimits_MaxLenName_cnst < Scanner_BlockSize_cnst);
	}
	++initialized;
}

