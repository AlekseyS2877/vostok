/* Generated by Vostok - Oberon-07 translator */

/*  Command line interface for Oberon-07 translator
 *  Copyright (C) 2016-2018 ComdivByZero
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <stdbool.h>

#define O7_BOOL_UNDEFINED
#include <o7.h>

#include "Log.h"
#include "Out.h"
#include "CLI.h"
#include "VDataStream.h"
#include "VFileStream.h"
#include "Utf8.h"
#include "StringStore.h"
#include "Parser.h"
#include "Scanner.h"
#include "Ast.h"
#include "GeneratorC.h"
#include "TranslatorLimits.h"
#include "PlatformExec.h"
#include "Message.h"
#include "CliParser.h"
#include "Platform.h"
#include "CFiles.h"
#include "OsEnv.h"

#define ErrNo_cnst 0
#define ErrParse_cnst ( - 1)

typedef struct Container_s {
	struct Container_s *next;
	struct Ast_RModule *m;
} *Container;
#define Container_s_tag o7_base_tag

static void Container_s_undef(struct Container_s *r) {
	r->next = NULL;
	r->m = NULL;
}

typedef struct ModuleProvider_s {
	Ast_RProvider _;
	struct Parser_Options opt;
	o7_char fileExt[32];
	int extLen;
	o7_char path[4096];
	unsigned sing;
	struct Translator_anon_0000 {
		struct Container_s *first;
		struct Container_s *last;
	} modules;

	o7_char expectName[TranslatorLimits_LenName_cnst + 1];
	int nameLen;
	o7_bool nameOk;
	o7_bool firstNotOk;
} *ModuleProvider;
static o7_tag_t ModuleProvider_s_tag;

static void ModuleProvider_s_undef(struct ModuleProvider_s *r) {
	Ast_RProvider_undef(&r->_);
	Parser_Options_undef(&r->opt);
	memset(&r->fileExt, 0, sizeof(r->fileExt));
	r->extLen = O7_INT_UNDEF;
	memset(&r->path, 0, sizeof(r->path));
	r->sing = 0u;
	memset(&r->modules, 0, sizeof(r->modules));
	memset(&r->expectName, 0, sizeof(r->expectName));
	r->nameLen = O7_INT_UNDEF;
	r->nameOk = O7_BOOL_UNDEF;
	r->firstNotOk = O7_BOOL_UNDEF;
}

static void ErrorMessage(int code) {
	Out_Int(o7_sub(code, Parser_ErrAstBegin_cnst), 0);
	Out_String(1, (o7_char *)"\x20");
	if (code <= Parser_ErrAstBegin_cnst) {
		Message_AstError(o7_sub(code, Parser_ErrAstBegin_cnst));
	} else {
		Message_ParseError(code);
	}
}

static void PrintErrors(struct Container_s *mc) {
#	define SkipError_cnst (Ast_ErrImportModuleWithError_cnst + Parser_ErrAstBegin_cnst)

	int i;
	struct Ast_Error_s *err;

	i = 0;
	while (O7_REF(mc)->m != NULL) {
		err = O7_REF(O7_REF(mc)->m)->errors;
		while ((err != NULL) && (o7_cmp(O7_REF(err)->code, SkipError_cnst) == 0)) {
			err = O7_REF(err)->next;
		}
		if (err != NULL) {
			Message_Text(27, (o7_char *)"Found errors in the module ");
			Out_String(StringStore_BlockSize_cnst + 1, O7_REF(O7_REF(O7_REF(mc)->m)->_._.name.block)->s);
			Out_String(2, (o7_char *)": ");
			Out_Ln();
			err = O7_REF(O7_REF(mc)->m)->errors;
			while (err != NULL) {
				if (o7_cmp(O7_REF(err)->code, SkipError_cnst) != 0) {
					i = o7_add(i, 1);

					Out_String(2, (o7_char *)"  ");
					Out_Int(i, 2);
					Out_String(2, (o7_char *)") ");
					ErrorMessage(O7_REF(err)->code);
					Out_String(1, (o7_char *)"\x20");
					Out_Int(o7_add(O7_REF(err)->line, 1), 0);
					Out_String(3, (o7_char *)" : ");
					Out_Int(o7_add(O7_REF(err)->column, o7_mul(O7_REF(err)->tabs, 3)), 0);
					Out_Ln();
				}

				err = O7_REF(err)->next;
			}
		}
		mc = O7_REF(mc)->next;
	}
#	undef SkipError_cnst
}

static struct Ast_RModule *SearchModule(struct ModuleProvider_s *mp, int name_len0, o7_char name[/*len0*/], int ofs, int end) {
	struct Container_s *mc;

	mc = O7_REF(O7_REF(mp)->modules.first)->next;
	while ((mc != O7_REF(mp)->modules.first) && !StringStore_IsEqualToChars(&O7_REF(O7_REF(mc)->m)->_._.name, name_len0, name, ofs, end)) {
		mc = O7_REF(mc)->next;
	}
	return O7_REF(mc)->m;
}

static void AddModule(struct ModuleProvider_s *mp, struct Ast_RModule *m) {
	struct Container_s *mc;

	O7_ASSERT(O7_REF(m)->_._.module == m);
	O7_NEW(&mc, Container_s);
	O7_REF(mc)->m = m;
	O7_REF(mc)->next = O7_REF(mp)->modules.first;

	O7_REF(O7_REF(mp)->modules.last)->next = mc;
	O7_REF(mp)->modules.last = mc;
}

static struct Ast_RModule *GetModule(struct Ast_RProvider *p, struct Ast_RModule *host, int name_len0, o7_char name[/*len0*/], int ofs, int end);
static struct VFileStream_RIn *GetModule_Open(struct ModuleProvider_s *p, int *pathOfs, int name_len0, o7_char name[/*len0*/], int ofs, int end) {
	o7_char n[1024];
	int len, l;
	struct VFileStream_RIn *in_;
	memset(&n, 0, sizeof(n));

	len = StringStore_CalcLen(4096, O7_REF(p)->path, (*pathOfs));
	l = 0;
	if ((len > 0) && StringStore_CopyChars(1024, n, &l, 4096, O7_REF(p)->path, (*pathOfs), o7_add((*pathOfs), len)) && StringStore_CopyCharsNull(1024, n, &l, 1, PlatformExec_dirSep) && StringStore_CopyChars(1024, n, &l, name_len0, name, ofs, end) && StringStore_CopyChars(1024, n, &l, 32, O7_REF(p)->fileExt, 0, O7_REF(p)->extLen)) {
		in_ = VFileStream_OpenIn(1024, n);
	} else {
		in_ = NULL;
	}
	(*pathOfs) = o7_add(o7_add((*pathOfs), len), 1);
	return in_;
}

static struct Ast_RModule *GetModule(struct Ast_RProvider *p, struct Ast_RModule *host, int name_len0, o7_char name[/*len0*/], int ofs, int end) {
	struct Ast_RModule *m;
	struct VFileStream_RIn *source;
	struct ModuleProvider_s *mp;
	int pathOfs, pathInd;

	mp = O7_GUARD(ModuleProvider_s, &p);
	m = SearchModule(mp, name_len0, name, ofs, end);
	if (m != NULL) {
		Log_StrLn(55, (o7_char *)"Найден уже разобранный модуль");
	} else {
		O7_REF(mp)->nameLen = 0;
		O7_ASSERT(StringStore_CopyChars(TranslatorLimits_LenName_cnst + 1, O7_REF(mp)->expectName, &O7_REF(mp)->nameLen, name_len0, name, ofs, end));

		pathInd =  - 1;
		pathOfs = 0;
		do {
			source = GetModule_Open(mp, &pathOfs, name_len0, name, ofs, end);
			if (source != NULL) {
				m = Parser_Parse(&source->_, p, &O7_REF(mp)->opt);
				VFileStream_CloseIn(&source);
				if (!o7_bl(O7_REF(mp)->nameOk)) {
					m = NULL;
				}
			}
			pathInd = o7_add(pathInd, 1);
		} while (!((m != NULL) || (O7_REF(mp)->path[o7_ind(4096, pathOfs)] == 0x00u)));
		if (m != NULL) {
			if (o7_in(pathInd, O7_REF(mp)->sing)) {
				O7_REF(m)->_._.mark = true;
			}
		} else if (o7_bl(O7_REF(mp)->firstNotOk)) {
			O7_REF(mp)->firstNotOk = false;
			Message_Text(37, (o7_char *)"Can not found or open file of module ");
			Out_String(TranslatorLimits_LenName_cnst + 1, O7_REF(mp)->expectName);
			Out_Ln();
		}
	}
	return m;
}

static o7_bool RegModule(struct Ast_RProvider *p, struct Ast_RModule *m);
static o7_bool RegModule_Reg(struct ModuleProvider_s *p, struct Ast_RModule *m) {
	Log_Str(StringStore_BlockSize_cnst + 1, O7_REF(O7_REF(m)->_._.name.block)->s);
	Log_Str(3, (o7_char *)" : ");
	Log_StrLn(TranslatorLimits_LenName_cnst + 1, O7_REF(p)->expectName);
	O7_REF(p)->nameOk = o7_strcmp(StringStore_BlockSize_cnst + 1, O7_REF(O7_REF(m)->_._.name.block)->s, TranslatorLimits_LenName_cnst + 1, O7_REF(p)->expectName) == 0;
	if (o7_bl(O7_REF(p)->nameOk)) {
		AddModule(p, m);
	}
	return o7_bl(O7_REF(p)->nameOk);
}

static o7_bool RegModule(struct Ast_RProvider *p, struct Ast_RModule *m) {
	Log_Str(10, (o7_char *)"RegModule ");
	Log_StrLn(StringStore_BlockSize_cnst + 1, O7_REF(O7_REF(m)->_._.name.block)->s);
	return RegModule_Reg(O7_GUARD(ModuleProvider_s, &p), m);
}

static o7_bool CopyModuleNameForFile(int str_len0, o7_char str[/*len0*/], int *len, struct StringStore_String *name) {
	return StringStore_CopyToChars(str_len0, str, &(*len), &(*name)) && (!GeneratorC_IsSpecModuleName(&(*name)) || StringStore_CopyCharsNull(str_len0, str, &(*len), 1, (o7_char *)"\x5F"));
}

static int OpenCOutput(struct VFileStream_ROut **interface_, struct VFileStream_ROut **implementation, struct Ast_RModule *module, o7_bool isMain, int dir_len0, o7_char dir[/*len0*/], int dirLen, struct PlatformExec_Code *exec) {
	int destLen, ret;

	(*interface_) = NULL;
	(*implementation) = NULL;
	destLen = dirLen;
	if (!StringStore_CopyCharsNull(dir_len0, dir, &destLen, 1, PlatformExec_dirSep) || !CopyModuleNameForFile(dir_len0, dir, &destLen, &O7_REF(module)->_._.name) || (destLen > o7_sub(dir_len0, 3))) {
		ret = CliParser_ErrTooLongOutName_cnst;
	} else {
		dir[o7_ind(dir_len0, destLen)] = (o7_char)'.';
		dir[o7_ind(dir_len0, o7_add(destLen, 2))] = 0x00u;
		if (!isMain) {
			dir[o7_ind(dir_len0, o7_add(destLen, 1))] = (o7_char)'h';
			(*interface_) = VFileStream_OpenOut(dir_len0, dir);
		}
		if (!isMain && ((*interface_) == NULL)) {
			ret = CliParser_ErrOpenH_cnst;
		} else {
			dir[o7_ind(dir_len0, o7_add(destLen, 1))] = (o7_char)'c';
			/* TODO */
			O7_ASSERT(PlatformExec_Add(&(*exec), dir_len0, dir, 0));
			Log_StrLn(dir_len0, dir);
			(*implementation) = VFileStream_OpenOut(dir_len0, dir);
			if ((*implementation) == NULL) {
				VFileStream_CloseOut(&(*interface_));
				ret = CliParser_ErrOpenC_cnst;
			} else {
				ret = ErrNo_cnst;
			}
		}
	}
	return ret;
}

static void NewProvider(struct ModuleProvider_s **mp) {
	O7_NEW(&(*mp), ModuleProvider_s);
	Ast_ProviderInit(&(*mp)->_, GetModule, RegModule);
	Parser_DefaultOptions(&O7_REF((*mp))->opt);
	O7_REF((*mp))->opt.printError = ErrorMessage;
	O7_REF((*mp))->extLen = 0;

	O7_NEW(&O7_REF((*mp))->modules.first, Container_s);
	O7_REF(O7_REF((*mp))->modules.first)->m = NULL;
	O7_REF(O7_REF((*mp))->modules.first)->next = O7_REF((*mp))->modules.first;
	O7_REF((*mp))->modules.last = O7_REF((*mp))->modules.first;

	O7_REF((*mp))->firstNotOk = true;
}

static int GenerateC(struct Ast_RModule *module, o7_bool isMain, struct Ast_Call_s *cmd, struct GeneratorC_Options_s *opt, int dir_len0, o7_char dir[/*len0*/], int dirLen, int cDirs_len0, o7_char cDirs[/*len0*/], struct PlatformExec_Code *exec) {
	struct Ast_RDeclaration *imp;
	int ret, i, cDirsLen, nameLen;
	o7_char name[512];
	struct VFileStream_ROut *iface, *impl;
	memset(&name, 0, sizeof(name));

	O7_REF(module)->_._.used = true;

	ret = ErrNo_cnst;
	imp = (&(O7_REF(module)->import_)->_);
	while ((ret == ErrNo_cnst) && (imp != NULL) && (o7_is(imp, Ast_Import_s_tag))) {
		if (!o7_bl(O7_REF(O7_REF(imp)->module)->_._.used)) {
			ret = GenerateC(O7_REF(imp)->module, false, NULL, opt, dir_len0, dir, dirLen, cDirs_len0, cDirs, &(*exec));
		}
		imp = O7_REF(imp)->next;
	}
	if (ret != ErrNo_cnst) {
	} else if (!o7_bl(O7_REF(module)->_._.mark)) {
		ret = OpenCOutput(&iface, &impl, module, isMain, dir_len0, dir, dirLen, &(*exec));
		if (ret == ErrNo_cnst) {
			GeneratorC_Generate(&iface->_, &impl->_, module, &cmd->_, opt);
			VFileStream_CloseOut(&iface);
			VFileStream_CloseOut(&impl);
		}
	} else {
		i = 0;
		while (cDirs[o7_ind(cDirs_len0, i)] != 0x00u) {
			nameLen = 0;
			cDirsLen = StringStore_CalcLen(cDirs_len0, cDirs, i);
			/* TODO */
			O7_ASSERT(StringStore_CopyChars(512, name, &nameLen, cDirs_len0, cDirs, i, o7_add(i, cDirsLen)) && StringStore_CopyCharsNull(512, name, &nameLen, 1, PlatformExec_dirSep) && CopyModuleNameForFile(512, name, &nameLen, &O7_REF(module)->_._.name) && StringStore_CopyCharsNull(512, name, &nameLen, 2, (o7_char *)".c") && (!CFiles_Exist(512, name, 0) || PlatformExec_Add(&(*exec), 512, name, 0)));
			i = o7_add(o7_add(i, cDirsLen), 1);
		}
	}
	return ret;
}

static o7_bool MakeDir(int name_len0, o7_char name[/*len0*/]) {
	struct PlatformExec_Code cmd;
	PlatformExec_Code_undef(&cmd);

	if (Platform_Posix) {
		O7_ASSERT(PlatformExec_Init(&cmd, 5, (o7_char *)"mkdir") && PlatformExec_Add(&cmd, name_len0, name, 0) && PlatformExec_AddClean(&cmd, 12, (o7_char *)" 2>/dev/null"));
	} else {
		O7_ASSERT(Platform_Windows);
		O7_ASSERT(PlatformExec_Init(&cmd, 5, (o7_char *)"mkdir") && PlatformExec_Add(&cmd, name_len0, name, 0));
	}
	return PlatformExec_Do(&cmd) == PlatformExec_Ok_cnst;
}

static o7_bool RemoveDir(int name_len0, o7_char name[/*len0*/]) {
	struct PlatformExec_Code cmd;
	PlatformExec_Code_undef(&cmd);

	if (Platform_Posix) {
		O7_ASSERT(PlatformExec_Init(&cmd, 2, (o7_char *)"rm") && PlatformExec_Add(&cmd, 2, (o7_char *)"-r", 0) && PlatformExec_Add(&cmd, name_len0, name, 0) && PlatformExec_AddClean(&cmd, 12, (o7_char *)" 2>/dev/null"));
	} else {
		O7_ASSERT(Platform_Windows);
		O7_ASSERT(PlatformExec_Init(&cmd, 5, (o7_char *)"rmdir") && PlatformExec_AddClean(&cmd, 5, (o7_char *)" /s/q") && PlatformExec_Add(&cmd, name_len0, name, 0));
	}
	return PlatformExec_Do(&cmd) == PlatformExec_Ok_cnst;
}

static o7_bool GetTempOutC(int dirCOut_len0, o7_char dirCOut[/*len0*/], int *len, int bin_len0, o7_char bin[/*len0*/], struct StringStore_String *name, int tmp_len0, o7_char tmp[/*len0*/]) {
	int binLen, i;
	o7_bool ok;

	(*len) = 0;
	if (o7_strcmp(tmp_len0, tmp, 0, (o7_char *)"") != 0) {
		ok = true;
		O7_ASSERT(StringStore_CopyCharsNull(dirCOut_len0, dirCOut, &(*len), tmp_len0, tmp));
	} else if (Platform_Posix) {
		ok = true;
		O7_ASSERT(StringStore_CopyCharsNull(dirCOut_len0, dirCOut, &(*len), 9, (o7_char *)"/tmp/o7c-") && StringStore_CopyToChars(dirCOut_len0, dirCOut, &(*len), &(*name)));
	} else {
		O7_ASSERT(Platform_Windows);
		ok = OsEnv_Get(dirCOut_len0, dirCOut, &(*len), 4, (o7_char *)"temp") && StringStore_CopyCharsNull(dirCOut_len0, dirCOut, &(*len), 5, (o7_char *)"\\o7c-") && StringStore_CopyToChars(dirCOut_len0, dirCOut, &(*len), &(*name));
	}

	if (ok) {
		i = 0;
		ok = MakeDir(dirCOut_len0, dirCOut);
		if (!ok && (o7_strcmp(tmp_len0, tmp, 0, (o7_char *)"") == 0)) {
			while (!ok && (i < 100)) {
				if (i == 0) {
					O7_ASSERT(StringStore_CopyCharsNull(dirCOut_len0, dirCOut, &(*len), 3, (o7_char *)"-00"));
				} else {
					dirCOut[o7_ind(dirCOut_len0, o7_sub((*len), 2))] = o7_chr(o7_add((int)(o7_char)'0', o7_div(i, 10)));
					dirCOut[o7_ind(dirCOut_len0, o7_sub((*len), 1))] = o7_chr(o7_add((int)(o7_char)'0', o7_mod(i, 10)));
				}
				ok = MakeDir(dirCOut_len0, dirCOut);
				i = o7_add(i, 1);
			}
		}
		if (ok && (bin[0] == 0x00u)) {
			binLen = 0;
			O7_ASSERT(StringStore_CopyCharsNull(bin_len0, bin, &binLen, dirCOut_len0, dirCOut) && StringStore_CopyCharsNull(bin_len0, bin, &binLen, 1, PlatformExec_dirSep) && StringStore_CopyToChars(bin_len0, bin, &binLen, &(*name)) && (!Platform_Windows || StringStore_CopyCharsNull(bin_len0, bin, &binLen, 4, (o7_char *)".exe")));
		}
	}
	return ok;
}

static o7_bool SearchCCompiler(struct PlatformExec_Code *cmd);
static o7_bool SearchCCompiler_Test(int c_len0, o7_char c[/*len0*/], int ver_len0, o7_char ver[/*len0*/]) {
	struct PlatformExec_Code exec;
	PlatformExec_Code_undef(&exec);

	return PlatformExec_Init(&exec, c_len0, c) && PlatformExec_Add(&exec, ver_len0, ver, 0) && ((Platform_Posix && PlatformExec_AddClean(&exec, 10, (o7_char *)">/dev/null")) || (Platform_Windows && PlatformExec_AddClean(&exec, 10, (o7_char *)">NUL 2>NUL"))) && (PlatformExec_Ok_cnst == PlatformExec_Do(&exec));
}

static o7_bool SearchCCompiler(struct PlatformExec_Code *cmd) {
	return SearchCCompiler_Test(2, (o7_char *)"cc", 9, (o7_char *)"--version") && PlatformExec_AddClean(&(*cmd), 9, (o7_char *)"cc -g -O1") || SearchCCompiler_Test(3, (o7_char *)"gcc", 9, (o7_char *)"--version") && PlatformExec_AddClean(&(*cmd), 10, (o7_char *)"gcc -g -O1") || SearchCCompiler_Test(5, (o7_char *)"clang", 9, (o7_char *)"--version") && PlatformExec_AddClean(&(*cmd), 12, (o7_char *)"clang -g -O1") || SearchCCompiler_Test(3, (o7_char *)"tcc", 2, (o7_char *)"-v") && PlatformExec_Add(&(*cmd), 3, (o7_char *)"tcc", 0);
}

static int ToC(int res, struct CliParser_Args *args);
static int ToC_Bin(struct Ast_RModule *module, struct Ast_Call_s *call, struct GeneratorC_Options_s *opt, int cDirs_len0, o7_char cDirs[/*len0*/], int cc_len0, o7_char cc[/*len0*/], int outC_len0, o7_char outC[/*len0*/], int bin_len0, o7_char bin[/*len0*/], struct PlatformExec_Code *cmd, int tmp_len0, o7_char tmp[/*len0*/]) {
	int outCLen, ret, i, nameLen, cDirsLen;
	o7_bool ok;
	o7_char name[512];
	memset(&name, 0, sizeof(name));

	ok = GetTempOutC(outC_len0, outC, &outCLen, bin_len0, bin, &O7_REF(module)->_._.name, tmp_len0, tmp);
	if (!ok) {
		ret = CliParser_ErrCantCreateOutDir_cnst;
	} else {
		if (cc[0] == 0x00u) {
			ok = SearchCCompiler(&(*cmd));
		} else {
			ok = PlatformExec_AddClean(&(*cmd), cc_len0, cc);
		}
		if (!ok) {
			ret = CliParser_ErrCantFoundCCompiler_cnst;
		} else {
			ret = GenerateC(module, true, call, opt, outC_len0, outC, outCLen, cDirs_len0, cDirs, &(*cmd));
		}
		outC[o7_ind(outC_len0, outCLen)] = 0x00u;
		if (ret == ErrNo_cnst) {
			ok = ok && PlatformExec_Add(&(*cmd), 2, (o7_char *)"-o", 0) && PlatformExec_Add(&(*cmd), bin_len0, bin, 0) && PlatformExec_Add(&(*cmd), 2, (o7_char *)"-I", 0) && PlatformExec_Add(&(*cmd), outC_len0, outC, 0);
			i = 0;
			while (ok && (cDirs[o7_ind(cDirs_len0, i)] != 0x00u)) {
				nameLen = 0;
				cDirsLen = StringStore_CalcLen(cDirs_len0, cDirs, i);
				ok = PlatformExec_Add(&(*cmd), 2, (o7_char *)"-I", 0) && PlatformExec_Add(&(*cmd), cDirs_len0, cDirs, i) && StringStore_CopyChars(512, name, &nameLen, cDirs_len0, cDirs, i, o7_add(i, cDirsLen)) && StringStore_CopyCharsNull(512, name, &nameLen, 1, PlatformExec_dirSep) && StringStore_CopyCharsNull(512, name, &nameLen, 4, (o7_char *)"o7.c") && (!CFiles_Exist(512, name, 0) || PlatformExec_Add(&(*cmd), 512, name, 0));
				i = o7_add(o7_add(i, cDirsLen), 1);
			}
			ok = ok && (!Platform_Posix || PlatformExec_Add(&(*cmd), 3, (o7_char *)"-lm", 0));
			PlatformExec_Log(&(*cmd));
			/* TODO */
			O7_ASSERT(ok);
			if (PlatformExec_Do(&(*cmd)) != PlatformExec_Ok_cnst) {
				ret = CliParser_ErrCCompiler_cnst;
			}
		}
	}
	return ret;
}

static int ToC_Run(int bin_len0, o7_char bin[/*len0*/], int arg) {
	struct PlatformExec_Code cmd;
	o7_char buf[65536];
	int len, ret;
	PlatformExec_Code_undef(&cmd);
	memset(&buf, 0, sizeof(buf));

	ret = CliParser_ErrTooLongRunArgs_cnst;
	if (PlatformExec_Init(&cmd, bin_len0, bin)) {
		arg = o7_add(arg, 1);
		len = 0;
		while ((o7_cmp(arg, CLI_count) < 0) && CLI_Get(65536, buf, &len, arg) && PlatformExec_Add(&cmd, 65536, buf, 0)) {
			len = 0;
			arg = o7_add(arg, 1);
		}
		if (o7_cmp(arg, CLI_count) >= 0) {
			CLI_SetExitCode(PlatformExec_Do(&cmd));
			ret = ErrNo_cnst;
		}
	}
	return ret;
}

static int ToC(int res, struct CliParser_Args *args) {
	int ret, len;
	o7_char outC[1024];
	struct ModuleProvider_s *mp;
	struct Ast_RModule *module;
	struct GeneratorC_Options_s *opt;
	struct Ast_Call_s *call;
	struct PlatformExec_Code exec;
	memset(&outC, 0, sizeof(outC));
	PlatformExec_Code_undef(&exec);

	O7_ASSERT(o7_in(res, O7_SET(CliParser_ResultC_cnst, CliParser_ResultRun_cnst)));

	NewProvider(&mp);
	memcpy(O7_REF(mp)->fileExt, (o7_char *)".mod", sizeof(".mod"));
	/* TODO */
	O7_REF(mp)->extLen = StringStore_CalcLen(32, O7_REF(mp)->fileExt, 0);
	len = 0;
	O7_ASSERT(StringStore_CopyChars(4096, O7_REF(mp)->path, &len, 4096, (*args).modPath, 0, (*args).modPathLen));
	O7_REF(mp)->sing = (*args).sing;
	if (o7_bl((*args).script)) {
		module = Parser_Script(65536, (*args).src, &mp->_, &O7_REF(mp)->opt);
		AddModule(mp, module);
	} else {
		module = GetModule(&mp->_, NULL, 65536, (*args).src, 0, (*args).srcNameEnd);
	}
	if (module == NULL) {
		ret = ErrParse_cnst;
	} else if (O7_REF(module)->errors != NULL) {
		ret = ErrParse_cnst;
		PrintErrors(O7_REF(O7_REF(mp)->modules.first)->next);
	} else {
		if (!o7_bl((*args).script) && (o7_cmp((*args).srcNameEnd, o7_sub((*args).srcLen, 1)) < 0)) {
			ret = Ast_CommandGet(&call, module, 65536, (*args).src, o7_add((*args).srcNameEnd, 1), o7_sub((*args).srcLen, 1));
		} else {
			ret = ErrNo_cnst;
			call = NULL;
		}
		if (ret != Ast_ErrNo_cnst) {
			ret = ErrParse_cnst;
			Message_AstError(ret);
			Out_Ln();
		} else {
			opt = GeneratorC_DefaultOptions();
			if (o7_cmp((*args).init, 0) >= 0) {
				O7_REF(opt)->varInit = o7_int((*args).init);
			}
			O7_ASSERT(PlatformExec_Init(&exec, 0, (o7_char *)""));
			switch (res) {
			case 2:
				(*args).resPathLen = o7_sub((*args).resPathLen, 1);
				ret = GenerateC(module, (call != NULL) || o7_bl((*args).script), call, opt, 1024, (*args).resPath, (*args).resPathLen, 4096, (*args).cDirs, &exec);
				break;
			case 3:
			case 4:
				ret = ToC_Bin(module, call, opt, 4096, (*args).cDirs, 4096, (*args).cc, 1024, outC, 1024, (*args).resPath, &exec, 1024, (*args).tmp);
				if ((res == CliParser_ResultRun_cnst) && (ret == ErrNo_cnst)) {
					ret = ToC_Run(1024, (*args).resPath, (*args).arg);
				}
				if ((o7_strcmp(1024, (*args).tmp, 0, (o7_char *)"") == 0) && !RemoveDir(1024, outC) && (ret == ErrNo_cnst)) {
					ret = CliParser_ErrCantRemoveOutDir_cnst;
				}
				break;
			default:
				o7_case_fail(res);
				break;
			}
		}
	}
	return ret;
}

static o7_bool Handle(struct CliParser_Args *args, int *ret) {
	if ((*ret) == CliParser_CmdHelp_cnst) {
		Message_Usage();
	} else {
		(*ret) = ToC((*ret), &(*args));
	}
	return 0 <= (*ret);
}

static void Translator_Start(void) {
	int ret;
	struct CliParser_Args args;
	CliParser_Args_undef(&args);

	Out_Open();
	Log_Turn(false);

	if (!CliParser_Parse(&args, &ret) || !Handle(&args, &ret)) {
		CLI_SetExitCode(1);
		if (ret != ErrParse_cnst) {
			Message_CliError(ret, 32, args.cmd);
		}
	}
}

extern int main(int argc, char *argv[]) {
	o7_init(argc, argv);
	Log_init();
	Out_init();
	CLI_init();
	VDataStream_init();
	VFileStream_init();
	Utf8_init();
	StringStore_init();
	Parser_init();
	Scanner_init();
	Ast_init();
	GeneratorC_init();
	TranslatorLimits_init();
	PlatformExec_init();
	Message_init();
	CliParser_init();
	Platform_init();
	CFiles_init();
	OsEnv_init();

	o7_tag_init(ModuleProvider_s_tag, Ast_RProvider_tag);

	Translator_Start();
	return o7_exit_code;
}
