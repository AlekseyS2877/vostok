/* Generated by Vostok - Oberon-07 translator */

/*  Command line interface for Oberon-07 translator
 *  Copyright (C) 2016  ComdivByZero
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <assert.h>
#include <math.h>
#include <stdbool.h>

#define O7C_BOOL_UNDEFINED
#include <o7c.h>

#include "Log.h"
#include "Out.h"
#include "CLI.h"
#include "VDataStream.h"
#include "VFileStream.h"
#include "Utf8.h"
#include "StringStore.h"
#include "Parser.h"
#include "Scanner.h"
#include "Ast.h"
#include "GeneratorC.h"
#include "TranslatorLimits.h"
#include "PlatformExec.h"
#include "MessageEn.h"
#include "CliParser.h"

#define ResultC_cnst 0
#define ResultBin_cnst 1
#define ResultRun_cnst 2
#define ErrNo_cnst 0
#define ErrParse_cnst ( - 1)

typedef struct Container_s {
	struct Container_s *next;
	struct Ast_RModule *m;
} *Container;
static o7c_tag_t Container_s_tag;

static void Container_s_undef(struct Container_s *r) {
	r->next = NULL;
	r->m = NULL;
}
typedef struct ModuleProvider_s {
	Ast_RProvider _;
	struct Parser_Options opt;
	o7c_char fileExt[32];
	int extLen;
	o7c_char path[4096];
	unsigned sing;
	struct Translator_anon_0000 {
		struct Container_s *first;
		struct Container_s *last;
	} modules;
} *ModuleProvider;
static o7c_tag_t ModuleProvider_s_tag;

static void ModuleProvider_s_undef(struct ModuleProvider_s *r) {
	Ast_RProvider_undef(&r->_);
	Parser_Options_undef(&r->opt);
	memset(&r->fileExt, 0, sizeof(r->fileExt));
	r->extLen = O7C_INT_UNDEF;
	memset(&r->path, 0, sizeof(r->path));
	r->sing = 0;
	memset(&r->modules, 0, sizeof(r->modules));
}

static void ErrorMessage(int code) {
	Out_Int(o7c_sub(code, Parser_ErrAstBegin_cnst), 0);
	Out_String(2, (o7c_char *)" ");
	if (o7c_cmp(code, Parser_ErrAstBegin_cnst) <=  0) {
		MessageEn_AstError(o7c_sub(code, Parser_ErrAstBegin_cnst));
	} else {
		MessageEn_ParseError(code);
	}
}

static void PrintErrors(struct Container_s *mc) {
#	define SkipError_cnst (Ast_ErrImportModuleWithError_cnst + Parser_ErrAstBegin_cnst)

	int i = O7C_INT_UNDEF;
	struct Ast_Error_s *err = NULL;

	i = 0;
	while (mc->m != NULL) {
		err = mc->m->errors;
		while ((err != NULL) && (o7c_cmp(err->code, SkipError_cnst) ==  0)) {
			err = err->next;
		}
		if (err != NULL) {
			MessageEn_Text(28, (o7c_char *)"Found errors in the module ");
			Out_String(StringStore_BlockSize_cnst + 1, mc->m->_._.name.block->s);
			Out_String(3, (o7c_char *)": ");
			Out_Ln();
			err = mc->m->errors;
			while (err != NULL) {
				if (o7c_cmp(err->code, SkipError_cnst) !=  0) {
					i = o7c_add(i, 1);
					Out_String(3, (o7c_char *)"  ");
					Out_Int(i, 2);
					Out_String(3, (o7c_char *)") ");
					ErrorMessage(err->code);
					Out_String(2, (o7c_char *)" ");
					Out_Int(o7c_add(err->line, 1), 0);
					Out_String(4, (o7c_char *)" : ");
					Out_Int(o7c_add(err->column, o7c_mul(err->tabs, 3)), 0);
					Out_Ln();
				}
				err = err->next;
			}
		}
		mc = mc->next;
	}
#	undef SkipError_cnst
}

static o7c_bool IsEqualStr(int str_len0, o7c_char str[/*len0*/], int ofs, int sample_len0, o7c_char sample[/*len0*/]) {
	int i = O7C_INT_UNDEF;

	i = 0;
	while ((str[o7c_ind(str_len0, ofs)] == sample[o7c_ind(sample_len0, i)]) && (sample[o7c_ind(sample_len0, i)] != 0x00u)) {
		ofs = o7c_add(ofs, 1);
		i = o7c_add(i, 1);
	}
	return str[o7c_ind(str_len0, ofs)] == sample[o7c_ind(sample_len0, i)];
}

static int CopyPath(int str_len0, o7c_char str[/*len0*/], unsigned *sing, int cDirs_len0, o7c_char cDirs[/*len0*/], int cc_len0, o7c_char cc[/*len0*/], int *init_, int *arg);
static o7c_bool CopyPath_CopyInfrPart(int str_len0, o7c_char str[/*len0*/], int *i, int *arg, int add_len0, o7c_char add[/*len0*/]) {
	o7c_bool ret = O7C_BOOL_UNDEF;

	ret = CLI_Get(str_len0, str, &(*i), (*arg));
	if (o7c_bl(ret)) {
		(*i) = o7c_sub((*i), 1);
		ret = StringStore_CopyCharsNull(str_len0, str, &(*i), add_len0, add);
		if (o7c_bl(ret)) {
			(*i) = o7c_add((*i), 1);
			str[o7c_ind(str_len0, (*i))] = 0x00u;
		}
	}
	return ret;
}

static int CopyPath(int str_len0, o7c_char str[/*len0*/], unsigned *sing, int cDirs_len0, o7c_char cDirs[/*len0*/], int cc_len0, o7c_char cc[/*len0*/], int *init_, int *arg) {
	int i = O7C_INT_UNDEF, dirsOfs = O7C_INT_UNDEF, ccLen = O7C_INT_UNDEF, count = O7C_INT_UNDEF, optLen = O7C_INT_UNDEF, ret = O7C_INT_UNDEF;
	o7c_char opt[256];
	memset(&opt, 0, sizeof(opt));

	i = 0;
	dirsOfs = 0;
	cDirs[0] = 0x00u;
	ccLen = 0;
	count = 0;
	(*sing) = 0;
	ret = ErrNo_cnst;
	optLen = 0;
	(*init_) =  - 1;
	while ((o7c_cmp(ret, ErrNo_cnst) ==  0) && (o7c_cmp(count, 32) <  0) && (o7c_cmp((*arg), CLI_count) <  0) && CLI_Get(256, opt, &optLen, (*arg)) && !IsEqualStr(256, opt, 0, 3, (o7c_char *)"--")) {
		optLen = 0;
		if ((o7c_strcmp(256, opt, 3, (o7c_char *)"-i") == 0) || (o7c_strcmp(256, opt, 3, (o7c_char *)"-m") == 0)) {
			(*arg) = o7c_add((*arg), 1);
			if (o7c_cmp((*arg), CLI_count) >=  0) {
				ret = CliParser_ErrNotEnoughArgs_cnst;
			} else if (CLI_Get(str_len0, str, &i, (*arg))) {
				if (o7c_strcmp(256, opt, 3, (o7c_char *)"-i") == 0) {
					(*sing) |= 1u << count;
				}
				count = o7c_add(count, 1);
			} else {
				ret = CliParser_ErrTooLongModuleDirs_cnst;
			}
		} else if (o7c_strcmp(256, opt, 3, (o7c_char *)"-c") == 0) {
			(*arg) = o7c_add((*arg), 1);
			if (o7c_cmp((*arg), CLI_count) >=  0) {
				ret = CliParser_ErrNotEnoughArgs_cnst;
			} else if (CLI_Get(cDirs_len0, cDirs, &dirsOfs, (*arg)) && (o7c_cmp(dirsOfs, cDirs_len0) <  0)) {
				cDirs[o7c_ind(cDirs_len0, dirsOfs)] = 0x00u;
				Log_Str(9, (o7c_char *)"cDirs = ");
				Log_StrLn(cDirs_len0, cDirs);
			} else {
				ret = CliParser_ErrTooLongCDirs_cnst;
			}
		} else if (o7c_strcmp(256, opt, 4, (o7c_char *)"-cc") == 0) {
			(*arg) = o7c_add((*arg), 1);
			if (o7c_cmp((*arg), CLI_count) >=  0) {
				ret = CliParser_ErrNotEnoughArgs_cnst;
			} else if (CLI_Get(cc_len0, cc, &ccLen, (*arg))) {
				ccLen = o7c_sub(ccLen, 1);
			} else {
				ret = CliParser_ErrTooLongCc_cnst;
			}
		} else if (o7c_strcmp(256, opt, 6, (o7c_char *)"-infr") == 0) {
			(*arg) = o7c_add((*arg), 1);
			if (o7c_cmp((*arg), CLI_count) >=  0) {
				ret = CliParser_ErrNotEnoughArgs_cnst;
			} else if (CopyPath_CopyInfrPart(str_len0, str, &i, &(*arg), 24, (o7c_char *)"/singularity/definition") && CopyPath_CopyInfrPart(str_len0, str, &i, &(*arg), 9, (o7c_char *)"/library") && CopyPath_CopyInfrPart(cDirs_len0, cDirs, &dirsOfs, &(*arg), 28, (o7c_char *)"/singularity/implementation")) {
				(*sing) |= 1u << count;
				count = o7c_add(count, 2);
			} else {
				ret = CliParser_ErrTooLongModuleDirs_cnst;
			}
		} else if (o7c_strcmp(256, opt, 6, (o7c_char *)"-init") == 0) {
			(*arg) = o7c_add((*arg), 1);
			optLen = 0;
			if (o7c_cmp((*arg), CLI_count) >=  0) {
				ret = CliParser_ErrNotEnoughArgs_cnst;
			} else if (!CLI_Get(256, opt, &optLen, (*arg))) {
				ret = CliParser_ErrTooLongInit_cnst;
			} else if (o7c_strcmp(256, opt, 3, (o7c_char *)"no") == 0) {
				(*init_) = GeneratorC_VarInitNo_cnst;
			} else if (o7c_strcmp(256, opt, 6, (o7c_char *)"undef") == 0) {
				(*init_) = GeneratorC_VarInitUndefined_cnst;
			} else if (o7c_strcmp(256, opt, 5, (o7c_char *)"zero") == 0) {
				(*init_) = GeneratorC_VarInitZero_cnst;
			} else {
				ret = CliParser_ErrUnknownInit_cnst;
			}
		} else {
			ret = CliParser_ErrUnexpectArg_cnst;
		}
		(*arg) = o7c_add((*arg), 1);
	}
	if (o7c_cmp(o7c_add(i, 1), str_len0) <  0) {
		str[o7c_ind(str_len0, o7c_add(i, 1))] = 0x00u;
		if (o7c_cmp(count, 32) >=  0) {
			ret = CliParser_ErrTooManyModuleDirs_cnst;
		}
	} else {
		ret = CliParser_ErrTooLongModuleDirs_cnst;
		str[o7c_ind(str_len0, o7c_sub(str_len0, 1))] = 0x00u;
		str[o7c_ind(str_len0, o7c_sub(str_len0, 2))] = 0x00u;
		str[o7c_ind(str_len0, o7c_sub(str_len0, 3))] = (char unsigned)'#';
	}
	return ret;
}

static struct Ast_RModule *SearchModule(struct ModuleProvider_s *mp, int name_len0, o7c_char name[/*len0*/], int ofs, int end) {
	struct Container_s *mc = NULL;

	mc = mp->modules.first->next;
	while ((mc != mp->modules.first) && !StringStore_IsEqualToChars(&mc->m->_._.name, StringStore_String_tag, name_len0, name, ofs, end)) {
		mc = mc->next;
	}
	return mc->m;
}

static void AddModule(struct ModuleProvider_s *mp, struct Ast_RModule *m) {
	struct Container_s *mc = NULL;

	assert(m->_._.module == m);
	O7C_NEW(&mc, Container_s);
	mc->m = m;
	mc->next = mp->modules.first;
	mp->modules.last->next = mc;
	mp->modules.last = mc;
}

static struct Ast_RModule *GetModule(struct Ast_RProvider *p, struct Ast_RModule *host, int name_len0, o7c_char name[/*len0*/], int ofs, int end);
static struct VFileStream_RIn *GetModule_Open(struct ModuleProvider_s *p, int *pathOfs, int name_len0, o7c_char name[/*len0*/], int ofs, int end) {
	o7c_char n[1024];
	int len = O7C_INT_UNDEF, l = O7C_INT_UNDEF;
	struct VFileStream_RIn *in_ = NULL;
	memset(&n, 0, sizeof(n));

	len = StringStore_CalcLen(4096, p->path, (*pathOfs));
	l = 0;
	if ((o7c_cmp(len, 0) >  0) && StringStore_CopyChars(1024, n, &l, 4096, p->path, (*pathOfs), o7c_add((*pathOfs), len)) && StringStore_CopyChars(1024, n, &l, 2, (o7c_char *)"/", 0, 1) && StringStore_CopyChars(1024, n, &l, name_len0, name, ofs, end) && StringStore_CopyChars(1024, n, &l, 32, p->fileExt, 0, p->extLen)) {
		Log_Str(16, (o7c_char *)"Открыть ");
		Log_Str(1024, n);
		Log_Ln();
		in_ = VFileStream_OpenIn(1024, n);
	} else {
		in_ = NULL;
	}
	(*pathOfs) = o7c_add(o7c_add((*pathOfs), len), 1);
	return in_;
}

static struct Ast_RModule *GetModule(struct Ast_RProvider *p, struct Ast_RModule *host, int name_len0, o7c_char name[/*len0*/], int ofs, int end) {
	struct Ast_RModule *m = NULL;
	struct VFileStream_RIn *source = NULL;
	struct ModuleProvider_s *mp = NULL;
	int pathOfs = O7C_INT_UNDEF, pathInd = O7C_INT_UNDEF;

	mp = O7C_GUARD(ModuleProvider_s, &p);
	m = SearchModule(mp, name_len0, name, ofs, end);
	if (m != NULL) {
		Log_StrLn(56, (o7c_char *)"Найден уже разобранный модуль");
	} else {
		pathInd =  - 1;
		pathOfs = 0;
		do {
			source = GetModule_Open(mp, &pathOfs, name_len0, name, ofs, end);
			pathInd = o7c_add(pathInd, 1);
		} while (!((source != NULL) || (mp->path[o7c_ind(4096, pathOfs)] == 0x00u)));
		if (source != NULL) {
			m = Parser_Parse(&source->_, p, &mp->opt, Parser_Options_tag);
			if (o7c_in(pathInd, mp->sing)) {
				m->_._.mark = true;
			}
			VFileStream_CloseIn(&source);
		} else {
			MessageEn_Text(37, (o7c_char *)"Can not found or open file of module");
			Out_Ln();
		}
	}
	return m;
}

static void RegModule(struct Ast_RProvider *p, struct Ast_RModule *m) {
	Log_Str(11, (o7c_char *)"RegModule ");
	Log_StrLn(StringStore_BlockSize_cnst + 1, m->_._.name.block->s);
	AddModule(O7C_GUARD(ModuleProvider_s, &p), m);
}

static int OpenCOutput(struct VFileStream_ROut **interface_, struct VFileStream_ROut **implementation, struct Ast_RModule *module, o7c_bool isMain, int dir_len0, o7c_char dir[/*len0*/], int dirLen) {
	int destLen = O7C_INT_UNDEF, ret = O7C_INT_UNDEF;

	(*interface_) = NULL;
	(*implementation) = NULL;
	destLen = dirLen;
	if (!StringStore_CopyChars(dir_len0, dir, &destLen, 2, (o7c_char *)"/", 0, 1) || !StringStore_CopyToChars(dir_len0, dir, &destLen, &module->_._.name, StringStore_String_tag) || (o7c_cmp(destLen, o7c_sub(dir_len0, 3)) >  0)) {
		ret = CliParser_ErrTooLongOutName_cnst;
	} else {
		dir[o7c_ind(dir_len0, destLen)] = (char unsigned)'.';
		dir[o7c_ind(dir_len0, o7c_add(destLen, 2))] = 0x00u;
		if (!isMain) {
			dir[o7c_ind(dir_len0, o7c_add(destLen, 1))] = (char unsigned)'h';
			(*interface_) = VFileStream_OpenOut(dir_len0, dir);
		}
		if (!isMain && ((*interface_) == NULL)) {
			ret = CliParser_ErrOpenH_cnst;
		} else {
			dir[o7c_ind(dir_len0, o7c_add(destLen, 1))] = (char unsigned)'c';
			Log_StrLn(dir_len0, dir);
			(*implementation) = VFileStream_OpenOut(dir_len0, dir);
			if ((*implementation) == NULL) {
				VFileStream_CloseOut(&(*interface_));
				ret = CliParser_ErrOpenC_cnst;
			} else {
				ret = ErrNo_cnst;
			}
		}
	}
	return ret;
}

static void NewProvider(struct ModuleProvider_s **mp) {
	O7C_NEW(&(*mp), ModuleProvider_s);
	Ast_ProviderInit(&(*mp)->_, GetModule, RegModule);
	Parser_DefaultOptions(&(*mp)->opt, Parser_Options_tag);
	(*mp)->opt.printError = ErrorMessage;
	(*mp)->extLen = 0;
	O7C_NEW(&(*mp)->modules.first, Container_s);
	(*mp)->modules.first->m = NULL;
	(*mp)->modules.first->next = (*mp)->modules.first;
	(*mp)->modules.last = (*mp)->modules.first;
}

static int GenerateC(struct Ast_RModule *module, o7c_bool isMain, struct Ast_Call_s *cmd, struct GeneratorC_Options_s *opt, int dir_len0, o7c_char dir[/*len0*/], int dirLen) {
	struct Ast_RDeclaration *imp = NULL;
	int ret = O7C_INT_UNDEF;
	struct VFileStream_ROut *iface = NULL, *impl = NULL;

	module->_._.mark = true;
	ret = ErrNo_cnst;
	imp = (&(module->import_)->_);
	while ((o7c_cmp(ret, ErrNo_cnst) ==  0) && (imp != NULL) && (o7c_is(imp, Ast_Import_s_tag))) {
		if (!imp->module->_._.mark) {
			ret = GenerateC(imp->module, false, NULL, opt, dir_len0, dir, dirLen);
		}
		imp = imp->next;
	}
	if (o7c_cmp(ret, ErrNo_cnst) ==  0) {
		ret = OpenCOutput(&iface, &impl, module, isMain, dir_len0, dir, dirLen);
		if (o7c_cmp(ret, ErrNo_cnst) ==  0) {
			GeneratorC_Generate(&iface->_, &impl->_, module, &cmd->_, opt);
			VFileStream_CloseOut(&iface);
			VFileStream_CloseOut(&impl);
		}
	}
	return ret;
}

static o7c_bool MakeDir(int name_len0, o7c_char name[/*len0*/]) {
	struct PlatformExec_Code cmd;
	o7c_bool ok = O7C_BOOL_UNDEF;
	PlatformExec_Code_undef(&cmd);

	ok = PlatformExec_Init(&cmd, PlatformExec_Code_tag, 6, (o7c_char *)"mkdir") && PlatformExec_Add(&cmd, PlatformExec_Code_tag, name_len0, name, 0);
	assert(o7c_bl(ok));
	return o7c_cmp(PlatformExec_Do(&cmd, PlatformExec_Code_tag), PlatformExec_Ok_cnst) ==  0;
}

static o7c_bool RemoveDir(int name_len0, o7c_char name[/*len0*/]) {
	struct PlatformExec_Code cmd;
	o7c_bool ok = O7C_BOOL_UNDEF;
	PlatformExec_Code_undef(&cmd);

	ok = PlatformExec_Init(&cmd, PlatformExec_Code_tag, 3, (o7c_char *)"rm") && PlatformExec_Add(&cmd, PlatformExec_Code_tag, 3, (o7c_char *)"-r", 0) && PlatformExec_Add(&cmd, PlatformExec_Code_tag, name_len0, name, 0);
	assert(o7c_bl(ok));
	return o7c_cmp(PlatformExec_Do(&cmd, PlatformExec_Code_tag), PlatformExec_Ok_cnst) ==  0;
}

static o7c_bool GetTempOutC(int dirCOut_len0, o7c_char dirCOut[/*len0*/], int *len, int bin_len0, o7c_char bin[/*len0*/], struct StringStore_String *name, o7c_tag_t name_tag) {
	int binLen = O7C_INT_UNDEF, i = O7C_INT_UNDEF;
	o7c_bool ok = O7C_BOOL_UNDEF;
	struct PlatformExec_Code cmd;
	PlatformExec_Code_undef(&cmd);

	(*len) = 0;
	ok = StringStore_CopyCharsNull(dirCOut_len0, dirCOut, &(*len), 10, (o7c_char *)"/tmp/o7c-") && StringStore_CopyToChars(dirCOut_len0, dirCOut, &(*len), &(*name), name_tag);
	assert(o7c_bl(ok));
	i = 0;
	ok = MakeDir(dirCOut_len0, dirCOut);
	while (!ok && (o7c_cmp(i, 100) <  0)) {
		if (o7c_cmp(i, 0) ==  0) {
			ok = StringStore_CopyCharsNull(dirCOut_len0, dirCOut, &(*len), 4, (o7c_char *)"-00");
			assert(o7c_bl(ok));
		} else {
			dirCOut[o7c_ind(dirCOut_len0, o7c_sub((*len), 2))] = o7c_chr(o7c_add((int)(char unsigned)'0', o7c_div(i, 10)));
			dirCOut[o7c_ind(dirCOut_len0, o7c_sub((*len), 1))] = o7c_chr(o7c_add((int)(char unsigned)'0', o7c_mod(i, 10)));
		}
		ok = MakeDir(dirCOut_len0, dirCOut);
		i = o7c_add(i, 1);
	}
	if (o7c_bl(ok) && (bin[0] == 0x00u)) {
		binLen = 0;
		ok = StringStore_CopyCharsNull(bin_len0, bin, &binLen, dirCOut_len0, dirCOut) && StringStore_CopyCharsNull(bin_len0, bin, &binLen, 2, (o7c_char *)"/") && StringStore_CopyToChars(bin_len0, bin, &binLen, &(*name), name_tag);
		assert(o7c_bl(ok));
	}
	return ok;
}

static int ToC(int res);
static int ToC_Bin(struct Ast_RModule *module, struct Ast_Call_s *call, struct GeneratorC_Options_s *opt, int cDirs_len0, o7c_char cDirs[/*len0*/], int cc_len0, o7c_char cc[/*len0*/], int outC_len0, o7c_char outC[/*len0*/], int bin_len0, o7c_char bin[/*len0*/]) {
	struct PlatformExec_Code cmd;
	int outCLen = O7C_INT_UNDEF, ret = O7C_INT_UNDEF, i = O7C_INT_UNDEF;
	o7c_bool ok = O7C_BOOL_UNDEF;
	PlatformExec_Code_undef(&cmd);

	ok = GetTempOutC(outC_len0, outC, &outCLen, bin_len0, bin, &module->_._.name, StringStore_String_tag);
	if (!ok) {
		ret = CliParser_ErrCantCreateOutDir_cnst;
	} else {
		ret = GenerateC(module, true, call, opt, outC_len0, outC, outCLen);
		outC[o7c_ind(outC_len0, outCLen)] = 0x00u;
		if (o7c_cmp(ret, ErrNo_cnst) ==  0) {
			ok = PlatformExec_Init(&cmd, PlatformExec_Code_tag, 1, (o7c_char *)"");
			if (cc[0] == 0x00u) {
				ok = o7c_bl(ok) && PlatformExec_AddClean(&cmd, PlatformExec_Code_tag, 10, (o7c_char *)"cc -g -O1");
			} else {
				ok = o7c_bl(ok) && PlatformExec_AddClean(&cmd, PlatformExec_Code_tag, cc_len0, cc);
			}
			ok = o7c_bl(ok) && PlatformExec_Add(&cmd, PlatformExec_Code_tag, 3, (o7c_char *)"-o", 0) && PlatformExec_Add(&cmd, PlatformExec_Code_tag, bin_len0, bin, 0) && PlatformExec_Add(&cmd, PlatformExec_Code_tag, outC_len0, outC, 0) && PlatformExec_AddClean(&cmd, PlatformExec_Code_tag, 8, (o7c_char *)"/*.c -I") && PlatformExec_Add(&cmd, PlatformExec_Code_tag, outC_len0, outC, 0);
			i = 0;
			while (o7c_bl(ok) && (cDirs[o7c_ind(cDirs_len0, i)] != 0x00u)) {
				ok = PlatformExec_Add(&cmd, PlatformExec_Code_tag, cDirs_len0, cDirs, i) && PlatformExec_AddClean(&cmd, PlatformExec_Code_tag, 8, (o7c_char *)"/*.c -I") && PlatformExec_Add(&cmd, PlatformExec_Code_tag, cDirs_len0, cDirs, i);
				i = o7c_add(o7c_add(i, StringStore_CalcLen(cDirs_len0, cDirs, i)), 1);
			}
			ok = o7c_bl(ok) && PlatformExec_Add(&cmd, PlatformExec_Code_tag, 4, (o7c_char *)"-lm", 0);
			PlatformExec_Log(&cmd, PlatformExec_Code_tag);
			assert(o7c_bl(ok));
			if (o7c_cmp(PlatformExec_Do(&cmd, PlatformExec_Code_tag), PlatformExec_Ok_cnst) !=  0) {
				ret = CliParser_ErrCCompiler_cnst;
			}
		}
	}
	return ret;
}

static int ToC_Run(int bin_len0, o7c_char bin[/*len0*/], int arg) {
	struct PlatformExec_Code cmd;
	o7c_char buf[65536];
	int len = O7C_INT_UNDEF, ret = O7C_INT_UNDEF;
	PlatformExec_Code_undef(&cmd);
	memset(&buf, 0, sizeof(buf));

	ret = CliParser_ErrTooLongRunArgs_cnst;
	if (PlatformExec_Init(&cmd, PlatformExec_Code_tag, bin_len0, bin)) {
		arg = o7c_add(arg, 1);
		len = 0;
		while ((o7c_cmp(arg, CLI_count) <  0) && CLI_Get(65536, buf, &len, arg) && PlatformExec_Add(&cmd, PlatformExec_Code_tag, 65536, buf, 0)) {
			len = 0;
			arg = o7c_add(arg, 1);
		}
		if (o7c_cmp(arg, CLI_count) >=  0) {
			CLI_SetExitCode(PlatformExec_Do(&cmd, PlatformExec_Code_tag));
			ret = ErrNo_cnst;
		}
	}
	return ret;
}

static int ToC_ParseCommand(int src_len0, o7c_char src[/*len0*/], o7c_bool *script);
static void ParseCommand_ToC_Empty(int src_len0, o7c_char src[/*len0*/], int *j) {
	while ((src[o7c_ind(src_len0, (*j))] == (char unsigned)' ') || (src[o7c_ind(src_len0, (*j))] == 0x09u)) {
		(*j) = o7c_add((*j), 1);
	}
}

static int ToC_ParseCommand(int src_len0, o7c_char src[/*len0*/], o7c_bool *script) {
	int i = O7C_INT_UNDEF, j = O7C_INT_UNDEF;

	i = 0;
	while ((src[o7c_ind(src_len0, i)] != 0x00u) && (src[o7c_ind(src_len0, i)] != (char unsigned)'.')) {
		i = o7c_add(i, 1);
	}
	if (src[o7c_ind(src_len0, i)] == (char unsigned)'.') {
		j = o7c_add(i, 1);
		ParseCommand_ToC_Empty(src_len0, src, &j);
		while ((src[o7c_ind(src_len0, j)] >= (char unsigned)'a') && (src[o7c_ind(src_len0, j)] <= (char unsigned)'z') || (src[o7c_ind(src_len0, j)] >= (char unsigned)'A') && (src[o7c_ind(src_len0, j)] <= (char unsigned)'Z') || (src[o7c_ind(src_len0, j)] >= (char unsigned)'0') && (src[o7c_ind(src_len0, j)] <= (char unsigned)'9')) {
			j = o7c_add(j, 1);
		}
		ParseCommand_ToC_Empty(src_len0, src, &j);
		(*script) = src[o7c_ind(src_len0, j)] != 0x00u;
	} else {
		(*script) = false;
	}
	return i;
}

static int ToC(int res) {
	int ret = O7C_INT_UNDEF;
	o7c_char src[65536];
	int srcLen = O7C_INT_UNDEF, srcNameEnd = O7C_INT_UNDEF;
	o7c_char outC[1024], resPath[1024];
	int resPathLen = O7C_INT_UNDEF;
	o7c_char cDirs[4096], cc[4096];
	struct ModuleProvider_s *mp = NULL;
	struct Ast_RModule *module = NULL;
	struct GeneratorC_Options_s *opt = NULL;
	int init_ = O7C_INT_UNDEF, arg = O7C_INT_UNDEF;
	struct Ast_Call_s *call = NULL;
	o7c_bool script = O7C_BOOL_UNDEF;
	memset(&src, 0, sizeof(src));
	memset(&outC, 0, sizeof(outC));
	memset(&resPath, 0, sizeof(resPath));
	memset(&cDirs, 0, sizeof(cDirs));
	memset(&cc, 0, sizeof(cc));

	assert(o7c_in(res, O7C_SET(ResultC_cnst, ResultRun_cnst)));
	srcLen = 0;
	arg = o7c_add(3, (int)(o7c_cmp(res, ResultRun_cnst) !=  0));
	if (o7c_cmp(CLI_count, arg) <  0) {
		ret = CliParser_ErrNotEnoughArgs_cnst;
	} else if (!CLI_Get(65536, src, &srcLen, 2)) {
		ret = CliParser_ErrTooLongSourceName_cnst;
	} else {
		NewProvider(&mp);
		memcpy(mp->fileExt, (o7c_char *)".mod", sizeof(".mod"));
		/* TODO */
		mp->extLen = StringStore_CalcLen(32, mp->fileExt, 0);
		ret = CopyPath(4096, mp->path, &mp->sing, 4096, cDirs, 4096, cc, &init_, &arg);
		if (o7c_cmp(ret, ErrNo_cnst) ==  0) {
			srcNameEnd = ToC_ParseCommand(65536, src, &script);
			if (o7c_bl(script)) {
				module = Parser_Script(65536, src, &mp->_, &mp->opt, Parser_Options_tag);
				AddModule(mp, module);
			} else {
				module = GetModule(&mp->_, NULL, 65536, src, 0, srcNameEnd);
			}
			resPathLen = 0;
			resPath[0] = 0x00u;
			if (module == NULL) {
				ret = ErrParse_cnst;
			} else if (module->errors != NULL) {
				PrintErrors(mp->modules.first->next);
				ret = ErrParse_cnst;
			} else if ((o7c_cmp(res, ResultRun_cnst) !=  0) && !CLI_Get(1024, resPath, &resPathLen, 3)) {
				ret = CliParser_ErrTooLongOutName_cnst;
			} else {
				if (!script && (o7c_cmp(srcNameEnd, o7c_sub(srcLen, 1)) <  0)) {
					ret = Ast_CommandGet(&call, module, 65536, src, o7c_add(srcNameEnd, 1), o7c_sub(srcLen, 1));
				} else {
					call = NULL;
				}
				if (o7c_cmp(ret, Ast_ErrNo_cnst) !=  0) {
					MessageEn_AstError(ret);
					Out_Ln();
					ret = ErrParse_cnst;
				} else {
					opt = GeneratorC_DefaultOptions();
					if (o7c_cmp(init_, 0) >=  0) {
						opt->varInit = init_;
					}
					switch (res) {
					case 0:
						resPathLen = o7c_sub(resPathLen, 1);
						ret = GenerateC(module, (call != NULL) || o7c_bl(script), call, opt, 1024, resPath, resPathLen);
						break;
					case 1:
					case 2:
						ret = ToC_Bin(module, call, opt, 4096, cDirs, 4096, cc, 1024, outC, 1024, resPath);
						if ((o7c_cmp(res, ResultRun_cnst) ==  0) && (o7c_cmp(ret, ErrNo_cnst) ==  0)) {
							ret = ToC_Run(1024, resPath, arg);
						}
						if (!RemoveDir(1024, outC) && (o7c_cmp(ret, ErrNo_cnst) ==  0)) {
							ret = CliParser_ErrCantRemoveOutDir_cnst;
						}
						break;
					default:
						abort();
						break;
					}
				}
			}
		}
	}
	return ret;
}

static void Translator_Start(void) {
	o7c_char cmd[1024];
	int cmdLen = O7C_INT_UNDEF, ret = O7C_INT_UNDEF;
	memset(&cmd, 0, sizeof(cmd));

	Out_Open();
	Log_Turn(false);
	cmdLen = 0;
	if ((o7c_cmp(CLI_count, 1) <=  0) || !CLI_Get(1024, cmd, &cmdLen, 1)) {
		ret = CliParser_ErrWrongArgs_cnst;
	} else {
		if (o7c_strcmp(1024, cmd, 5, (o7c_char *)"help") == 0) {
			ret = ErrNo_cnst;
			MessageEn_Usage();
			Out_Ln();
		} else if (o7c_strcmp(1024, cmd, 5, (o7c_char *)"to-c") == 0) {
			ret = ToC(ResultC_cnst);
		} else if (o7c_strcmp(1024, cmd, 7, (o7c_char *)"to-bin") == 0) {
			ret = ToC(ResultBin_cnst);
		} else if (o7c_strcmp(1024, cmd, 4, (o7c_char *)"run") == 0) {
			ret = ToC(ResultRun_cnst);
		} else {
			ret = CliParser_ErrUnknownCommand_cnst;
		}
	}
	if (o7c_cmp(ret, ErrNo_cnst) !=  0) {
		CLI_SetExitCode(1);
		if (o7c_cmp(ret, ErrParse_cnst) !=  0) {
			MessageEn_CliError(ret, 1024, cmd);
		}
	}
}

extern int main(int argc, char *argv[]) {
	o7c_init(argc, argv);
	Log_init();
	Out_init();
	CLI_init();
	VDataStream_init();
	VFileStream_init();
	Utf8_init();
	StringStore_init();
	Parser_init();
	Scanner_init();
	Ast_init();
	GeneratorC_init();
	TranslatorLimits_init();
	PlatformExec_init();
	MessageEn_init();
	CliParser_init();

	o7c_tag_init(Container_s_tag, NULL);
	o7c_tag_init(ModuleProvider_s_tag, Ast_RProvider_tag);

	Translator_Start();
	return o7c_exit_code;
}
