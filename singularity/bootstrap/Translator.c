/* Generated by Vostok - Oberon-07 translator */

/*  Command line interface for Oberon-07 translator
 *  Copyright (C) 2016-2017 ComdivByZero
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <stdbool.h>

#define O7_BOOL_UNDEFINED
#include <o7.h>

#include "Log.h"
#include "Out.h"
#include "CLI.h"
#include "VDataStream.h"
#include "VFileStream.h"
#include "Utf8.h"
#include "StringStore.h"
#include "Parser.h"
#include "Scanner.h"
#include "Ast.h"
#include "GeneratorC.h"
#include "TranslatorLimits.h"
#include "PlatformExec.h"
#include "MessageEn.h"
#include "CliParser.h"
#include "Platform.h"
#include "CFiles.h"
#include "OsEnv.h"

#define ResultC_cnst 0
#define ResultBin_cnst 1
#define ResultRun_cnst 2

#define ErrNo_cnst 0
#define ErrParse_cnst ( - 1)

typedef struct Container_s {
	struct Container_s *next;
	struct Ast_RModule *m;
} *Container;
#define Container_s_tag o7_base_tag

static void Container_s_undef(struct Container_s *r) {
	r->next = NULL;
	r->m = NULL;
}

typedef struct ModuleProvider_s {
	Ast_RProvider _;
	struct Parser_Options opt;
	o7_char fileExt[32];
	int extLen;
	o7_char path[4096];
	unsigned sing;
	struct Translator_anon_0000 {
		struct Container_s *first;
		struct Container_s *last;
	} modules;
} *ModuleProvider;
static o7_tag_t ModuleProvider_s_tag;

static void ModuleProvider_s_undef(struct ModuleProvider_s *r) {
	Ast_RProvider_undef(&r->_);
	Parser_Options_undef(&r->opt);
	memset(&r->fileExt, 0, sizeof(r->fileExt));
	r->extLen = O7_INT_UNDEF;
	memset(&r->path, 0, sizeof(r->path));
	r->sing = 0;
	memset(&r->modules, 0, sizeof(r->modules));
}

static o7_char pathSep[2];

static void ErrorMessage(int code) {
	Out_Int(o7_sub(code, Parser_ErrAstBegin_cnst), 0);
	Out_String(1, (o7_char *)"\x20");
	if (o7_cmp(code, Parser_ErrAstBegin_cnst) <=  0) {
		MessageEn_AstError(o7_sub(code, Parser_ErrAstBegin_cnst));
	} else {
		MessageEn_ParseError(code);
	}
}

static void PrintErrors(struct Container_s *mc) {
#	define SkipError_cnst (Ast_ErrImportModuleWithError_cnst + Parser_ErrAstBegin_cnst)

	int i = O7_INT_UNDEF;
	struct Ast_Error_s *err = NULL;

	i = 0;
	while (O7_REF(mc)->m != NULL) {
		err = O7_REF(O7_REF(mc)->m)->errors;
		while ((err != NULL) && (o7_cmp(O7_REF(err)->code, SkipError_cnst) ==  0)) {
			err = O7_REF(err)->next;
		}
		if (err != NULL) {
			MessageEn_Text(27, (o7_char *)"Found errors in the module ");
			Out_String(StringStore_BlockSize_cnst + 1, O7_REF(O7_REF(O7_REF(mc)->m)->_._.name.block)->s);
			Out_String(2, (o7_char *)": ");
			Out_Ln();
			err = O7_REF(O7_REF(mc)->m)->errors;
			while (err != NULL) {
				if (o7_cmp(O7_REF(err)->code, SkipError_cnst) !=  0) {
					i = o7_add(i, 1);

					Out_String(2, (o7_char *)"  ");
					Out_Int(i, 2);
					Out_String(2, (o7_char *)") ");
					ErrorMessage(O7_REF(err)->code);
					Out_String(1, (o7_char *)"\x20");
					Out_Int(o7_add(O7_REF(err)->line, 1), 0);
					Out_String(3, (o7_char *)" : ");
					Out_Int(o7_add(O7_REF(err)->column, o7_mul(O7_REF(err)->tabs, 3)), 0);
					Out_Ln();
				}

				err = O7_REF(err)->next;
			}
		}
		mc = O7_REF(mc)->next;
	}
#	undef SkipError_cnst
}

static o7_bool IsEqualStr(int str_len0, o7_char str[/*len0*/], int ofs, int sample_len0, o7_char sample[/*len0*/]) {
	int i = O7_INT_UNDEF;

	i = 0;
	while ((str[o7_ind(str_len0, ofs)] == sample[o7_ind(sample_len0, i)]) && (sample[o7_ind(sample_len0, i)] != 0x00u)) {
		ofs = o7_add(ofs, 1);
		i = o7_add(i, 1);
	}
	return str[o7_ind(str_len0, ofs)] == sample[o7_ind(sample_len0, i)];
}

static int CopyPath(int str_len0, o7_char str[/*len0*/], unsigned *sing, int cDirs_len0, o7_char cDirs[/*len0*/], int cc_len0, o7_char cc[/*len0*/], int *init, int tmp_len0, o7_char tmp[/*len0*/], int *arg);
static o7_bool CopyPath_CopyInfrPart(int str_len0, o7_char str[/*len0*/], int *i, int *arg, int add_len0, o7_char add[/*len0*/]) {
	o7_bool ret = O7_BOOL_UNDEF;

	ret = CLI_Get(str_len0, str, &(*i), (*arg));
	if (o7_bl(ret)) {
		(*i) = o7_sub((*i), 1);
		ret = StringStore_CopyCharsNull(str_len0, str, &(*i), add_len0, add);
		if (o7_bl(ret)) {
			(*i) = o7_add((*i), 1);
			str[o7_ind(str_len0, (*i))] = 0x00u;
		}
	}
	return o7_bl(ret);
}

static int CopyPath(int str_len0, o7_char str[/*len0*/], unsigned *sing, int cDirs_len0, o7_char cDirs[/*len0*/], int cc_len0, o7_char cc[/*len0*/], int *init, int tmp_len0, o7_char tmp[/*len0*/], int *arg) {
	int i = O7_INT_UNDEF, dirsOfs = O7_INT_UNDEF, ccLen = O7_INT_UNDEF, count = O7_INT_UNDEF, optLen = O7_INT_UNDEF, ret = O7_INT_UNDEF;
	o7_char opt[256];
	memset(&opt, 0, sizeof(opt));

	i = 0;
	dirsOfs = 0;
	cDirs[0] = 0x00u;
	tmp[0] = 0x00u;
	ccLen = 0;
	count = 0;
	(*sing) = 0;
	ret = ErrNo_cnst;
	optLen = 0;
	(*init) =  - 1;
	while ((o7_cmp(ret, ErrNo_cnst) ==  0) && (o7_cmp(count, 32) <  0) && (o7_cmp((*arg), CLI_count) <  0) && CLI_Get(256, opt, &optLen, (*arg)) && !IsEqualStr(256, opt, 0, 2, (o7_char *)"--")) {
		optLen = 0;
		if ((o7_strcmp(256, opt, 2, (o7_char *)"-i") == 0) || (o7_strcmp(256, opt, 2, (o7_char *)"-m") == 0)) {
			(*arg) = o7_add((*arg), 1);
			if (o7_cmp((*arg), CLI_count) >=  0) {
				ret = CliParser_ErrNotEnoughArgs_cnst;
			} else if (CLI_Get(str_len0, str, &i, (*arg))) {
				if (o7_strcmp(256, opt, 2, (o7_char *)"-i") == 0) {
					(*sing) |= 1u << count;
				}
				count = o7_add(count, 1);
			} else {
				ret = CliParser_ErrTooLongModuleDirs_cnst;
			}
		} else if (o7_strcmp(256, opt, 2, (o7_char *)"-c") == 0) {
			(*arg) = o7_add((*arg), 1);
			if (o7_cmp((*arg), CLI_count) >=  0) {
				ret = CliParser_ErrNotEnoughArgs_cnst;
			} else if (CLI_Get(cDirs_len0, cDirs, &dirsOfs, (*arg)) && (o7_cmp(dirsOfs, cDirs_len0) <  0)) {
				cDirs[o7_ind(cDirs_len0, dirsOfs)] = 0x00u;
				Log_Str(8, (o7_char *)"cDirs = ");
				Log_StrLn(cDirs_len0, cDirs);
			} else {
				ret = CliParser_ErrTooLongCDirs_cnst;
			}
		} else if (o7_strcmp(256, opt, 3, (o7_char *)"-cc") == 0) {
			(*arg) = o7_add((*arg), 1);
			if (o7_cmp((*arg), CLI_count) >=  0) {
				ret = CliParser_ErrNotEnoughArgs_cnst;
			} else if (CLI_Get(cc_len0, cc, &ccLen, (*arg))) {
				ccLen = o7_sub(ccLen, 1);
			} else {
				ret = CliParser_ErrTooLongCc_cnst;
			}
		} else if (o7_strcmp(256, opt, 5, (o7_char *)"-infr") == 0) {
			(*arg) = o7_add((*arg), 1);
			if (o7_cmp((*arg), CLI_count) >=  0) {
				ret = CliParser_ErrNotEnoughArgs_cnst;
			} else if (o7_bl(Platform_Posix) && CopyPath_CopyInfrPart(str_len0, str, &i, &(*arg), 23, (o7_char *)"/singularity/definition") && CopyPath_CopyInfrPart(str_len0, str, &i, &(*arg), 8, (o7_char *)"/library") && CopyPath_CopyInfrPart(cDirs_len0, cDirs, &dirsOfs, &(*arg), 27, (o7_char *)"/singularity/implementation") || o7_bl(Platform_Windows) && CopyPath_CopyInfrPart(str_len0, str, &i, &(*arg), 23, (o7_char *)"\\singularity\\definition") && CopyPath_CopyInfrPart(str_len0, str, &i, &(*arg), 8, (o7_char *)"\\library") && CopyPath_CopyInfrPart(cDirs_len0, cDirs, &dirsOfs, &(*arg), 27, (o7_char *)"\\singularity\\implementation")) {
				(*sing) |= 1u << count;
				count = o7_add(count, 2);
			} else {
				ret = CliParser_ErrTooLongModuleDirs_cnst;
			}
		} else if (o7_strcmp(256, opt, 5, (o7_char *)"-init") == 0) {
			(*arg) = o7_add((*arg), 1);
			if (o7_cmp((*arg), CLI_count) >=  0) {
				ret = CliParser_ErrNotEnoughArgs_cnst;
			} else if (!CLI_Get(256, opt, &optLen, (*arg))) {
				ret = CliParser_ErrUnknownInit_cnst;
			} else if (o7_strcmp(256, opt, 2, (o7_char *)"no") == 0) {
				(*init) = GeneratorC_VarInitNo_cnst;
			} else if (o7_strcmp(256, opt, 5, (o7_char *)"undef") == 0) {
				(*init) = GeneratorC_VarInitUndefined_cnst;
			} else if (o7_strcmp(256, opt, 4, (o7_char *)"zero") == 0) {
				(*init) = GeneratorC_VarInitZero_cnst;
			} else {
				ret = CliParser_ErrUnknownInit_cnst;
			}
			optLen = 0;
		} else if (o7_strcmp(256, opt, 2, (o7_char *)"-t") == 0) {
			(*arg) = o7_add((*arg), 1);
			if (o7_cmp((*arg), CLI_count) >=  0) {
				ret = CliParser_ErrNotEnoughArgs_cnst;
			} else if (!CLI_Get(tmp_len0, tmp, &optLen, (*arg))) {
				ret = CliParser_ErrTooLongTemp_cnst;
			}
			optLen = 0;
		} else {
			ret = CliParser_ErrUnexpectArg_cnst;
		}
		(*arg) = o7_add((*arg), 1);
	}
	if (o7_cmp(o7_add(i, 1), str_len0) <  0) {
		str[o7_ind(str_len0, o7_add(i, 1))] = 0x00u;
		if (o7_cmp(count, 32) >=  0) {
			ret = CliParser_ErrTooManyModuleDirs_cnst;
		}
	} else {
		ret = CliParser_ErrTooLongModuleDirs_cnst;
		str[o7_ind(str_len0, o7_sub(str_len0, 1))] = 0x00u;
		str[o7_ind(str_len0, o7_sub(str_len0, 2))] = 0x00u;
		str[o7_ind(str_len0, o7_sub(str_len0, 3))] = (o7_char)'#';
	}
	return o7_int(ret);
}

static struct Ast_RModule *SearchModule(struct ModuleProvider_s *mp, int name_len0, o7_char name[/*len0*/], int ofs, int end) {
	struct Container_s *mc = NULL;

	mc = O7_REF(O7_REF(mp)->modules.first)->next;
	while ((mc != O7_REF(mp)->modules.first) && !StringStore_IsEqualToChars(&O7_REF(O7_REF(mc)->m)->_._.name, name_len0, name, ofs, end)) {
		mc = O7_REF(mc)->next;
	}
	return O7_REF(mc)->m;
}

static void AddModule(struct ModuleProvider_s *mp, struct Ast_RModule *m) {
	struct Container_s *mc = NULL;

	O7_ASSERT(O7_REF(m)->_._.module == m);
	O7_NEW(&mc, Container_s);
	O7_REF(mc)->m = m;
	O7_REF(mc)->next = O7_REF(mp)->modules.first;

	O7_REF(O7_REF(mp)->modules.last)->next = mc;
	O7_REF(mp)->modules.last = mc;
}

static struct Ast_RModule *GetModule(struct Ast_RProvider *p, struct Ast_RModule *host, int name_len0, o7_char name[/*len0*/], int ofs, int end);
static struct VFileStream_RIn *GetModule_Open(struct ModuleProvider_s *p, int *pathOfs, int name_len0, o7_char name[/*len0*/], int ofs, int end) {
	o7_char n[1024];
	int len = O7_INT_UNDEF, l = O7_INT_UNDEF;
	struct VFileStream_RIn *in_ = NULL;
	memset(&n, 0, sizeof(n));

	len = StringStore_CalcLen(4096, O7_REF(p)->path, (*pathOfs));
	l = 0;
	if ((o7_cmp(len, 0) >  0) && StringStore_CopyChars(1024, n, &l, 4096, O7_REF(p)->path, (*pathOfs), o7_add((*pathOfs), len)) && StringStore_CopyCharsNull(1024, n, &l, 2, pathSep) && StringStore_CopyChars(1024, n, &l, name_len0, name, ofs, end) && StringStore_CopyChars(1024, n, &l, 32, O7_REF(p)->fileExt, 0, O7_REF(p)->extLen)) {
		in_ = VFileStream_OpenIn(1024, n);
	} else {
		in_ = NULL;
	}
	(*pathOfs) = o7_add(o7_add((*pathOfs), len), 1);
	return in_;
}

static struct Ast_RModule *GetModule(struct Ast_RProvider *p, struct Ast_RModule *host, int name_len0, o7_char name[/*len0*/], int ofs, int end) {
	struct Ast_RModule *m = NULL;
	struct VFileStream_RIn *source = NULL;
	struct ModuleProvider_s *mp = NULL;
	int pathOfs = O7_INT_UNDEF, pathInd = O7_INT_UNDEF;

	mp = O7_GUARD(ModuleProvider_s, &p);
	m = SearchModule(mp, name_len0, name, ofs, end);
	if (m != NULL) {
		Log_StrLn(55, (o7_char *)"Найден уже разобранный модуль");
	} else {
		pathInd =  - 1;
		pathOfs = 0;
		do {
			source = GetModule_Open(mp, &pathOfs, name_len0, name, ofs, end);
			pathInd = o7_add(pathInd, 1);
		} while (!((source != NULL) || (O7_REF(mp)->path[o7_ind(4096, pathOfs)] == 0x00u)));
		if (source != NULL) {
			m = Parser_Parse(&source->_, p, &O7_REF(mp)->opt);
			if (o7_in(pathInd, O7_REF(mp)->sing)) {
				O7_REF(m)->_._.mark = true;
			}
			VFileStream_CloseIn(&source);
		} else {
			MessageEn_Text(36, (o7_char *)"Can not found or open file of module");
			Out_Ln();
		}
	}
	return m;
}

static void RegModule(struct Ast_RProvider *p, struct Ast_RModule *m) {
	Log_Str(10, (o7_char *)"RegModule ");
	Log_StrLn(StringStore_BlockSize_cnst + 1, O7_REF(O7_REF(m)->_._.name.block)->s);
	AddModule(O7_GUARD(ModuleProvider_s, &p), m);
}

static int OpenCOutput(struct VFileStream_ROut **interface_, struct VFileStream_ROut **implementation, struct Ast_RModule *module, o7_bool isMain, int dir_len0, o7_char dir[/*len0*/], int dirLen, struct PlatformExec_Code *exec) {
	int destLen = O7_INT_UNDEF, ret = O7_INT_UNDEF;

	(*interface_) = NULL;
	(*implementation) = NULL;
	destLen = o7_int(dirLen);
	if (!StringStore_CopyCharsNull(dir_len0, dir, &destLen, 2, pathSep) || !StringStore_CopyToChars(dir_len0, dir, &destLen, &O7_REF(module)->_._.name) || (o7_cmp(destLen, o7_sub(dir_len0, 3)) >  0)) {
		ret = CliParser_ErrTooLongOutName_cnst;
	} else {
		dir[o7_ind(dir_len0, destLen)] = (o7_char)'.';
		dir[o7_ind(dir_len0, o7_add(destLen, 2))] = 0x00u;
		if (!o7_bl(isMain)) {
			dir[o7_ind(dir_len0, o7_add(destLen, 1))] = (o7_char)'h';
			(*interface_) = VFileStream_OpenOut(dir_len0, dir);
		}
		if (!o7_bl(isMain) && ((*interface_) == NULL)) {
			ret = CliParser_ErrOpenH_cnst;
		} else {
			dir[o7_ind(dir_len0, o7_add(destLen, 1))] = (o7_char)'c';
			/* TODO */
			O7_ASSERT(PlatformExec_Add(&(*exec), dir_len0, dir, 0));
			Log_StrLn(dir_len0, dir);
			(*implementation) = VFileStream_OpenOut(dir_len0, dir);
			if ((*implementation) == NULL) {
				VFileStream_CloseOut(&(*interface_));
				ret = CliParser_ErrOpenC_cnst;
			} else {
				ret = ErrNo_cnst;
			}
		}
	}
	return o7_int(ret);
}

static void NewProvider(struct ModuleProvider_s **mp) {
	O7_NEW(&(*mp), ModuleProvider_s);
	Ast_ProviderInit(&(*mp)->_, GetModule, RegModule);
	Parser_DefaultOptions(&O7_REF((*mp))->opt);
	O7_REF((*mp))->opt.printError = ErrorMessage;
	O7_REF((*mp))->extLen = 0;

	O7_NEW(&O7_REF((*mp))->modules.first, Container_s);
	O7_REF(O7_REF((*mp))->modules.first)->m = NULL;
	O7_REF(O7_REF((*mp))->modules.first)->next = O7_REF((*mp))->modules.first;
	O7_REF((*mp))->modules.last = O7_REF((*mp))->modules.first;
}

static int GenerateC(struct Ast_RModule *module, o7_bool isMain, struct Ast_Call_s *cmd, struct GeneratorC_Options_s *opt, int dir_len0, o7_char dir[/*len0*/], int dirLen, int cDirs_len0, o7_char cDirs[/*len0*/], struct PlatformExec_Code *exec) {
	struct Ast_RDeclaration *imp = NULL;
	int ret = O7_INT_UNDEF, i = O7_INT_UNDEF, cDirsLen = O7_INT_UNDEF, nameLen = O7_INT_UNDEF;
	o7_char name[512];
	struct VFileStream_ROut *iface = NULL, *impl = NULL;
	memset(&name, 0, sizeof(name));

	O7_REF(module)->_._.used = true;

	ret = ErrNo_cnst;
	imp = (&(O7_REF(module)->import_)->_);
	while ((o7_cmp(ret, ErrNo_cnst) ==  0) && (imp != NULL) && (o7_is(imp, Ast_Import_s_tag))) {
		if (!o7_bl(O7_REF(O7_REF(imp)->module)->_._.used)) {
			ret = GenerateC(O7_REF(imp)->module, false, NULL, opt, dir_len0, dir, dirLen, cDirs_len0, cDirs, &(*exec));
		}
		imp = O7_REF(imp)->next;
	}
	if (o7_cmp(ret, ErrNo_cnst) !=  0) {
	} else if (!o7_bl(O7_REF(module)->_._.mark)) {
		ret = OpenCOutput(&iface, &impl, module, isMain, dir_len0, dir, dirLen, &(*exec));
		if (o7_cmp(ret, ErrNo_cnst) ==  0) {
			GeneratorC_Generate(&iface->_, &impl->_, module, &cmd->_, opt);
			VFileStream_CloseOut(&iface);
			VFileStream_CloseOut(&impl);
		}
	} else {
		i = 0;
		while (cDirs[o7_ind(cDirs_len0, i)] != 0x00u) {
			nameLen = 0;
			cDirsLen = StringStore_CalcLen(cDirs_len0, cDirs, i);
			/* TODO */
			O7_ASSERT(StringStore_CopyChars(512, name, &nameLen, cDirs_len0, cDirs, i, o7_add(i, cDirsLen)) && StringStore_CopyCharsNull(512, name, &nameLen, 2, pathSep) && StringStore_CopyToChars(512, name, &nameLen, &O7_REF(module)->_._.name) && StringStore_CopyCharsNull(512, name, &nameLen, 2, (o7_char *)".c") && (!CFiles_Exist(512, name, 0) || PlatformExec_Add(&(*exec), 512, name, 0)));
			i = o7_add(o7_add(i, cDirsLen), 1);
		}
	}
	return o7_int(ret);
}

static o7_bool MakeDir(int name_len0, o7_char name[/*len0*/]) {
	struct PlatformExec_Code cmd;
	PlatformExec_Code_undef(&cmd);

	if (o7_bl(Platform_Posix)) {
		O7_ASSERT(PlatformExec_Init(&cmd, 5, (o7_char *)"mkdir") && PlatformExec_Add(&cmd, name_len0, name, 0) && PlatformExec_AddClean(&cmd, 12, (o7_char *)" 2>/dev/null"));
	} else if (o7_bl(Platform_Windows)) {
		O7_ASSERT(PlatformExec_Init(&cmd, 5, (o7_char *)"mkdir") && PlatformExec_Add(&cmd, name_len0, name, 0));
	}
	return o7_cmp(PlatformExec_Do(&cmd), PlatformExec_Ok_cnst) ==  0;
}

static o7_bool RemoveDir(int name_len0, o7_char name[/*len0*/]) {
	struct PlatformExec_Code cmd;
	PlatformExec_Code_undef(&cmd);

	if (o7_bl(Platform_Posix)) {
		O7_ASSERT(PlatformExec_Init(&cmd, 2, (o7_char *)"rm") && PlatformExec_Add(&cmd, 2, (o7_char *)"-r", 0) && PlatformExec_Add(&cmd, name_len0, name, 0) && PlatformExec_AddClean(&cmd, 12, (o7_char *)" 2>/dev/null"));
	} else if (o7_bl(Platform_Windows)) {
		O7_ASSERT(PlatformExec_Init(&cmd, 5, (o7_char *)"rmdir") && PlatformExec_AddClean(&cmd, 5, (o7_char *)" /s/q") && PlatformExec_Add(&cmd, name_len0, name, 0));
	}
	return o7_cmp(PlatformExec_Do(&cmd), PlatformExec_Ok_cnst) ==  0;
}

static o7_bool GetTempOutC(int dirCOut_len0, o7_char dirCOut[/*len0*/], int *len, int bin_len0, o7_char bin[/*len0*/], struct StringStore_String *name, int tmp_len0, o7_char tmp[/*len0*/]) {
	int binLen = O7_INT_UNDEF, i = O7_INT_UNDEF;
	o7_bool ok = O7_BOOL_UNDEF;

	(*len) = 0;
	if (o7_strcmp(tmp_len0, tmp, 0, (o7_char *)"") != 0) {
		ok = true;
		O7_ASSERT(StringStore_CopyCharsNull(dirCOut_len0, dirCOut, &(*len), tmp_len0, tmp));
	} else if (o7_bl(Platform_Posix)) {
		ok = true;
		O7_ASSERT(StringStore_CopyCharsNull(dirCOut_len0, dirCOut, &(*len), 9, (o7_char *)"/tmp/o7c-") && StringStore_CopyToChars(dirCOut_len0, dirCOut, &(*len), &(*name)));
	} else if (o7_bl(Platform_Windows)) {
		ok = OsEnv_Get(dirCOut_len0, dirCOut, &(*len), 4, (o7_char *)"temp") && StringStore_CopyCharsNull(dirCOut_len0, dirCOut, &(*len), 5, (o7_char *)"\\o7c-") && StringStore_CopyToChars(dirCOut_len0, dirCOut, &(*len), &(*name));
	}

	if (o7_bl(ok)) {
		i = 0;
		ok = MakeDir(dirCOut_len0, dirCOut);
		if (!o7_bl(ok) && (o7_strcmp(tmp_len0, tmp, 0, (o7_char *)"") == 0)) {
			while (!o7_bl(ok) && (o7_cmp(i, 100) <  0)) {
				if (o7_cmp(i, 0) ==  0) {
					O7_ASSERT(StringStore_CopyCharsNull(dirCOut_len0, dirCOut, &(*len), 3, (o7_char *)"-00"));
				} else {
					dirCOut[o7_ind(dirCOut_len0, o7_sub((*len), 2))] = o7_chr(o7_add((int)(o7_char)'0', o7_div(i, 10)));
					dirCOut[o7_ind(dirCOut_len0, o7_sub((*len), 1))] = o7_chr(o7_add((int)(o7_char)'0', o7_mod(i, 10)));
				}
				ok = MakeDir(dirCOut_len0, dirCOut);
				i = o7_add(i, 1);
			}
		}
		if (o7_bl(ok) && (bin[0] == 0x00u)) {
			binLen = 0;
			O7_ASSERT(StringStore_CopyCharsNull(bin_len0, bin, &binLen, dirCOut_len0, dirCOut) && StringStore_CopyCharsNull(bin_len0, bin, &binLen, 2, pathSep) && StringStore_CopyToChars(bin_len0, bin, &binLen, &(*name)) && (!o7_bl(Platform_Windows) || StringStore_CopyCharsNull(bin_len0, bin, &binLen, 4, (o7_char *)".exe")));
		}
	}
	return o7_bl(ok);
}

static int ToC(int res);
static int ToC_Bin(struct Ast_RModule *module, struct Ast_Call_s *call, struct GeneratorC_Options_s *opt, int cDirs_len0, o7_char cDirs[/*len0*/], int cc_len0, o7_char cc[/*len0*/], int outC_len0, o7_char outC[/*len0*/], int bin_len0, o7_char bin[/*len0*/], struct PlatformExec_Code *cmd, int tmp_len0, o7_char tmp[/*len0*/]) {
	int outCLen = O7_INT_UNDEF, ret = O7_INT_UNDEF, i = O7_INT_UNDEF, nameLen = O7_INT_UNDEF, cDirsLen = O7_INT_UNDEF;
	o7_bool ok = O7_BOOL_UNDEF;
	o7_char name[512];
	memset(&name, 0, sizeof(name));

	ok = GetTempOutC(outC_len0, outC, &outCLen, bin_len0, bin, &O7_REF(module)->_._.name, tmp_len0, tmp);
	if (!o7_bl(ok)) {
		ret = CliParser_ErrCantCreateOutDir_cnst;
	} else {
		if (cc[0] == 0x00u) {
			ok = PlatformExec_AddClean(&(*cmd), 9, (o7_char *)"cc -g -O1");
		} else {
			ok = PlatformExec_AddClean(&(*cmd), cc_len0, cc);
		}
		ret = GenerateC(module, true, call, opt, outC_len0, outC, outCLen, cDirs_len0, cDirs, &(*cmd));
		outC[o7_ind(outC_len0, outCLen)] = 0x00u;
		if (o7_cmp(ret, ErrNo_cnst) ==  0) {
			ok = o7_bl(ok) && PlatformExec_Add(&(*cmd), 2, (o7_char *)"-o", 0) && PlatformExec_Add(&(*cmd), bin_len0, bin, 0) && PlatformExec_Add(&(*cmd), 2, (o7_char *)"-I", 0) && PlatformExec_Add(&(*cmd), outC_len0, outC, 0);
			i = 0;
			while (o7_bl(ok) && (cDirs[o7_ind(cDirs_len0, i)] != 0x00u)) {
				nameLen = 0;
				cDirsLen = StringStore_CalcLen(cDirs_len0, cDirs, i);
				ok = PlatformExec_Add(&(*cmd), 2, (o7_char *)"-I", 0) && PlatformExec_Add(&(*cmd), cDirs_len0, cDirs, i) && StringStore_CopyChars(512, name, &nameLen, cDirs_len0, cDirs, i, o7_add(i, cDirsLen)) && StringStore_CopyCharsNull(512, name, &nameLen, 2, pathSep) && StringStore_CopyCharsNull(512, name, &nameLen, 4, (o7_char *)"o7.c") && (!CFiles_Exist(512, name, 0) || PlatformExec_Add(&(*cmd), 512, name, 0));
				i = o7_add(o7_add(i, cDirsLen), 1);
			}
			ok = o7_bl(ok) && (!o7_bl(Platform_Posix) || PlatformExec_Add(&(*cmd), 3, (o7_char *)"-lm", 0));
			PlatformExec_Log(&(*cmd));
			/* TODO */
			O7_ASSERT(o7_bl(ok));
			if (o7_cmp(PlatformExec_Do(&(*cmd)), PlatformExec_Ok_cnst) !=  0) {
				ret = CliParser_ErrCCompiler_cnst;
			}
		}
	}
	return o7_int(ret);
}

static int ToC_Run(int bin_len0, o7_char bin[/*len0*/], int arg) {
	struct PlatformExec_Code cmd;
	o7_char buf[65536];
	int len = O7_INT_UNDEF, ret = O7_INT_UNDEF;
	PlatformExec_Code_undef(&cmd);
	memset(&buf, 0, sizeof(buf));

	ret = CliParser_ErrTooLongRunArgs_cnst;
	if (PlatformExec_Init(&cmd, bin_len0, bin)) {
		arg = o7_add(arg, 1);
		len = 0;
		while ((o7_cmp(arg, CLI_count) <  0) && CLI_Get(65536, buf, &len, arg) && PlatformExec_Add(&cmd, 65536, buf, 0)) {
			len = 0;
			arg = o7_add(arg, 1);
		}
		if (o7_cmp(arg, CLI_count) >=  0) {
			CLI_SetExitCode(PlatformExec_Do(&cmd));
			ret = ErrNo_cnst;
		}
	}
	return o7_int(ret);
}

static int ToC_ParseCommand(int src_len0, o7_char src[/*len0*/], o7_bool *script);
static void ToC_ParseCommand_Empty(int src_len0, o7_char src[/*len0*/], int *j) {
	while ((src[o7_ind(src_len0, (*j))] == (o7_char)' ') || (src[o7_ind(src_len0, (*j))] == 0x09u)) {
		(*j) = o7_add((*j), 1);
	}
}

static int ToC_ParseCommand(int src_len0, o7_char src[/*len0*/], o7_bool *script) {
	int i = O7_INT_UNDEF, j = O7_INT_UNDEF;

	i = 0;
	while ((src[o7_ind(src_len0, i)] != 0x00u) && (src[o7_ind(src_len0, i)] != (o7_char)'.')) {
		i = o7_add(i, 1);
	}
	if (src[o7_ind(src_len0, i)] == (o7_char)'.') {
		j = o7_add(i, 1);
		ToC_ParseCommand_Empty(src_len0, src, &j);
		while (((o7_char)'a' <= src[o7_ind(src_len0, j)]) && (src[o7_ind(src_len0, j)] <= (o7_char)'z') || ((o7_char)'A' <= src[o7_ind(src_len0, j)]) && (src[o7_ind(src_len0, j)] <= (o7_char)'Z') || ((o7_char)'0' <= src[o7_ind(src_len0, j)]) && (src[o7_ind(src_len0, j)] <= (o7_char)'9')) {
			j = o7_add(j, 1);
		}
		ToC_ParseCommand_Empty(src_len0, src, &j);
		(*script) = src[o7_ind(src_len0, j)] != 0x00u;
	} else {
		(*script) = false;
	}
	return o7_int(i);
}

static int ToC(int res) {
	int ret = O7_INT_UNDEF;
	o7_char src[65536];
	int srcLen = O7_INT_UNDEF, srcNameEnd = O7_INT_UNDEF;
	o7_char outC[1024], resPath[1024], tmp[1024];
	int resPathLen = O7_INT_UNDEF;
	o7_char cDirs[4096], cc[4096];
	struct ModuleProvider_s *mp = NULL;
	struct Ast_RModule *module = NULL;
	struct GeneratorC_Options_s *opt = NULL;
	int init = O7_INT_UNDEF, arg = O7_INT_UNDEF;
	struct Ast_Call_s *call = NULL;
	o7_bool script = O7_BOOL_UNDEF;
	struct PlatformExec_Code exec;
	memset(&src, 0, sizeof(src));
	memset(&outC, 0, sizeof(outC));
	memset(&resPath, 0, sizeof(resPath));
	memset(&tmp, 0, sizeof(tmp));
	memset(&cDirs, 0, sizeof(cDirs));
	memset(&cc, 0, sizeof(cc));
	PlatformExec_Code_undef(&exec);

	O7_ASSERT(o7_in(res, O7_SET(ResultC_cnst, ResultRun_cnst)));

	srcLen = 0;
	arg = o7_add(3, (int)(o7_cmp(res, ResultRun_cnst) !=  0));
	if (o7_cmp(CLI_count, arg) <  0) {
		ret = CliParser_ErrNotEnoughArgs_cnst;
	} else if (!CLI_Get(65536, src, &srcLen, 2)) {
		ret = CliParser_ErrTooLongSourceName_cnst;
	} else {
		NewProvider(&mp);
		memcpy(O7_REF(mp)->fileExt, (o7_char *)".mod", sizeof(".mod"));
		/* TODO */
		O7_REF(mp)->extLen = StringStore_CalcLen(32, O7_REF(mp)->fileExt, 0);
		ret = CopyPath(4096, O7_REF(mp)->path, &O7_REF(mp)->sing, 4096, cDirs, 4096, cc, &init, 1024, tmp, &arg);
		if (o7_cmp(ret, ErrNo_cnst) ==  0) {
			srcNameEnd = ToC_ParseCommand(65536, src, &script);
			if (o7_bl(script)) {
				module = Parser_Script(65536, src, &mp->_, &O7_REF(mp)->opt);
				AddModule(mp, module);
			} else {
				module = GetModule(&mp->_, NULL, 65536, src, 0, srcNameEnd);
			}
			resPathLen = 0;
			resPath[0] = 0x00u;
			if (module == NULL) {
				ret = ErrParse_cnst;
			} else if (O7_REF(module)->errors != NULL) {
				PrintErrors(O7_REF(O7_REF(mp)->modules.first)->next);
				ret = ErrParse_cnst;
			} else if ((o7_cmp(res, ResultRun_cnst) !=  0) && !CLI_Get(1024, resPath, &resPathLen, 3)) {
				ret = CliParser_ErrTooLongOutName_cnst;
			} else {
				if (!o7_bl(script) && (o7_cmp(srcNameEnd, o7_sub(srcLen, 1)) <  0)) {
					ret = Ast_CommandGet(&call, module, 65536, src, o7_add(srcNameEnd, 1), o7_sub(srcLen, 1));
				} else {
					call = NULL;
				}
				if (o7_cmp(ret, Ast_ErrNo_cnst) !=  0) {
					MessageEn_AstError(ret);
					Out_Ln();
					ret = ErrParse_cnst;
				} else {
					opt = GeneratorC_DefaultOptions();
					if (o7_cmp(init, 0) >=  0) {
						O7_REF(opt)->varInit = o7_int(init);
					}
					O7_ASSERT(PlatformExec_Init(&exec, 0, (o7_char *)""));
					switch (res) {
					case 0:
						resPathLen = o7_sub(resPathLen, 1);
						ret = GenerateC(module, (call != NULL) || o7_bl(script), call, opt, 1024, resPath, resPathLen, 4096, cDirs, &exec);
						break;
					case 1:
					case 2:
						ret = ToC_Bin(module, call, opt, 4096, cDirs, 4096, cc, 1024, outC, 1024, resPath, &exec, 1024, tmp);
						if ((o7_cmp(res, ResultRun_cnst) ==  0) && (o7_cmp(ret, ErrNo_cnst) ==  0)) {
							ret = ToC_Run(1024, resPath, arg);
						}
						if ((o7_strcmp(1024, tmp, 0, (o7_char *)"") == 0) && !RemoveDir(1024, outC) && (o7_cmp(ret, ErrNo_cnst) ==  0)) {
							ret = CliParser_ErrCantRemoveOutDir_cnst;
						}
						break;
					default:
						abort();
						break;
					}
				}
			}
		}
	}
	return o7_int(ret);
}

static void Translator_Start(void) {
	o7_char cmd[1024];
	int cmdLen = O7_INT_UNDEF, ret = O7_INT_UNDEF;
	memset(&cmd, 0, sizeof(cmd));

	Out_Open();
	Log_Turn(false);

	cmdLen = 0;
	if ((o7_cmp(CLI_count, 1) <=  0) || !CLI_Get(1024, cmd, &cmdLen, 1)) {
		ret = CliParser_ErrWrongArgs_cnst;
	} else {
		if (o7_strcmp(1024, cmd, 4, (o7_char *)"help") == 0) {
			ret = ErrNo_cnst;
			MessageEn_Usage();
			Out_Ln();
		} else if (o7_strcmp(1024, cmd, 4, (o7_char *)"to-c") == 0) {
			ret = ToC(ResultC_cnst);
		} else if (o7_strcmp(1024, cmd, 6, (o7_char *)"to-bin") == 0) {
			ret = ToC(ResultBin_cnst);
		} else if (o7_strcmp(1024, cmd, 3, (o7_char *)"run") == 0) {
			ret = ToC(ResultRun_cnst);
		} else {
			ret = CliParser_ErrUnknownCommand_cnst;
		}
	}
	if (o7_cmp(ret, ErrNo_cnst) !=  0) {
		CLI_SetExitCode(1);
		if (o7_cmp(ret, ErrParse_cnst) !=  0) {
			MessageEn_CliError(ret, 1024, cmd);
		}
	}
}

extern int main(int argc, char *argv[]) {
	o7_init(argc, argv);
	Log_init();
	Out_init();
	CLI_init();
	VDataStream_init();
	VFileStream_init();
	Utf8_init();
	StringStore_init();
	Parser_init();
	Scanner_init();
	Ast_init();
	GeneratorC_init();
	TranslatorLimits_init();
	PlatformExec_init();
	MessageEn_init();
	CliParser_init();
	Platform_init();
	CFiles_init();
	OsEnv_init();

	o7_tag_init(ModuleProvider_s_tag, Ast_RProvider_tag);

	if (o7_bl(Platform_Posix)) {
		memcpy(pathSep, (o7_char *)"\x2F", 1);
	} else if (o7_bl(Platform_Windows)) {
		memcpy(pathSep, (o7_char *)"\x5C", 1);
	} else {
		O7_ASSERT(false);
	}
	Translator_Start();
	return o7_exit_code;
}
