/* Generated by Vostok - Oberon-07 translator */

#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <assert.h>
#include <math.h>
#include <stdbool.h>

#define O7C_BOOL_UNDEFINED
#include <o7c.h>

#include "MessageEn.h"

static void O(int s_len0, o7c_char s[/*len0*/]) {
	Out_String(s_len0, s);
}

static void S(int s_len0, o7c_char s[/*len0*/]) {
	Out_String(s_len0, s);
	Out_Ln();
}

extern void MessageEn_AstError(int code) {
	switch (code) {
	case -1:
		O(47, (o7c_char *)"Module name already declare in the import list");
		break;
	case -89:
		O(21, (o7c_char *)"Module import itself");
		break;
	case -90:
		O(39, (o7c_char *)"Cyclic import of modules is prohibited");
		break;
	case -2:
		O(40, (o7c_char *)"Redeclaration of name in the same scope");
		break;
	case -8:
		O(47, (o7c_char *)"Declaration's name shadow module's declaration");
		break;
	case -3:
		O(38, (o7c_char *)"Subexpressions types are incompatible");
		break;
	case -4:
		O(50, (o7c_char *)"Subexpressions types in division are incompatible");
		break;
	case -5:
		O(61, (o7c_char *)"In a logic expression must be subexpressions of boolean type");
		break;
	case -6:
		O(58, (o7c_char *)"In integer division available only integer subexpressions");
		break;
	case -7:
		O(68, (o7c_char *)"In a float point division available only float point subexpressions");
		break;
	case -9:
		O(30, (o7c_char *)"Set can contain only integers");
		break;
	case -10:
		O(46, (o7c_char *)"Item's  value of set out of range - [0 .. 31]");
		break;
	case -11:
		O(42, (o7c_char *)"Left item of range bigger then right item");
		break;
	case -12:
		O(45, (o7c_char *)"Subexpressions types in sum are incompatible");
		break;
	case -13:
		S(53, (o7c_char *)"In expressions *, / available only numbers and sets.");
		O(38, (o7c_char *)"DIV, MOD applicable only for integers");
		break;
	case -14:
		O(51, (o7c_char *)"In expresions +, - available only numbers and sets");
		break;
	case -15:
		O(40, (o7c_char *)"Unary sign not applicable to logic type");
		break;
	case -17:
		O(54, (o7c_char *)"Subexpressions types in comparison are not compatible");
		break;
	case -18:
		O(24, (o7c_char *)"Ast.ErrExprInWrongTypes");
		break;
	case -19:
		O(25, (o7c_char *)"Ast.ErrExprInRightNotSet");
		break;
	case -20:
		O(41, (o7c_char *)"Left subexpression of IN must be integer");
		break;
	case -21:
		O(37, (o7c_char *)"Relation not applicable to such type");
		break;
	case -22:
		O(30, (o7c_char *)"IS applicable only to records");
		break;
	case -23:
		O(47, (o7c_char *)"Left part of IS be record or pointer to record");
		break;
	case -24:
		O(56, (o7c_char *)"Constant declaration matched to not constant expression");
		break;
	case -25:
		O(33, (o7c_char *)"Incompatible types in assignment");
		break;
	case -84:
		O(43, (o7c_char *)"Expected variable expression in assignment");
		break;
	case -26:
		O(61, (o7c_char *)"Call applicable only to procedures and procedure's variables");
		break;
	case -28:
		O(34, (o7c_char *)"Returned value can not be ignored");
		break;
	case -27:
		O(34, (o7c_char *)"Called procedure not return value");
		break;
	case -29:
		O(36, (o7c_char *)"Excess parameters in procedure call");
		break;
	case -30:
		O(30, (o7c_char *)"Incompatible parameter's type");
		break;
	case -31:
		O(27, (o7c_char *)"Parameter must be variable");
		break;
	case -58:
		O(65, (o7c_char *)"For variable parameter - pointer must used argument of same type");
		break;
	case -32:
		O(43, (o7c_char *)"Not enough parameters in call of procedure");
		break;
	case -33:
		O(43, (o7c_char *)"Expression in CASE must be integer or char");
		break;
	case -34:
		O(38, (o7c_char *)"Label of CASE must be integer or char");
		break;
	case -36:
		O(40, (o7c_char *)"Values of labels of CASE are duplicated");
		break;
	case -37:
		O(38, (o7c_char *)"Types of labels in CASE are not equal");
		break;
	case -38:
		O(65, (o7c_char *)"Left part of range in label of CASE must be less than right part");
		break;
	case -39:
		O(32, (o7c_char *)"Labels in CASE must be constant");
		break;
	case -40:
		O(26, (o7c_char *)"Procedure have not return");
		break;
	case -41:
		O(76, (o7c_char *)"Type of expression in return is not compatible with declared type in header");
		break;
	case -42:
		O(16, (o7c_char *)"Expected return");
		break;
	case -43:
		O(21, (o7c_char *)"Declaraion not found");
		break;
	case -44:
		O(41, (o7c_char *)"Recursive declaration of constant denied");
		break;
	case -45:
		O(26, (o7c_char *)"Imported module not found");
		break;
	case -46:
		O(33, (o7c_char *)"Imported module contain mistakes");
		break;
	case -47:
		O(40, (o7c_char *)"Dereference applicable only to pointers");
		break;
	case -91:
		O(27, (o7c_char *)"Array's length must be > 0");
		break;
	case -92:
		O(32, (o7c_char *)"Overall length of array too big");
		break;
	case -48:
		O(35, (o7c_char *)"[ index ] applicable only to array");
		break;
	case -49:
		O(27, (o7c_char *)"Array index is not integer");
		break;
	case -50:
		O(21, (o7c_char *)"Negative array index");
		break;
	case -51:
		O(25, (o7c_char *)"Array index out of range");
		break;
	case -52:
		O(41, (o7c_char *)"In type's guard expected extended record");
		break;
	case -53:
		O(52, (o7c_char *)"In type's guard expected pointer to extended record");
		break;
	case -54:
		O(68, (o7c_char *)"In a type's guard must be designator of record or pointer to record");
		break;
	case -55:
		O(61, (o7c_char *)"Selector '.' applicable only to record and pointer to record");
		break;
	case -56:
		O(18, (o7c_char *)"Expected variable");
		break;
	case -57:
		O(27, (o7c_char *)"Iterato of FOR not integer");
		break;
	case -59:
		O(41, (o7c_char *)"Expression in IF must be of boolean type");
		break;
	case -60:
		O(44, (o7c_char *)"Expression in WHILE must be of boolean type");
		break;
	case -61:
		O(33, (o7c_char *)"Expression in WHILE always false");
		break;
	case -62:
		O(61, (o7c_char *)"WHILE loop is indefinite becase guard expression always true");
		break;
	case -63:
		O(44, (o7c_char *)"Expression in UNTIL must be of boolean type");
		break;
	case -64:
		O(55, (o7c_char *)"Loop is indefinite because of end condion always false");
		break;
	case -65:
		O(25, (o7c_char *)"End conditin always true");
		break;
	case -66:
		O(28, (o7c_char *)"Declaration is not exported");
		break;
	case -67:
		O(51, (o7c_char *)"Logic negative ~ applicable only to boolean values");
		break;
	case -69:
		O(26, (o7c_char *)"Overflow in constants sum");
		break;
	case 68:
		O(33, (o7c_char *)"Overflow in constants difference");
		break;
	case -71:
		O(37, (o7c_char *)"Overflow in constants multiplication");
		break;
	case -72:
		O(17, (o7c_char *)"Division by zero");
		break;
	case -73:
		O(26, (o7c_char *)"Value out of byte's range");
		break;
	case -74:
		O(26, (o7c_char *)"Value out of char's range");
		break;
	case -75:
		O(28, (o7c_char *)"Expected integer expression");
		break;
	case -76:
		O(37, (o7c_char *)"Expected constant integer expression");
		break;
	case -77:
		O(29, (o7c_char *)"Iterator's step can not be 0");
		break;
	case -78:
		O(61, (o7c_char *)"For enumeration from low to high iterator's step must be > 0");
		break;
	case -79:
		O(61, (o7c_char *)"For enumeration from low to high iterator's step must be < 0");
		break;
	case -80:
		O(29, (o7c_char *)"Iterator in FOR can overflow");
		break;
	case -81:
		O(29, (o7c_char *)"Using uninitialized variable");
		break;
	case -82:
		O(27, (o7c_char *)"Expected name of procedure");
		break;
	case -83:
		O(43, (o7c_char *)"As command can be procedure without return");
		break;
	case -85:
		O(47, (o7c_char *)"As command can be procedure without parameters");
		break;
	case -86:
		O(41, (o7c_char *)"Returned type can not be array or record");
		break;
	case -87:
		O(58, (o7c_char *)"Exist undeclared record, previously referenced in pointer");
		break;
	case -88:
		O(37, (o7c_char *)"Pointer can reference only to record");
		break;
	default:
		abort();
		break;
	}
}

extern void MessageEn_ParseError(int code) {
	switch (code) {
	case -1:
		O(24, (o7c_char *)"Unexpected char in text");
		break;
	case -2:
		O(29, (o7c_char *)"Value of constant is too big");
		break;
	case -3:
		O(31, (o7c_char *)"Scale of real value is too big");
		break;
	case -4:
		O(23, (o7c_char *)"Length of word too big");
		break;
	case -5:
		O(69, (o7c_char *)"In end of hexadecimal number expected 'H' for number or 'X' for char");
		break;
	case -6:
		O(10, (o7c_char *)"Expected ");
		O(2, (o7c_char *)"\x22");
		break;
	case -7:
		O(22, (o7c_char *)"ErrExpectDigitInScale");
		break;
	case -8:
		O(17, (o7c_char *)"Unclosed comment");
		break;
	case -101:
		O(18, (o7c_char *)"Expected 'MODULE'");
		break;
	case -102:
		O(14, (o7c_char *)"Expected name");
		break;
	case -103:
		O(13, (o7c_char *)"Expected ':'");
		break;
	case -104:
		O(13, (o7c_char *)"Expected ';'");
		break;
	case -105:
		O(15, (o7c_char *)"Expected 'END'");
		break;
	case -106:
		O(13, (o7c_char *)"Expected '.'");
		break;
	case -107:
		O(29, (o7c_char *)"Expected имя модуля");
		break;
	case -108:
		O(13, (o7c_char *)"Expected '='");
		break;
	case -109:
		O(13, (o7c_char *)"Expected ')'");
		break;
	case -110:
		O(13, (o7c_char *)"Expected ']'");
		break;
	case -111:
		O(13, (o7c_char *)"Expected '}'");
		break;
	case -112:
		O(12, (o7c_char *)"Expected OF");
		break;
	case -115:
		O(12, (o7c_char *)"Expected TO");
		break;
	case -116:
		O(60, (o7c_char *)"Expected structured type: array, record, pointer, procedure");
		break;
	case -117:
		O(16, (o7c_char *)"Expected record");
		break;
	case -118:
		O(19, (o7c_char *)"Expected statement");
		break;
	case -119:
		O(14, (o7c_char *)"Expected THEN");
		break;
	case -120:
		O(12, (o7c_char *)"Expected :=");
		break;
	case -122:
		O(51, (o7c_char *)"Expected variable, which type is record or pointer");
		break;
	case -124:
		O(14, (o7c_char *)"Expected type");
		break;
	case -125:
		O(15, (o7c_char *)"Expected UNTIL");
		break;
	case -126:
		O(12, (o7c_char *)"Expected DO");
		break;
	case -128:
		O(20, (o7c_char *)"Expected designator");
		break;
	case -130:
		O(19, (o7c_char *)"Expected procedure");
		break;
	case -131:
		O(26, (o7c_char *)"Expected name of constant");
		break;
	case -132:
		O(36, (o7c_char *)"Expected procedure's name after end");
		break;
	case -133:
		O(20, (o7c_char *)"Expected expression");
		break;
	case -135:
		O(11, (o7c_char *)"Excess ';'");
		break;
	case -150:
		O(47, (o7c_char *)"Name after end do not match with module's name");
		break;
	case -151:
		O(29, (o7c_char *)"Too many dimensions in array");
		break;
	case -152:
		O(50, (o7c_char *)"Name after end do not match with procedure's name");
		break;
	case -153:
		O(50, (o7c_char *)"Declaration of procedure with return must have ()");
		break;
	case -134:
		O(26, (o7c_char *)"Expected number or string");
		break;
	case -136:
		O(52, (o7c_char *)"Unexpected '='. Maybe, you mean ':=' for assignment");
		break;
	case -137:
		O(49, (o7c_char *)"As label in CASE not accepted not 1 char strings");
		break;
	default:
		abort();
		break;
	}
}

extern void MessageEn_Usage(void) {
	S(8, (o7c_char *)"Usage: ");
	S(14, (o7c_char *)"  1) o7c help");
	S(57, (o7c_char *)"  2) o7c to-c   Script OutDir {-m PTM|-i PTI|-infr Infr}");
	S(75, (o7c_char *)"  3) o7c to-bin Script Result {-m PTM|-i PTI|-infr Infr|-c PTHC|-cc CComp}");
	S(68, (o7c_char *)"  4) o7c run    Script {-m PTM|-i PTI|-c PTHC|-cc CComp} -- options");
	S(67, (o7c_char *)"Script = Call { ; Call } . Call = Module.Procedure[(Parameters)] .");
	S(50, (o7c_char *)"PTM - Path To directories with Modules for search");
	S(77, (o7c_char *)"PTI - Path To directories with Interface Modules without real implementation");
	S(78, (o7c_char *)"PTHC - Path To directories with .H & .C -implementations of interface modules");
	S(59, (o7c_char *)"Infr - path to infrastructure. '-infr p' is shortening to:");
	S(75, (o7c_char *)"  -i p/singularity/definition -c p/singularity/implementation -m p/library");
	S(48, (o7c_char *)"CComp - C Compiler for build generated .c-files");
}

extern void MessageEn_CliError(int err, int cmd_len0, o7c_char cmd[/*len0*/]) {
	switch (err) {
	case -10:
		MessageEn_Usage();
		break;
	case -11:
		S(29, (o7c_char *)"Too long name of source file");
		Out_Ln();
		break;
	case -12:
		S(26, (o7c_char *)"Too long destination name");
		Out_Ln();
		break;
	case -13:
		S(25, (o7c_char *)"Can not open source file");
		break;
	case -14:
		S(33, (o7c_char *)"Can not open destination .h file");
		break;
	case -15:
		S(33, (o7c_char *)"Can not open destination .c file");
		break;
	case -16:
		O(18, (o7c_char *)"Unknown command: ");
		S(cmd_len0, cmd);
		MessageEn_Usage();
		break;
	case -17:
		O(44, (o7c_char *)"Not enough count of arguments for command: ");
		S(cmd_len0, cmd);
		break;
	case -18:
		S(44, (o7c_char *)"Too long overall length of paths to modules");
		break;
	case -19:
		S(26, (o7c_char *)"Too many paths to modules");
		break;
	case -20:
		S(45, (o7c_char *)"Too long overall length of paths to .c files");
		break;
	case -21:
		S(38, (o7c_char *)"Too long length of C compiler options");
		break;
	case -23:
		S(29, (o7c_char *)"Error during C compiler call");
		break;
	case -24:
		S(30, (o7c_char *)"Too long command line options");
		break;
	case -25:
		S(18, (o7c_char *)"Unexpected option");
		break;
	case -26:
		S(30, (o7c_char *)"Unknown initialization method");
		break;
	case -27:
		S(32, (o7c_char *)"Can not create output directory");
		break;
	case -28:
		S(32, (o7c_char *)"Can not remove output directory");
		break;
	default:
		abort();
		break;
	}
}

extern void MessageEn_Text(int str_len0, o7c_char str[/*len0*/]) {
	O(str_len0, str);
}

extern void MessageEn_init(void) {
	static int initialized = 0;
	if (0 == initialized) {
		Ast_init();
		Parser_init();
		CliParser_init();
		Scanner_init();
		Out_init();
		Utf8_init();

	}
	++initialized;
}

