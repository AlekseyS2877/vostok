/* Generated by Vostok - Oberon-07 translator */

#include <stdbool.h>

#define O7_BOOL_UNDEFINED
#include <o7.h>

#include "MessageEn.h"

static void O(int s_len0, o7_char s[/*len0*/]) {
	Out_String(s_len0, s);
}

static void S(int s_len0, o7_char s[/*len0*/]) {
	Out_String(s_len0, s);
	Out_Ln();
}

extern void MessageEn_AstError(int code) {
	switch (code) {
	case -1:
		O(49, (o7_char *)"Module's name already declared in the import list");
		break;
	case -89:
		O(21, (o7_char *)"Module imports itself");
		break;
	case -90:
		O(38, (o7_char *)"Cyclic import of modules is prohibited");
		break;
	case -2:
		O(39, (o7_char *)"Redeclaration of name in the same scope");
		break;
	case -8:
		O(47, (o7_char *)"Declaration's name shadows module's declaration");
		break;
	case -101:
		O(48, (o7_char *)"Declaration's name shadows predefined identifier");
		break;
	case -3:
		O(37, (o7_char *)"Subexpressions types are incompatible");
		break;
	case -4:
		O(49, (o7_char *)"Subexpressions types in division are incompatible");
		break;
	case -5:
		O(60, (o7_char *)"In a logic expression must be subexpressions of boolean type");
		break;
	case -6:
		O(57, (o7_char *)"In integer division available only integer subexpressions");
		break;
	case -7:
		O(67, (o7_char *)"In a float point division available only float point subexpressions");
		break;
	case -9:
		O(29, (o7_char *)"Set can contain only integers");
		break;
	case -10:
		O(47, (o7_char *)"Item's value of set is out of range - [0 .. 31]");
		break;
	case -11:
		O(44, (o7_char *)"Left item of range is bigger then right item");
		break;
	case -35:
		O(53, (o7_char *)"Set, which contain 31 can not be converted to integer");
		break;
	case -12:
		O(44, (o7_char *)"Subexpressions types in sum are incompatible");
		break;
	case -13:
		S(52, (o7_char *)"In expressions *, / available only numbers and sets.");
		O(37, (o7_char *)"DIV, MOD applicable only for integers");
		break;
	case -14:
		O(50, (o7_char *)"In expresions +, - available only numbers and sets");
		break;
	case -15:
		O(39, (o7_char *)"Unary sign not applicable to logic type");
		break;
	case -17:
		O(53, (o7_char *)"Subexpressions types in comparison are not compatible");
		break;
	case -18:
		O(47, (o7_char *)"Left subexpression must be integer, right - Set");
		break;
	case -19:
		O(40, (o7_char *)"Right subexpression after IN must be Set");
		break;
	case -20:
		O(44, (o7_char *)"Left subexpression before IN must be integer");
		break;
	case -21:
		O(36, (o7_char *)"Relation not applicable to such type");
		break;
	case -22:
		O(42, (o7_char *)"IS applicable only to records and pointers");
		break;
	case -23:
		O(46, (o7_char *)"Left part of IS be record or pointer to record");
		break;
	case -93:
		O(68, (o7_char *)"Type of left part of IS expression must be same kind that right type");
		break;
	case -94:
		O(44, (o7_char *)"In right part of IS expected extended record");
		break;
	case -24:
		O(55, (o7_char *)"Constant declaration matched to not constant expression");
		break;
	case -25:
		O(32, (o7_char *)"Incompatible types in assignment");
		break;
	case -84:
		O(42, (o7_char *)"Expected variable expression in assignment");
		break;
	case -26:
		O(62, (o7_char *)"Call applicable only to subroutines and subroutine's variables");
		break;
	case -28:
		O(33, (o7_char *)"Returned value can not be ignored");
		break;
	case -27:
		O(34, (o7_char *)"Called subroutine not return value");
		break;
	case -29:
		O(37, (o7_char *)"Excess parameter in subroutine's call");
		break;
	case -30:
		O(29, (o7_char *)"Incompatible parameter's type");
		break;
	case -31:
		O(26, (o7_char *)"Parameter must be variable");
		break;
	case -58:
		O(64, (o7_char *)"For variable parameter - pointer must used argument of same type");
		break;
	case -32:
		O(42, (o7_char *)"Not enough parameters in subroutine's call");
		break;
	case -33:
		O(42, (o7_char *)"Expression in CASE must be integer or char");
		break;
	case -68:
		O(41, (o7_char *)"Case label must have integer or char type");
		break;
	case -34:
		O(37, (o7_char *)"Label of CASE must be integer or char");
		break;
	case -36:
		O(39, (o7_char *)"Values of labels of CASE are duplicated");
		break;
	case -37:
		O(37, (o7_char *)"Types of labels in CASE are not equal");
		break;
	case -38:
		O(64, (o7_char *)"Left part of range in label of CASE must be less than right part");
		break;
	case -39:
		O(31, (o7_char *)"Labels in CASE must be constant");
		break;
	case -99:
		O(33, (o7_char *)"Else branch in CASE already exist");
		break;
	case -40:
		O(26, (o7_char *)"Subroutine have not return");
		break;
	case -41:
		O(75, (o7_char *)"Type of expression in return is not compatible with declared type in header");
		break;
	case -42:
		O(15, (o7_char *)"Expected return");
		break;
	case -43:
		O(20, (o7_char *)"Declaraion not found");
		break;
	case -44:
		O(40, (o7_char *)"Recursive declaration of constant denied");
		break;
	case -45:
		O(25, (o7_char *)"Imported module not found");
		break;
	case -46:
		O(32, (o7_char *)"Imported module contain mistakes");
		break;
	case -47:
		O(39, (o7_char *)"Dereference applicable only to pointers");
		break;
	case -91:
		O(26, (o7_char *)"Array's length must be > 0");
		break;
	case -92:
		O(31, (o7_char *)"Overall length of array too big");
		break;
	case -48:
		O(34, (o7_char *)"[ index ] applicable only to array");
		break;
	case -49:
		O(26, (o7_char *)"Array index is not integer");
		break;
	case -50:
		O(20, (o7_char *)"Negative array index");
		break;
	case -51:
		O(24, (o7_char *)"Array index out of range");
		break;
	case -52:
		O(40, (o7_char *)"In type's guard expected extended record");
		break;
	case -53:
		O(51, (o7_char *)"In type's guard expected pointer to extended record");
		break;
	case -54:
		O(67, (o7_char *)"In a type's guard must be designator of record or pointer to record");
		break;
	case -55:
		O(60, (o7_char *)"Selector '.' applicable only to record and pointer to record");
		break;
	case -56:
		O(17, (o7_char *)"Expected variable");
		break;
	case -57:
		O(34, (o7_char *)"Iterator of 'FOR'-loop not integer");
		break;
	case -59:
		O(40, (o7_char *)"Expression in IF must be of boolean type");
		break;
	case -60:
		O(43, (o7_char *)"Expression in WHILE must be of boolean type");
		break;
	case -61:
		O(32, (o7_char *)"Expression in WHILE always false");
		break;
	case -62:
		O(60, (o7_char *)"WHILE loop is indefinite becase guard expression always true");
		break;
	case -63:
		O(43, (o7_char *)"Expression in UNTIL must be of boolean type");
		break;
	case -64:
		O(54, (o7_char *)"Loop is indefinite because of end condion always false");
		break;
	case -65:
		O(24, (o7_char *)"End conditin always true");
		break;
	case -66:
		O(27, (o7_char *)"Declaration is not exported");
		break;
	case -67:
		O(50, (o7_char *)"Logic negative ~ applicable only to boolean values");
		break;
	case -69:
		O(25, (o7_char *)"Overflow in constants sum");
		break;
	case -70:
		O(32, (o7_char *)"Overflow in constants difference");
		break;
	case -71:
		O(36, (o7_char *)"Overflow in constants multiplication");
		break;
	case -72:
		O(16, (o7_char *)"Division by zero");
		break;
	case -73:
		O(25, (o7_char *)"Value out of byte's range");
		break;
	case -74:
		O(25, (o7_char *)"Value out of char's range");
		break;
	case -75:
		O(27, (o7_char *)"Expected integer expression");
		break;
	case -76:
		O(36, (o7_char *)"Expected constant integer expression");
		break;
	case -77:
		O(28, (o7_char *)"Iterator's step can not be 0");
		break;
	case -78:
		O(60, (o7_char *)"For enumeration from low to high iterator's step must be > 0");
		break;
	case -79:
		O(60, (o7_char *)"For enumeration from low to high iterator's step must be < 0");
		break;
	case -80:
		O(28, (o7_char *)"Iterator in FOR can overflow");
		break;
	case -81:
		O(28, (o7_char *)"Using uninitialized variable");
		break;
	case -82:
		O(26, (o7_char *)"Expected name of procedure");
		break;
	case -83:
		O(43, (o7_char *)"As command can be subroutine without return");
		break;
	case -85:
		O(47, (o7_char *)"As command can be subroutine without parameters");
		break;
	case -86:
		O(40, (o7_char *)"Returned type can not be array or record");
		break;
	case -87:
		O(57, (o7_char *)"Exist undeclared record, previously referenced in pointer");
		break;
	case -88:
		O(36, (o7_char *)"Pointer can reference only to record");
		break;
	case -95:
		O(22, (o7_char *)"Assertion always false");
		break;
	case -96:
		O(60, (o7_char *)"Declared variable which type is incompletely declared record");
		break;
	case -97:
		O(56, (o7_char *)"Incompletely declared record is used as subtype of array");
		break;
	case -98:
		O(37, (o7_char *)"Exist unused declaration in the scope");
		break;
	case 102:
		O(31, (o7_char *)"Too deep nesting of subroutines");
		break;
	default:
		abort();
		break;
	}
}

extern void MessageEn_ParseError(int code) {
	switch (code) {
	case -1:
		O(23, (o7_char *)"Unexpected char in text");
		break;
	case -2:
		O(28, (o7_char *)"Value of constant is too big");
		break;
	case -3:
		O(30, (o7_char *)"Scale of real value is too big");
		break;
	case -4:
		O(22, (o7_char *)"Length of word too big");
		break;
	case -5:
		O(68, (o7_char *)"In end of hexadecimal number expected 'H' for number or 'X' for char");
		break;
	case -6:
		O(9, (o7_char *)"Expected ");
		O(1, (o7_char *)"\x22");
		break;
	case -7:
		O(21, (o7_char *)"ErrExpectDigitInScale");
		break;
	case -8:
		O(16, (o7_char *)"Unclosed comment");
		break;
	case -101:
		O(17, (o7_char *)"Expected 'MODULE'");
		break;
	case -102:
		O(13, (o7_char *)"Expected name");
		break;
	case -103:
		O(12, (o7_char *)"Expected ':'");
		break;
	case -104:
		O(12, (o7_char *)"Expected ';'");
		break;
	case -105:
		O(14, (o7_char *)"Expected 'END'");
		break;
	case -106:
		O(12, (o7_char *)"Expected '.'");
		break;
	case -107:
		O(28, (o7_char *)"Expected имя модуля");
		break;
	case -108:
		O(12, (o7_char *)"Expected '='");
		break;
	case -109:
		O(12, (o7_char *)"Expected ')'");
		break;
	case -110:
		O(12, (o7_char *)"Expected ']'");
		break;
	case -111:
		O(12, (o7_char *)"Expected '}'");
		break;
	case -112:
		O(11, (o7_char *)"Expected OF");
		break;
	case -115:
		O(11, (o7_char *)"Expected TO");
		break;
	case -116:
		O(59, (o7_char *)"Expected structured type: array, record, pointer, procedure");
		break;
	case -117:
		O(15, (o7_char *)"Expected record");
		break;
	case -118:
		O(18, (o7_char *)"Expected statement");
		break;
	case -119:
		O(13, (o7_char *)"Expected THEN");
		break;
	case -120:
		O(11, (o7_char *)"Expected :=");
		break;
	case -122:
		O(50, (o7_char *)"Expected variable, which type is record or pointer");
		break;
	case -124:
		O(13, (o7_char *)"Expected type");
		break;
	case -125:
		O(14, (o7_char *)"Expected UNTIL");
		break;
	case -126:
		O(11, (o7_char *)"Expected DO");
		break;
	case -128:
		O(19, (o7_char *)"Expected designator");
		break;
	case -130:
		O(18, (o7_char *)"Expected procedure");
		break;
	case -131:
		O(25, (o7_char *)"Expected name of constant");
		break;
	case -132:
		O(35, (o7_char *)"Expected procedure's name after end");
		break;
	case -133:
		O(19, (o7_char *)"Expected expression");
		break;
	case -135:
		O(10, (o7_char *)"Excess ';'");
		break;
	case -150:
		O(46, (o7_char *)"Name after end do not match with module's name");
		break;
	case -151:
		O(28, (o7_char *)"Too many dimensions in array");
		break;
	case -152:
		O(49, (o7_char *)"Name after end do not match with procedure's name");
		break;
	case -153:
		O(49, (o7_char *)"Declaration of procedure with return must have ()");
		break;
	case -134:
		O(25, (o7_char *)"Expected number or string");
		break;
	case -136:
		O(51, (o7_char *)"Unexpected '='. Maybe, you mean ':=' for assignment");
		break;
	case -137:
		O(48, (o7_char *)"As label in CASE not accepted not 1 char strings");
		break;
	default:
		abort();
		break;
	}
}

extern void MessageEn_Usage(void) {
	S(36, (o7_char *)"Translator from Oberon-07 to C. 2017");
	S(7, (o7_char *)"Usage: ");
	S(13, (o7_char *)"  1) o7c help");
	S(56, (o7_char *)"  2) o7c to-c   Script OutDir {-m PTM|-i PTI|-infr Infr}");
	S(74, (o7_char *)"  3) o7c to-bin Script Result {-m PTM|-i PTI|-infr Infr|-c PTHC|-cc CComp}");
	S(74, (o7_char *)"  4) o7c run    Script {-m PTM|-i PTI|-c PTHC|-cc CComp} [-t temp] -- opts");
	S(66, (o7_char *)"Script = Call { ; Call } . Call = Module.Procedure[(Parameters)] .");
	S(49, (o7_char *)"PTM - Path To directories with Modules for search");
	S(76, (o7_char *)"PTI - Path To directories with Interface Modules without real implementation");
	S(77, (o7_char *)"PTHC - Path To directories with .h & .c -implementations of interface modules");
	S(58, (o7_char *)"Infr - path to infrastructure. '-infr p' is shortening to:");
	S(74, (o7_char *)"  -i p/singularity/definition -c p/singularity/implementation -m p/library");
	S(47, (o7_char *)"CComp - C Compiler for build generated .c-files");
}

extern void MessageEn_CliError(int err, int cmd_len0, o7_char cmd[/*len0*/]) {
	switch (err) {
	case -10:
		MessageEn_Usage();
		break;
	case -11:
		S(28, (o7_char *)"Too long name of source file");
		Out_Ln();
		break;
	case -12:
		S(25, (o7_char *)"Too long destination name");
		Out_Ln();
		break;
	case -13:
		S(24, (o7_char *)"Can not open source file");
		break;
	case -14:
		S(32, (o7_char *)"Can not open destination .h file");
		break;
	case -15:
		S(32, (o7_char *)"Can not open destination .c file");
		break;
	case -16:
		O(17, (o7_char *)"Unknown command: ");
		S(cmd_len0, cmd);
		MessageEn_Usage();
		break;
	case -17:
		O(43, (o7_char *)"Not enough count of arguments for command: ");
		S(cmd_len0, cmd);
		break;
	case -18:
		S(43, (o7_char *)"Too long overall length of paths to modules");
		break;
	case -19:
		S(25, (o7_char *)"Too many paths to modules");
		break;
	case -20:
		S(44, (o7_char *)"Too long overall length of paths to .c files");
		break;
	case -21:
		S(37, (o7_char *)"Too long length of C compiler options");
		break;
	case -22:
		S(36, (o7_char *)"Too long name of temporary directory");
		break;
	case -23:
		S(28, (o7_char *)"Error during C compiler call");
		break;
	case -24:
		S(29, (o7_char *)"Too long command line options");
		break;
	case -25:
		S(17, (o7_char *)"Unexpected option");
		break;
	case -26:
		S(29, (o7_char *)"Unknown initialization method");
		break;
	case -27:
		S(31, (o7_char *)"Can not create output directory");
		break;
	case -28:
		S(31, (o7_char *)"Can not remove output directory");
		break;
	default:
		abort();
		break;
	}
}

extern void MessageEn_Text(int str_len0, o7_char str[/*len0*/]) {
	O(str_len0, str);
}

extern void MessageEn_init(void) {
	static int initialized = 0;
	if (0 == initialized) {
		Ast_init();
		Parser_init();
		CliParser_init();
		Scanner_init();
		Out_init();
		Utf8_init();

	}
	++initialized;
}

